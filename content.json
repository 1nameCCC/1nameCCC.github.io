{"meta":{"title":"这是一个主标题","subtitle":"测试阶段","description":"学习一下","author":"CCC","url":"http://1nameccc.github.io","root":"/"},"pages":[{"title":"Android","date":"2024-09-06T14:02:06.000Z","updated":"2024-09-09T09:09:04.312Z","comments":true,"path":"Android/index.html","permalink":"http://1nameccc.github.io/Android/index.html","excerpt":"","text":""},{"title":"categories |分类 |归档","date":"2024-09-06T13:10:05.000Z","updated":"2024-09-07T09:25:42.560Z","comments":false,"path":"categories/index.html","permalink":"http://1nameccc.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags | 标签","date":"2024-09-06T13:09:51.000Z","updated":"2024-09-10T07:39:08.029Z","comments":true,"path":"tags/index.html","permalink":"http://1nameccc.github.io/tags/index.html","excerpt":"","text":""},{"title":"pagename","date":"2024-09-06T13:52:49.000Z","updated":"2024-09-06T13:52:49.941Z","comments":true,"path":"pagename/index.html","permalink":"http://1nameccc.github.io/pagename/index.html","excerpt":"","text":""}],"posts":[{"title":"嵌软笔试面试——基础","slug":"0-1-嵌软笔试面试/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:45:55.585Z","comments":true,"path":"2023/08/01/0-1-嵌软笔试面试/index/","permalink":"http://1nameccc.github.io/2023/08/01/0-1-%E5%B5%8C%E8%BD%AF%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/index/","excerpt":"嵌入式软件笔试面试","text":"嵌入式软件笔试面试 #define 声明 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）答案： #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL我在这想看到几件事情： #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等） 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。 “标准”宏MIN 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。答案： #define MIN(A,B) （（A） &lt;&#x3D; (B) ? (A) : (B))这个测试是为下面的目的而设的： 标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。 懂得在宏中小心地把参数用括号括起来 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？ least &#x3D; MIN(*p++, b)； 死循环 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？这个问题用几个解决方案。我首选的方案是： while(1){} 一些程序员更喜欢如下方案： for(;;){} 这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是：”我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。 第三个方案是用 gotoLoop:…goto Loop;应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC&#x2F;FORTRAN程序员。 数据声明 a) 一个整型数（An integer）b)一个指向整型数的指针（ A pointer to an integer）c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）rd)一个有10个整型数的数组（ An array of 10 integers）e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ） 答案是：a) int a; &#x2F;&#x2F; An integerb) int *a; &#x2F;&#x2F; A pointer to an integerc) int **a; &#x2F;&#x2F; A pointer to a pointer to an integerd) int a[10]; &#x2F;&#x2F; An array of 10 integerse) int *a[10]; &#x2F;&#x2F; An array of 10 pointers to integersf) int (*a)[10]; &#x2F;&#x2F; A pointer to an array of 10 integersg) int (*a)(int); &#x2F;&#x2F; A pointer to a function a that takes an integer argument and returns an integerh) int (*a[10])(int); &#x2F;&#x2F; An array of 10 pointers to functions that take an integer argument and return an integer static的作用 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 const含意 我只要一听到被面试者说：”const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着”只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？ const int a;int const a;const int *a;int * const a;int const * a const; 前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？ 我也如下的几下理由： 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。） 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。 volatile含意 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 并行设备的硬件寄存器（如：状态寄存器） 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 多线程应用中被几个任务共享的变量 回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。1)一个参数既可以是const还可以是volatile吗？解释为什么。2); 一个指针可以是volatile 吗？解释为什么。3); 下面的函数有什么错误： int square(volatile int *ptr){ return *ptr * *ptr;} 下面是答案：1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。\\3) 这段代码有点变态。这段代码的目的是用来返指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码： int square(volatile int *ptr){ int a,b; a &#x3D; *ptr; b &#x3D; *ptr; return a * b;} 由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下： long square(volatile int *ptr){ int a; a &#x3D; *ptr; return a * a;} 位操作 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。对这个问题有三种基本的反应 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。 最佳的解决方案如下： #define BIT3 (0x1 &lt;&lt; 3)static int a; void set_bit3(void){ a |&#x3D; BIT3;}void clear_bit3(void){ a &amp;&#x3D; ~BIT3;} 一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|&#x3D;和&amp;&#x3D;~操作。 访问固定的内存位置 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下： int *ptr; ptr &#x3D; (int *)0x67a9; *ptr &#x3D; 0xaa55; A more obscure approach is:一个较晦涩的方法是： *(int * const)(0x67a9) &#x3D; 0xaa55; 即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。 中断 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。 __interrupt double compute_area (double radius){ double area &#x3D; PI * radius * radius; printf(“\\nArea &#x3D; %f”, area); return area;} 这个函数有太多的错误了，以至让人不知从何说起了： ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。 ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。 在许多的处理器&#x2F;编译器中，浮点一般都是不可重入的。有些处理器&#x2F;编译器需要让额处的寄存器入栈，有些处理器&#x2F;编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。 代码分析123456void foo(void)&#123; unsigned int a = 6; int b = -20; (a+b &gt; 6) ? puts(&quot;&gt; 6&quot;) : puts(&quot;&lt;= 6&quot;);&#125; 这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 “&gt;6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。 评价代码123456unsigned int zero = 0;unsigned int compzero = 0xFFFF; /*1&#x27;s complement of zero */// 对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：unsigned int compzero = ~0; 这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧… 动态内存分配 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？ 12345char *ptr;if ((ptr = (char *)malloc(0)) == NULL) puts(&quot;Got a null pointer&quot;);else puts(&quot;Got a valid pointer&quot;); 这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。 Typedef Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子： #define dPS struct s *typedef struct s * tPS; 以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子： dPS p1,p2;tPS p3,p4; 第一个扩展为 struct s * p1, p2; 上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。 晦涩的语法 C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？ int a &#x3D; 5, b &#x3D; 7, c;c &#x3D; a+++b; 这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成： c &#x3D; a++ + b; 因此, 这段代码持行后a &#x3D; 6, b &#x3D; 7, c &#x3D; 12。如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。","categories":[{"name":"嵌软笔试面试","slug":"嵌软笔试面试","permalink":"http://1nameccc.github.io/categories/%E5%B5%8C%E8%BD%AF%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"嵌软笔试面试","slug":"嵌软笔试面试","permalink":"http://1nameccc.github.io/tags/%E5%B5%8C%E8%BD%AF%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"}],"author":"coucou"},{"title":"C语言——指针&数组","slug":"1-2-C语言-指针&数组/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:55:51.461Z","comments":true,"path":"2023/08/01/1-2-C语言-指针&数组/index/","permalink":"http://1nameccc.github.io/2023/08/01/1-2-C%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88&%E6%95%B0%E7%BB%84/index/","excerpt":"C语言——指针&amp;数组","text":"C语言——指针&amp;数组 指针 指针是一种编程概念，它是一个变量或数据类型，用于存储内存地址。指针允许程序直接访问和操作内存中的数据，而不仅仅是访问变量的值。指针通常在低级编程语言（如C和C++）中使用，以及某些高级编程语言中的底层编程任务中。 关键要点关于指针包括： 内存地址：指针存储一个内存地址，该地址指向计算机内存中的某个位置。 指向：指针可以指向内存中的数据，这可以是基本数据类型（如整数、字符）或复杂的数据结构（如数组、结构体）。 解引用：通过解引用指针，可以访问指针所指向的内存地址上的值。解引用操作使用 * 符号。 地址运算：指针可以进行地址运算，例如指针加法或减法，以访问相邻内存位置。 动态内存分配：指针在动态内存分配中非常有用，允许程序在运行时分配和释放内存，避免静态内存分配的限制。 传递参数：指针允许将变量的地址传递给函数，以便在函数内部修改变量的值。 好处 指针可以动态分配内存 在链表中可以方便修改链表的节点 解析字符串 相同类型的指针可以直接复制 调用Free释放内存后，指针还能用吗 Free释放掉内存后，只是把内存的使用权就被归还给系统，内存里面的东西可能被清除也可能是垃圾值，但是指向这个内存的指针还是指向这块内存，并不会NULL 指针不能加指针 指针之间可以做减法，但不能做加法 空指针是指指向地址为0的地方 数组 初始化 12345&gt;int a[][2]; //不允许&gt;int b[][2]=&#123;1,2,3,4&#125;; //可以&gt;int c[] = &#123;1,2,3&#125;; // 可以&gt;int c[]; //不可以&gt;int d[][]; //不允许，第二个[]必须填，不管有没有初始化 数组名num &#x2F; &amp;num的区别 对于一维数组来说 num+1是偏移到下个元素，&amp;num+1是偏移整个数组 对于二维数组来说 num+1是偏移一个一维数组，&amp;num+1是整个数组 数组下标是负数 12345678910&gt;int a[5] = &#123;0,1,2,3,4&#125;;&gt;int *p = &amp;a[4];&gt;for(int i=-4; i&lt;=0; i++)&gt;&#123;printf(%d %d \\n&quot;, p[i], &amp;p[i])&gt;&#125;&gt;// 0 1310572&gt;// 1 1310576&gt;// 2 1310580&gt;…… 二维数组 int a[3][3]; int a[3][3];表示是个三行三列的二维数组 数组名表示数组首元素的地址，即第0行第0个地址 a+1表示地址偏移一个一维数组的地址，即三列int大小&#x3D;34 &#x3D; 12 *a 表示去二维变一维，*a就相当于一维数组的数组名，比如 *a +1 表示第0行下标为1的元素地址，只是偏移一个Int地址 若要表示a[2][2]的元素 即 *(*(a+2)+2) 指针的运算 123456789&gt;// 例子1：&gt;int *ptr;//假设指针指向的地址是0x 00 00 00 00&gt;Ptr++; //运算之后指针指向0x 00 00 00 04&gt;Char *p;&gt;P++;//地址偏移1&gt;// 注意:对于一级指针的++操作偏移量要看指针指向的是什么类型&gt;// 对应二级指针偏移量，对于32系统是4个字节，因为二级指针指向的类型就是指针，所以永远是一个指针类型的大小 1234567891011&gt;// 例子2：&gt;#include&lt;stdio.h&gt; &gt;int main() &gt;&#123; char a[20]=&quot;You_are_a_girl&quot;; char *p=a; char **ptr=&amp;p; printf(&quot;**ptr=%c\\n&quot;,**ptr); ptr++; printf(&quot;**ptr=%c\\n&quot;,**ptr); &gt;&#125;&gt;// 在这个例子中是无法确定二级指针++之后指向的地址内容，因为二级指针(ptr)指针指向的一级指针的地址，如果二级指针(ptr)++之后，那么就会指向一级指针的后4个字节(对于32位操作系统来说指针类型是4字节)，至于这个地址里面是啥无从得知 123456789101112131415161718&gt;// *p++ *(p++) (*p)++ *++p ++*p 的运算&gt;int num[] = &#123;1, 2, 3, 4&#125;;&gt;1. 后++先不用管，即先把地址里面的值给别人，再去++，可以是地址或值(看括号是否包住*p,是则是值++)，后++有三种如下：&gt;(*p)++ 地址前后都不会变化，变化的是地址里面的值，先赋值给别人，*P再++&gt;*(p++)和*p++一样 地址发生变化，先把*P赋值给别人，再++地址&gt;2.前++，先++操作，可以是++地址或者值，(++符号靠近p就是地址++，靠近*P就是值++)，再把值给别人&gt;*++p 地址发生改变，先把地址++，再把地址变化后的里面的值给别人&gt;++*p 地址不发生变化，*P的值++之后再赋值给别人&gt;注意:指针++,到底加几个字节要根据指针指向的类型决定，指针在32系统中永远是4个字节&gt;举例子：&gt;Int * a;//假设指针指向的地址0&gt;a++;//此时指针指向后移4个字节，即指向4&gt;Char *b;//假设指针指向的地址0&gt;b++；//此时指针指向后移1个字节，即指向1 12345&gt;// sizeof(数组名)和sizeof(&amp;数组)&gt;int Num[100];&gt;printf(&quot;%ld\\n&quot;,sizeof(Num));//400&gt;printf(&quot;%ld\\n&quot;,sizeof(&amp;Num));//8起始就是打印int *指针大小&gt;printf(&quot;%ld\\n&quot;,sizeof(int *));//8 指针数组 12345&gt;// 首先是个数组，这个数组里的元素是指针&gt;int *p [4];&gt;int a[4]=&#123;1,2,3,4&#125;;&gt;p[0]=&amp;a[0];&gt;printf(&quot;%d\\n&quot;,*p[0]); 123456789&gt;// 首先是个指针，这个指针指向数组例如：&gt;Int (*p) [4];//表示一个指向有4个int 元素的数组的指针，所以p+1，加的是4个int&gt;int num[8] =&#123;1,2,3,4,5,6,7,8&#125;;&gt;int (*p)[4] ;&gt;p = num;&gt;printf(&quot;%d\\n&quot;,sizeof(p));//8 因为p是指针，64位系统8个字节&gt;printf(&quot;%p\\n&quot;,p);//0x7ffe11d8a4e0 &gt;printf(&quot;%p\\n&quot;,p+1);//0x7ffe11d8a4f0 //加的是指针指向的类型大小，这里指针指向的是有四个4int元素的数组，所以加的是16个字节 12345&gt;// 双指针&gt;int b[12] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;&gt;int (*p)[4];&gt;p = b;&gt;printf(&quot;%d\\n&quot;, **(++p)); // 5 指针函数 1234&gt;// 函数的返回值是个指针类型&gt;int * fun(int x,int y)&#123; &gt;&#125; 函数指针 12345&gt;int (*pf)(float);&gt;// 函数指针调用函数事注意以下几点：&gt;1. 函数类型必须和函数指针的类型一样，比如参数类型，返回值&gt;2. 给函数指针赋值是可以&amp;也可以不要 指针和数组的区别 数据类型: 指针是一种数据类型，用于存储内存地址。指针可以指向不同数据类型的内存位置。 数组是一种数据结构，用于存储相同数据类型的一组连续内存单元。 大小: 指针的大小通常与系统架构相关，它存储一个内存地址，因此大小在不同系统上可能会有所不同。 数组的大小是由其包含的元素数量决定，每个元素的大小也是相同的。 初始化和赋值: 指针需要显式初始化为一个有效的内存地址，可以通过将其设置为某个变量的地址来初始化。 数组在声明时需要指定大小，而且在创建时会自动初始化，可以直接为数组元素赋值。 地址运算: 指针允许进行地址运算，例如指针加法或减法，以访问内存中的相邻位置。 数组的元素在内存中是连续存储的，因此可以通过索引来访问不同的元素。 传递给函数: 指针可以用于将变量的地址传递给函数，以便在函数内部修改变量的值。 数组在传递给函数时通常会退化为指针，因此函数接收到的是指向数组第一个元素的指针。 动态内存分配: 指针可用于动态内存分配，例如使用 malloc 或 new 来分配内存，然后通过指针访问分配的内存。 数组的大小通常在编译时确定，但C99标准引入了可变长度数组（VLA），允许在运行时指定数组大小。 指针和引用的区别 指针： 指针是一个变量，它存储另一个变量的内存地址。 指针可以为空（null），也可以重新分配给指向不同的变量。 指针需要使用解引用操作符 * 来访问所指向的值。 指针可以进行指针算术，如指针加法或减法。 指针可以指向不同类型的对象，但需要进行强制类型转换。 指针可能需要显式地管理内存，包括分配和释放内存。 引用： 引用是一个别名，它为已经存在的变量提供了另一个名称。 引用在创建时必须与现有变量绑定，无法改变绑定到不同的变量。 引用的语法更简洁，不需要解引用操作符，直接使用引用就可以访问所绑定的值。 引用不支持指针算术。 引用通常用于传递参数给函数，以便在函数内部修改参数的值。 引用不需要显式管理内存，不涉及内存分配和释放。 引用区别于指针的特性是 ： 不存在空引用（保证不操作空指针） 必须初始化（保证不是野指针） 一个引用永远指向他初始化的那个对象（保证指针值不变） 野指针 野指针：是指指针指向的地址是不确定的； 野指针（Dangling Pointer）通常是指指针变量存储了一个无效的内存地址，也就是它指向的内存区域可能已经被释放或不再有效。野指针的操作是不安全的，因为它们可能导致未定义的行为或程序崩溃。 野指针一般来说可以被重新赋值，但这并不会解决野指针的问题。重新赋值一个野指针只是改变了它的目标地址，但仍然可能会导致访问无效内存。在C和C++中，遵循以下最佳实践来处理野指针： 避免野指针：在使用指针前，确保它指向有效的内存区域。不要让指针指向已释放的内存或未分配的内存。 初始化指针：在声明指针时，始终将其初始化为NULL（C语言）或nullptr（C++语言）。这可以帮助你检测是否有野指针。 谨慎使用已释放的内存：如果确实要使用已释放的内存，确保在释放内存后不再访问它。 不要多次释放相同的内存：释放内存后，不要再次释放相同的内存块，否则会导致问题。 原因： 释放内存之后，指针没有及时置空 避免： 初始化置NULL 申请内存后判空 指针释放后置NULL 使用智能指针 12345&gt;int *p1 = NULL; //初始化置NULL&gt;p1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 &gt;assert(p1 != NULL); //判空，防错设计&gt;free(p1); &gt;p1 = NULL; //释放后置空 指针 &amp; const 1234&gt;const int* p; //常量指针-----&gt;指针指向的地址的内容不可以改变&gt;int const *p; //常量指针&gt;int * const p; // 指针常量--------&gt;指针指向的地址可以不改变&gt;const int * const p; //指向常量的常量指针 指针减指针 1234567891011121314&gt;// 地址相减 = （地址a -地址b）/sizeof（指针指向的类型）&gt;int a[3];&gt;a[0] = 0;&gt;a[1] = 1;&gt;a[2] = 2;&gt;int *p, *q;&gt;p = a;&gt;q = &amp;a[2];&gt;printf(&quot;%p\\n&quot;,p);//0x7ffe80e38b0c &gt;printf(&quot;%p\\n&quot;,q);//0x7ffe80e38b14 &gt;printf(&quot;%d\\n&quot;,q-p);//2 ( q - p) /sizeof(int )&gt;// 那么就有&gt;a[q-p] = a[2] = 2 指针作为函数参数传递问题 1234567891011121314151617181920212223242526272829303132&gt;//函数1，交换两个数&gt;void swap1(int *p,int *q)&gt;&#123; int num = *p; *p =*q; *q = num;&gt;&#125;&gt;//函数2，让p指针指向a，想重新给p赋值为90，之后再交换p,q&gt;void swap(int *p,int *q)&gt;&#123; int a =90;p = &amp;a; int num = *p; *p =*q; *q = num;&gt;&#125;&gt;int main()&gt;&#123;int a =2,b =3;int * j = &amp;a; // 指针j指向aint * k =&amp;b; //指针 k 指向 bswap(j,k); //调用函数printf(&quot;a =%d b= %d\\n&quot;,a,b);// a = 2 b = 90; return 0;&gt;&#125;&gt;// 于函数swap1我们可以正常交换两个值，但是swap函数却不是我们想要的，我们想要的答案是 a = 3 b = 90;可是发现，a的值压根没变，这是为什么呢？&gt;// 在swap函数中，你将指针p指向了一个局部变量a，而这个局部变量在swap函数执行完毕后将被销毁。这会导致指针p指向一个不再有效的内存位置&gt;总结：&gt;如果在函数形参里的指针变量不修改指向，那么就会影响传递过来的指针 12345678910111213141516171819202122232425&gt;void fun(char *s) &#123; char a[10]; strcpy(a, &quot;STRING&quot;); s = a;//修改了形参指针指向，就不会影响传递过来指针&gt;&#125;&gt;void main() &#123; char *p = &quot;PROGRAM&quot;; fun(p); printf(&quot;%s\\n&quot;, p); //PROGRAM&gt;&#125;&gt;// 拓展：通过二级指针操作&gt;void fun(char **s) &#123; char a[10]; strcpy(a, &quot;STRING&quot;);*s = a; // *s = &quot;string&quot;;&gt;&#125;&gt;int main() &#123; char *p = &quot;PROGRAM&quot;; fun(&amp;p); printf(&quot;%s\\n&quot;, p); //打印空白return 0;&gt;&#125;&gt;// 在这里我们通过把一级指针的地址传递给函数，函数二级形参来接受，那么*s表示的就是指针p指向的地址，可以看出这里直接就操作p的指针指向，所以如果 *s = “string”那么指针p就会指向”string”的地址 二维数组和数组指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&gt;int main()&gt;&#123; /*二维数组和数组指针*/ int (*p)[3]; int s[3][3]=&#123;1,4,7,4,9,6,2,7,9&#125;; p = s; printf(&quot;p addr is = %p\\n&quot;,p);//0x7ffde8cdf0a0 printf(&quot;s addr is = %p\\n&quot;,s);//0x7ffde8cdf0a0 /*可以发现p+1和s+1是一样的都是加一个一维数组*/ printf(&quot;p + 1 addr is = %p\\n&quot;,p + 1);//0x7ffde8cdf0ac printf(&quot;s + 1 addr is = %p\\n&quot;,s + 1);//0x7ffde8cdf0ac /*可以发现使用p表示二维数组的元素和二维数组名表示元素是一样的用法*/ printf(&quot;*(*(p + 1)) is = %d\\n&quot;,*(*(p + 1)));//*(*(p + 1)) is = 4 printf(&quot;*(*(s + 1)) is = %d\\n&quot;,*(*(s + 1)));//*(*(s + 1)) is = 4 printf(&quot;*(p[1]+0) is = %d\\n&quot;,*(p[1]+0));//*(p[1]+0) is = 4 printf(&quot;*(s[1]+1) is = %d\\n&quot;,*(s[1]+1));//*(s[1]+1) is = 9 return 0;&gt;&#125;&gt;// 一维数组：&gt;int num[2]; &gt;printf(&quot;%p \\n&quot;,num); //0x7fffe2a8cde8&gt;printf(&quot;%p \\n&quot;,num+1); //0x7fffe2a8cdec &gt;printf(&quot;%p \\n&quot;,&amp;num+1); //0x7fffe2a8cdf0 &gt;// 可以看出：&gt;num +1 加的是一个Int&gt;&amp;num + 1加的是整个数组&gt;// 二维数组;&gt;int num[2][2];&gt;printf(&quot;%p \\n&quot;,num); //0x7ffe18f73560 &gt;printf(&quot;%p \\n&quot;,num+1); //0x7ffe18f73568 &gt;printf(&quot;%p \\n&quot;,&amp;num+1); //0x7ffe18f73570 &gt;// 可以看出：&gt;num +1 加的是一个一维&gt;&amp;num + 1加的是整个数组 &gt;// 例子 &gt;int main() &gt;&#123; int num[2][3]=&#123;1,2,3,4,5,6&#125;; int (*p)[3]; p = num; printf(&quot;%p\\n&quot;,p);//0x7ffffad71df0 printf(&quot;%p\\n&quot;,p+1);//0x7ffffad71dfc printf(&quot;%p\\n&quot;,num[0]+1);//0x7ffffad71df4 printf(&quot;%p\\n&quot;,*p+1);//0x7ffffad71df4// 注意这里&amp;p+1 printf(&quot;%p\\n&quot;,&amp;num+1);//0x7ffffad71e08 printf(&quot;%d\\n&quot;,**p);//1&gt;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"指针&数组篇","slug":"指针-数组篇","permalink":"http://1nameccc.github.io/tags/%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84%E7%AF%87/"}],"author":"coucou"},{"title":"嵌软笔试面试——经典题","slug":"0-2-嵌软笔试面试-经典/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:38:18.846Z","comments":true,"path":"2023/08/01/0-2-嵌软笔试面试-经典/index/","permalink":"http://1nameccc.github.io/2023/08/01/0-2-%E5%B5%8C%E8%BD%AF%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95-%E7%BB%8F%E5%85%B8/index/","excerpt":"嵌软笔试面试——经典题","text":"嵌软笔试面试——经典题 零值 1、请填写 bool , float, 指针变量 与“零值”比较的 if语句。 提示：这里“零值”可以是 0, 0.0 , FALSE 或者“空指针”。例如 int 变量 n 与“零值”比较的 if 语句为： if ( n &#x3D;&#x3D; 0 ) if ( n !&#x3D; 0 ) 以此类推。 （1） 请写出 bool flag 与“零值”比较的 if 语句： 【标准答案】if ( flag ) if ( !flag ) 如下写法不得分 if(flag &#x3D;&#x3D; TRUE) || if(flag &#x3D;&#x3D; 1) || if(flag &#x3D;&#x3D; FLASE) || if(flag &#x3D;&#x3D; 0) （2）请写出 float x 与“零值”比较的 if 语句： 【标准答案】 const float EPSINON &#x3D; 0.00001; if ((x &gt;&#x3D; - EPSINON) &amp;&amp; (x &lt;&#x3D; EPSINON) 不可将浮点变量用“&#x3D;&#x3D;”或“！&#x3D;”与数字比较，应该设法转化成“&gt;&#x3D;”或“&lt;&#x3D;”此类形式。 如下写法不得分 if( x &#x3D;&#x3D; 0.0) || if(x !&#x3D; 0.0) （3） 请写出 char *p 与“零值”比较的 if 语句 【标准答案】 if (p &#x3D;&#x3D; NULL) if (p !&#x3D; NULL) 如下写法不得分 if(p &#x3D;&#x3D; 0) || if(p) sizeof计算 以下为 Linux下的 32 位 C程序，请计算 sizeof 的值。 char str[] &#x3D; “Hello” ; char *p &#x3D; str ; int n &#x3D; 10; 请计算 （1）sizeof (str ) &#x3D; （2）sizeof ( p ) &#x3D; （3） sizeof ( n ) &#x3D; 【标准答案】（1）6、（2）4、（3）4 （4） void Func ( char str[100]){} 请计算 sizeof( str ) &#x3D; （5） void *p &#x3D; malloc( 100 ); 请计算sizeof ( p ) &#x3D; 【标准答案】（4）4、（5）4 变量定义 用变量a给出下面的定义 e) 一个有10个指针的数组，该指针是指向一个整型数的; f) 一个指向有10个整型数数组的指针 ; g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数; h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数; 【标准答案】 e)int * a[10]; f)int (*a)[10] * *g)int (*a)(int); h) int (*a[10])(int) 分析代码 设有以下说明和定义： 123456&gt;typedef union &#123; long i; int k[5]; char c;&gt;&#125; DATE; &gt;struct data &#123; int cat; DATE cow; double dog; &gt;&#125; too; DATE max; 则语句 printf(“%d”,sizeof(struct date)+sizeof(max));的执行结果是： 【标准答案】DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20 data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 &#x3D; 32. 所以结果是 20 + 32 &#x3D; 52. 当然…在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 &#x3D; 20 请问以下代码有什么问题： 12345678&gt;int main()&gt;&#123; char a; char *str=&amp;a; strcpy(str,&quot;hello&quot;); printf(str); return 0;&gt;&#125; 【标准答案】没有为str分配内存空间，将会发生异常问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。 请问以下代码有什么问题： 1234&gt;char* s=&quot;AAA&quot;;&gt;printf(&quot;%s&quot;,s);&gt;s[0]=&#x27;B&#x27;;&gt;printf(&quot;%s&quot;,s); 有什么错？ 【标准答案】”AAA”是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。 cosnt char* s&#x3D;”AAA”; 然后又因为是常量，所以对是s[0]的赋值操作是不合法的。 12345678910111213141516171819void getmemory(char *p)&#123; p=(char *) malloc(100); strcpy(p,“hello world”);&#125;int main( )&#123; char *str=NULL; getmemory(str); printf(“%s/n”,str); free(str); return 0;&#125;// 会出现什么问题？答案: 程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险。 void main()&#123; char aa[10]; printf(“%d”,strlen(aa));&#125;// 会出现什么问题？打印结果是是多少？【标准答案】sizeof()和初不初始化，没有关系，strlen()和初始化有关，打印结果值未知。 1234char szstr[10]; strcpy(szstr,&quot;0123456789&quot;); // 产生什么结果？为什么？【标准答案】长度不一样，出现段错误。 请简述以下两个 for 循环的优缺点。 数组和链表的区别 数组：数据顺序存储，固定大小； 链表：数据可以随机存储，大小可动态改变 解释代码 int (*s[10])(int) 表示的是什么啊 【标准答案】int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 c和c++中的struct有什么不同？ 【标准答案】c和c++中struct的主要区别是c中的struct 不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同， struct默认为public，而class默认为private 12345678&gt;int main()&gt;&#123;int x=3; printf(&quot;%d&quot;,x); return 1;&gt;&#125;&gt;// 问函数既然不会被其它函数调用，为什么要返回1？&gt;【标准答案】mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息。 struct计算123456789101112131415161718192021222324struct A&#123; char t:4; char k:4; unsigned short i:8; unsigned long m;&#125;;// 问sizeof(A) = ?【标准答案】8struct name1&#123; char str; short x; int num;&#125;；// 求sizeof(name1)?【标准答案】8 struct name2&#123; char str; int num; short x;&#125;;// 求sizeof(name2)？【标准答案】12 分析(指针)12345678910111213// 程序哪里有错误wap( int* p1,int* p2 )&#123; int *p; *p = *p1; *p1 = *p2; *p2 = *p;&#125;【标准答案】p为野指针 (void *)ptr 和 (*(void**))//ptr的结果是否相同？其中ptr为同一个指针。【标准答案】(void *)ptr 和 (*(void**))ptr值是相同的 指针123456789101112131415/* 要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？ */【标准答案】*((void (*)( ))0x100000 ) ( );首先要将0x100000强制转换成函数指针,即: (void (*)())0x100000然后再调用它:*((void (*)())0x100000)();/* 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。 */【参考答案】这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：int *ptr;ptr = (int *)0x67a9;*ptr = 0xaa55; 内存分析 堆栈溢出一般是由什么原因导致的？ 【标准答案】没有回收垃圾资源。 关于内存的思考题（1）你能看出有什么问题？ volatile 关键字volatile有什么含意? 并给出三个不同的例子。 【参考答案】一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 1). 并行设备的硬件寄存器（如：状态寄存器） 2). 一个中断服务子程序中会访问到的非自动变量 3). 多线程应用中被几个任务共享的变量 关键字volatile有什么含意？ 【标准答案】提示编译器对象的值可能在编译器未监测到的情况下改变。 头文件 头文件中的 ifndef&#x2F;define&#x2F;endif 干什么用？ 【标准答案】防止该头文件被重复引用。 #include &lt;filename.h&gt; 和 #include “filename.h” 有什么区别？ 【标准答案】对于#include &lt;filename.h&gt; ，编译器从标准库路径开始搜索 filename.h ; 对于#include “filename.h” ，编译器从用户的工作路径开始搜索 filename.h 。 如何引用一个已经定义过的全局变量？ 【标准答案】可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变量写错了 ，那么在编译期间会报错，如果你用extern方式引用 时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。 全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？ 【标准答案】可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。 const &amp; static const 有什么用途？（请至少说明两种） 【标准答案】： （1）可以定义 const 常量 （2）const 可以修饰函数的参数、返回值，甚至函数的定义体。被 const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。 static有什么用途？（请至少说明两种） 【标准答案】 限制变量的作用域（static全局变量）； 设置变量的存储域（static局部变量）。 A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）? 【标准答案】static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。 他们都放在静态数据区，但是编译器对他们的命名是不同的。 如果要使变量在其他模块也有意义的话，需要使用extern关键字。 static全局变量与普通的全局变量有什么区别？ 【标准答案】 static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别 【标准答案】static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别？ 【标准答案】static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 堆栈 队列和栈有什么区别？ 【标准答案】队列先进先出，栈后进先出。 Heap与stack的差别。 【标准答案】Heap是堆，stack是栈。 Stack的空间由操作系统自动分配&#x2F;释放，Heap上的空间手动分配&#x2F;释放。Stack空间有限，Heap是很大的自由存储区C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行 程序的局部变量存在于栈(stack)中，全局变量存在于静态数据区 中，动态申请数据存在于堆（ heap）中。 用两个栈实现一个队列的功能？要求给出算法和思路！ 【参考答案】设2个栈为A,B, 一开始均为空. 入队: 将新元素push入栈A; 出队: (1) 判断栈B是否为空； (2) 如果不为空，则将栈A中所有元素依次pop出并push到栈B； (3) 将栈B的栈顶元素pop出； 宏&amp;编译 用宏定义写出swap（x，y），即交换两数。 【标准答案】 #define swap(x, y) (x)&#x3D;(x)+(y);(y)&#x3D;(x)–(y);(x)&#x3D;(x)–(y); 写一个“标准”宏，这个宏输入两个参数并返回较小的一个。 【标准答案】#define Min(X, Y) ((X)&gt;(Y)?(Y):(X))&#x2F;&#x2F;结尾没有; 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题） 【参考答案】#define SECONDS_PER_YEAR (60 * 60* 24 * 365)UL 已知一个数组table，用一个宏定义，求出数据的元素个数。 【标准答案】 #define NTBL(table) (sizeof(table)&#x2F;sizeof(table[0])) 什么是预编译，何时需要预编译： 【标准答案】１、总是使用不经常改动的大型代码体。 ２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子： #define dPS struct s * typedef struct s * tPS; 以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？ 【参考答案】这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子： dPS p1,p2; tPS p3,p4; 第一个扩展为 struct s * p1, p2; 上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。 extern “C” 在 C++ 程序中调用被 C 编译器编译后的函数， 为什么要加 extern “C”？ 【标准答案】C++语言支持函数重载，C 语言不支持函数重载。函数被 C++编译后在库中的名字与 C 语言的不同。假设某个函数的原型为： void foo(int x, int y); 该函数被 C 编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int 之类的名字。 C++ 提供了 C 连接交换指定符号 extern“C”来解决名字匹配问题。 代码分析2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 1. 请写出下列代码的输出内容#include &lt;stdio.h&gt;int main()&#123; int a,b,c,d; a=10; b=a++; c=++a; d=10*a++; printf(&quot;b，c，d：%d，%d，%d&quot;，b，c，d）; return 0;&#125;【标准答案】10，12，120 unsigned char *p1; unsigned long *p2;p1=(unsigned char *)0x801000; p2=(unsigned long *)0x810000; // 2. 请问p1+5= ; p2+5= ;【标准答案】0x801005、0x810020 void main()&#123; int a[5]=&#123;1,2,3,4,5&#125;; int *ptr=(int *)(&amp;a+1); printf(“%d，%d”,*(a+1),*(ptr-1));&#125;// 3. 请问输出：【标准答案】2,5 // 4. 以下是求一个数的平方的程序,请找出错误: #define SQUARE(a)((a)*(a))int a=5; int b;b=SQUARE(a++);【标准答案】宏在预编译时会以替换的形式展开，仅仅会替换。涉及到宏的地方，不要用++ --，标准中对此没有规定，因此最终结果将会依赖于不同的编译器。执行程序的答案可能是25、也有可能是36。 #define Max_CB 500void LmiQueryCSmd(Struct MSgCB * pmsg)&#123; unsigned char ucCmdNum; ...... for(ucCmdNum=0;ucCmdNum&lt;Max_CB;ucCmdN um++) &#123; ......; &#125;&#125;// 5. 这段代码执行有什么问题？【标准答案】死循环unsigned char //无符号字符型 表示范围0~255 char //有符号字符型 表示范围-128~127int modifyvalue()&#123; return(x+=10);&#125;int changevalue(int x)&#123; return(x+=1);&#125;void main()&#123; int x=10; x++; changevalue(x); x++; modifyvalue(); printf(&quot;First output:%dn&quot;,x); x++; changevalue(x); printf(&quot;Second output:%dn&quot;,x); modifyvalue(); printf(&quot;Third output:%dn&quot;,x);&#125;// 6. 输出?【 标准答案】12、13、13// 7. 请写出下列代码的输出内容＃include&lt;stdio.h&gt; main()&#123; int a,b,c,d; a=10; b=a++; c=++a; d=10*a++; printf(&quot;b，c，d：%d，%d，%d&quot;，b，c，d）; return 0;&#125;【标准答案】10，12，120 找出程序的错误 123456789// 9. 下面的代码输出是什么，为什么？ void foo(void)&#123; unsigned int a = 6; int b = -20; (a+b &gt; 6)? puts(&quot;&gt; 6&quot;) : puts(&quot;&lt;= 6&quot;);&#125;【参考答案】这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“&gt;6”。原因是当表达式中存在有符号类型和无符号类型时所有的数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。 other12345678910111213141516171819// 1. 一语句实现x是否为2的若干次幂的判断。void main()&#123; int a; scanf(“%d”,&amp;a); printf(“%c”,(a)&amp;(a-1)?’n’:’y’); // 若是打印y，否则n&#125;// 2. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字interrupt。下面的代码就使用了 interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。interrupt double compute_area (double radius)&#123;double area = PI * radius * radius; printf(&quot; Area = %f&quot;, area);return area;&#125;【参考答案】这个函数有太多的错误了，以至让人不知从何说起了：1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了 代码编写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 1. 编写 strcpy 函数, 已知 strcpy 函数的原型是 char *strcpy(char *strDest, const char *strSrc);其中 strDest 是目的字符串， strSrc 是源字符串。（1） 不调用 C++/C 的字符串库函数，请编写函数strcpy 。（2） strcpy 能把 strSrc 的内容复制到 strDest，为什么还要 char * 类型的返回值？// 2. 请编写一个 C 函数，该函数给出一个字节中被置 1 的位的个数。unsigned int TestAsOne0(char log)&#123; int i; unsigned int num=0, val; for(i=0; i&lt;8; i++) &#123; val = log &gt;&gt; i; //移位val &amp;= 0x01; //与1相与if(val) num++; &#125; return num;&#125;// 3. 实现strcmp函数// 4. 华为面试题：怎么判断链表中是否有环？【参考答案】答：用两个指针来遍历这个单向链表，第一个指针p1，每次走一步；第二个指针p2，每次走两步； 当p2 指针追上 p1的时候，就表明链表当中有环路了。int testLinkRing(Link *head)&#123; Link *t1=head,*t2=head; while( t1-&gt;next &amp;&amp; t2-&gt;next) &#123; t1 = t1-&gt;next; if (NULL == (t2 = t2-&gt;next-&gt;next)) return 0; //无环 if (t1 == t2) return 1; &#125; return 0;&#125;// 5. 实现双向链表删除一个节点P，在节点P后插入一个节点，写出这两个函数。// 6. 把一个链表反向 。【参考答案】从第一个元素开始，ps指向他，将他（ps）指向头节点(ps-&gt;next= head)，将ps设为头节点（head = ps;）操作下一个元素（ps = pe-&gt;next;）等于是依次将每个元素翻到原头节点前面。// 7. 取一个整数a从右端开始的4～7位。void main()&#123; unsigned a,b,c,d; scanf(&quot;%o&quot;,&amp;a); b=a&gt;&gt;4; c=~(~0&lt;&lt;4); d=b&amp;c; printf(&quot;%o\\n%o\\n&quot;,a,d);&#125;","categories":[{"name":"嵌软笔试面试","slug":"嵌软笔试面试","permalink":"http://1nameccc.github.io/categories/%E5%B5%8C%E8%BD%AF%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"嵌软笔试面试","slug":"嵌软笔试面试","permalink":"http://1nameccc.github.io/tags/%E5%B5%8C%E8%BD%AF%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"}],"author":"coucou"},{"title":"C语言——内存篇","slug":"1-1-C语言-内存/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:46:00.684Z","comments":true,"path":"2023/08/01/1-1-C语言-内存/index/","permalink":"http://1nameccc.github.io/2023/08/01/1-1-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98/index/","excerpt":"C语言——内存","text":"C语言——内存 内存分配方式 栈内存分配（Stack Allocation）： 栈内存是一种自动分配和释放的内存，用于存储局部变量和函数调用的上下文信息。 变量在函数内部声明时，存储在栈内存中。栈的特性是后进先出（LIFO），所以最后进入栈的变量会最先被释放。 1234void someFunction() &#123; int x; // 在栈上分配内存 // 函数执行完毕后，x 的内存会被自动释放&#125; 堆内存分配（Heap Allocation）： 堆内存是一种动态分配和释放的内存，用于存储程序运行时需要动态分配的数据。 使用malloc()、calloc()、realloc() 等函数在堆上分配内存，并使用 free() 函数释放堆内存。 123int *ptr = (int *)malloc(sizeof(int)); // 在堆上分配内存// 使用完毕后，需要手动释放内存free(ptr); 全局变量和静态变量分配（Static and Global Variables）： 全局变量和静态变量存储在静态存储区，它们在程序的整个生命周期内存在。 全局变量在所有函数之外声明，而静态变量在函数内部使用 static 关键字声明。 1234int globalVar; // 全局变量，在静态存储区分配内存void someFunction() &#123; static int staticVar; // 静态变量，在静态存储区分配内存&#125; 堆和栈的区别 生存周期: 栈：栈上的变量的生命周期通常局限于函数的执行期间。当函数返回时，栈上的局部变量会被销毁，内存被释放。 堆：堆上分配的内存的生命周期可以长于任何特定函数调用，通常由程序员来管理。内存只有在显式释放时才会被回收。 大小限制: 栈：栈的大小通常受限于编译器或操作系统的设置，较小。因此，栈适合存储相对较小的数据结构。 堆：堆的大小通常受系统内存的限制，可以分配较大的内存块，适合存储大型数据结构。 访问速度: 栈：栈上的内存访问速度较快，因为它是线性分配，且栈上的数据通常存储紧凑。 堆：堆上的内存访问速度较慢，因为它是动态分配的，数据可能分散存储在内存中。 分配方式: 栈：栈上的内存分配和释放是自动的，不需要程序员干预。 堆：堆上的内存需要程序员手动分配和释放，使用 malloc()、free() 等函数。 栈在c语言中的作用 用来保存临时变量，临时变量包括函数参数，函数内部定义的临时变量 多线程编程的基础就是栈，每个线程多最少有自己的专属的栈，用来保存本线程运行时各个函数的临时变量 c++的内存管理 在c++中虚拟内存分为代码段、数据段、bss段、堆、共享区、栈 代码段:包括只读存储去和文本区，其中只读存储区字符串常量，文本区存储程序的机械代码 数据段：全局变量、静态变量（全局、局部） BSS段：未初始化的全局变量和静态变量（全局、局部），以及所有被初始化为0的全局变量和静态变量 堆:调用new&#x2F;malloc申请的内存空间，地址由低地址向高地址扩张 栈：局部变量、函数的返回值，函数的参数，地址由高地址向低地址扩张 内存泄漏 简单来说就是申请了内存，不使用之后并没有释放内存，或者说，指向申请的内存的指针突然又去指向别的地方，导致找不到申请的内存， 影响 随着程序运行时间越长，占用内存越多，最终用完内存，导致系统崩溃 减少内存泄漏 良好的编码习惯，使用内存分配的函数，一但使用完毕之后就要记得使用对应的函数是否掉 将分配的内存的指针以链表的形式自行管理，使用之后从链表中删除，程序结束时可以检查改链表 使用智能指针 字节对齐问题 对齐要求：计算机体系结构规定了数据类型的对齐要求，通常以字节为单位。例如，一个32位体系结构可能需要数据类型的存储地址是其大小的整数倍，比如4字节对齐或8字节对齐。 未对齐访问：如果数据没有按照对齐要求存储在内存中，访问该数据可能会导致性能损失或硬件要求，并可能导致错误。在这种情况下，需要将数据移动到字节对齐的地址进行访问。 常见就是求复合类型大小，比如结构体、联合体 C语言函数参数压栈顺序 C语言中，函数参数的压栈顺序通常是从右到左，也就是从最后一个参数开始压栈，依次向前。这是因为C语言的调用约定是”cdecl”（C Declaration），按照这个约定，函数的调用者（调用函数的地方）会将参数从右到左依次推入栈中，然后调用函数。 举个例子，假设有一个如下所示的函数： 123&gt;int addNumbers(int a, int b, int c) &#123; return a + b + c;&gt;&#125; 如果在另一个函数中调用addNumbers函数，假设要计算addNumbers(1, 2, 3)，参数的压栈顺序是这样的： 首先，数字3（参数c）被推入栈中。 然后，数字2（参数b）被推入栈中。 最后，数字1（参数a）被推入栈中。 可能内存溢出的函数 strcat: strcat 用于将一个字符串附加到另一个字符串的末尾。 可能导致内存溢出，因为它不会检查目标字符串的容量，如果目标字符串不足以容纳被附加的内容，就会溢出。 改进方法：使用 strncat 函数，该函数接受一个额外参数，指定要附加的最大字符数，从而避免溢出。 strncat: strncat 具有改进版的 strcat，可以控制附加的字符数。 仍然需要小心，确保指定的字符数不会超过目标字符串的容量。 strcmp: strcmp 用于比较两个字符串是否相等。 不会导致内存溢出，但可能导致无限循环或错误，如果比较的字符串没有正确的终止符。 改进方法：使用 strncmp 函数，并始终确保比较的字符串以 null 结尾。 strcpy: strcpy 用于将一个字符串复制到另一个字符串。 可能导致内存溢出，因为它不会检查目标字符串的容量，如果目标字符串不足以容纳被复制的内容，就会溢出。 改进方法：使用 strncpy 函数，该函数接受一个额外参数，指定要复制的最大字符数，从而避免溢出。 内存申请函数 123456&gt;// 申请堆内存&gt;void *malloc(size_t size); //申请size_t个字节内存&gt;void free(void *ptr); //释放内存，但是指针还是可以用&gt;void *calloc(size_t nmemb, size_t size); //申请nmemb快内存，每块size_t个字节&gt;void *realloc(void *ptr, size_t size);//申请内存，重新申请size_t字节内存，&gt;void *reallocarray(void *ptr, size_t nmemb, size_t size);","categories":[{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"内存篇","slug":"内存篇","permalink":"http://1nameccc.github.io/tags/%E5%86%85%E5%AD%98%E7%AF%87/"}],"author":"coucou"},{"title":"C语言——预处理","slug":"1-3-C语言-预处理/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:55:59.936Z","comments":true,"path":"2023/08/01/1-3-C语言-预处理/index/","permalink":"http://1nameccc.github.io/2023/08/01/1-3-C%E8%AF%AD%E8%A8%80-%E9%A2%84%E5%A4%84%E7%90%86/index/","excerpt":"C语言——预处理","text":"C语言——预处理 #error 12345678&gt;// 编译程序时，只要遇到#error就会生成一个编译错误提醒，并且停止编译，&gt;语法格式:&gt;#error error-message&gt;实例:&gt;#ifdef xxx&gt;#error “xxx has been defined”&gt;#else&gt;#endif #ifndef #define #endif 12345&gt;// 当项目中有多个c文件使用到同一个头文件是，在编译的时候会出现大量的变量，函数声明冲突，解决就是使用&gt;#ifndef _HEAR_H_&gt;#define _HEAR_H_&gt;#endif #define和const Define和const 都可以用于定义常量但以下区别(生效时间，内存占用情况，类型检查)： define只是单纯的文本替换，define常量的生命生命周期止于编译器，不存在分配内存，存在与程序的代码段 const生效于编译的阶段；define生效于预处理阶段 Const修饰的常量处于程序的数据段，在堆栈中分配空间 Const有数据类型检查，define没有 #define不可调试，const能调试 const定义的变量在C中不是真正的常量 Const 定义的常量不能作为数组的大小 typedef和#define 原理不同： 首先#define是预处理命令，在预处理阶段只是机械的替换带入字符串，并不会左类型检查， typedef是关键字，作用是给自己的作用域内给一个已经存在的类型起个别名 #define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域 对指针的操作不同 #define 表明一年 1#define YEAR (60 * 60 * 24 * 365)ul 标准宏MIN 1#define MIN(a, b) ((a) &lt; (b) ? (a) : (b)) 缺点 无法进行类型检查 运算优先级问题 无法调试 代码膨胀 无法操作类的私有数据成员 123456789101112131415161718192021222324252627#define m(a,b) a*b// #define m(a,b) (a)*(b)//避免出问题最好加上()int main()&#123; printf(&quot;%d\\n&quot;,m(5,6)); printf(&quot;%d\\n&quot;,m(5+1,6));//实际是这样的：5+1*6 return 0;&#125;#define sqort(a) ((a)*(a))// 实例1： int a = 5;int b = sqort(a++);//( (a++) * (a++) ) 先给括号赋值 5之后a再+1=6printf(&quot;%d\\n&quot;,b);//30printf(&quot;%d\\n&quot;,a);//7// 实例2： int a = 5;int b = sqort(++a);//(（++a）* (++a)) printf(&quot;%d\\n&quot;,b);//49printf(&quot;%d\\n&quot;,a);//7这里主要是考察++a和后加加的问题// 记住一点：++a返回的a的引用，a++返回的是a加之前的数值a的引用是要等最终的那个a才能确定的 #include 对于.#include&lt;头文件&gt;，表示是系统文件，编译会先从标准库路径下搜索，编译器设置的头文件路径–&gt;系统变量 对于#include”头文件”，当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量 C代码编译过程 预处理（Preprocessing）： 预处理阶段是在实际编译之前的一个可选步骤，用于处理源代码中的预处理指令，比如 #include 和 #define。 预处理器将处理这些指令，并且可能会包含其他文件、进行宏替换等。 预处理的输出是一个经过处理的源文件，通常以.i或.ii为扩展名。 编译（Compiling）： 编译阶段将预处理后的源代码转换为汇编代码（Assembly Code）。 编译器（如GNU Compiler Collection中的gcc）将C源代码翻译成汇编语言。 输出是一个以.s为扩展名的汇编代码文件。 汇编（Assembling）： 汇编阶段将汇编代码转换为机器语言指令。 汇编器（如GNU Assembler中的as）将汇编代码翻译成机器码。 输出是一个以.o或.obj为扩展名的目标文件，包含了二进制指令。 链接（Linking）： 链接阶段将多个目标文件（例如，多个C文件分别编译得到的目标文件）合并为一个可执行文件。 链接器（如GNU的ld或gcc中的链接器部分）将各个目标文件中的函数和变量引用解析，并创建一个可执行文件。 链接的输出是一个可执行的二进制文件，可以在操作系统上运行。 在头文件中是否可以定义静态变量 不可以，因为静态变量是有记忆的，不会随函数结束而结束，所以，如果定义在头文件中，那么就会被多个文件开辟空间，浪费资源或者重新出错 #和##的作用 12345678910111213141516&gt;// #利用宏参数字符串化&gt;#define ARGV(x) printf(&quot;&quot;#x&quot; is %s\\n&quot;,#x) //表示把参数x解释为字符串&gt;int a = 5;&gt;ARGV(a); //a is a&gt;// ##运算符粘合剂 组合成一个变量，强制分隔&gt;#define targ( n ) X##n //表示X1......或Xn&gt;int main()&gt;&#123; int a = 5; // ARGV(a); int targ(1) = 10;//表示 X1 =10 printf(&quot;%d\\&quot;,X1);//10 return 0&gt;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"预处理篇","slug":"预处理篇","permalink":"http://1nameccc.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86%E7%AF%87/"}],"author":"coucou"},{"title":"C语言——关键字","slug":"1-4-C语言-关键字/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:56:18.502Z","comments":true,"path":"2023/08/01/1-4-C语言-关键字/index/","permalink":"http://1nameccc.github.io/2023/08/01/1-4-C%E8%AF%AD%E8%A8%80-%E5%85%B3%E9%94%AE%E5%AD%97/index/","excerpt":"C语言——关键字","text":"C语言——关键字 goto 无条件跳转 volatile 禁止编译器优化：编译器在编译过程中会对变量进行各种优化，包括缓存寄存器中的变量值，以提高程序执行速度。但是，在某些情况下，这种优化可能导致问题，特别是当变量的值由外部因素（例如硬件或其他线程）更改时。使用volatile 关键字可以告诉编译器不要进行这些优化，以确保变量的值在任何时刻都是最新的。 适用于多线程编程：在多线程环境中，多个线程可能同时访问和修改同一个变量。在这种情况下，使用volatile 可以确保线程在读取和写入volatile 变量时不会进行缓存，从而避免数据不一致的问题。 适用于嵌入式系统和硬件寄存器：在嵌入式系统编程中，经常需要访问硬件寄存器，这些寄存器的值可能会在任何时刻由硬件更改。使用volatile 可以确保编译器不会对这些寄存器的访问进行优化。 防止编译器删除无用的代码：在某些情况下，变量的值可能不会被用于计算结果，但它们的值仍然对程序的行为产生影响。使用volatile 可以防止编译器删除这些看似无用的代码。 union 对于联合体所有的成员都共享一块内存，而结构体是所有变量内存的叠加，需要考虑字节对齐问题，对于联合体来说，只要你修改里面的成员的数据就会修改其他成员的数据，而结构体的成员数据是不影响的 判断大小端问题 大端字节序：高字节存放在低位地址，低字节存放在高地址 小端字节序：低字节存放在低位，高字节存放在高位 计算占用空间大小问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&gt;对于不同位的操作系统，个别数据类型数据大小不一样，&gt;Long 和unsigned long在32位中是4个字节&gt;在64位中是8个字节计算的时候需要考虑字节对齐问题：&gt;1. 所占空间必须是成员变量中字节最大的整数倍&gt;2. 每个变量类型的偏移量必须是该变量类型的整数倍&gt;3. 对于联合体，由于所有变量都是共用一块内存，还需注意数组占用最大内存&gt;例如：&gt;Typedef union &#123;double I;int k[5];char c;&#125; DATE;&gt;在联合体中成员变量最大为double为8个字节，所以最终大小必须是8的整数倍；又因为联合体是共占内存空间，即int*5=20字节，所以最终为24个字节&gt;Typedef struct data &#123;int cat;DATE cow; double dog;&#125;too;&gt;求sizeof(too);&gt;解：在结构体里面联合体为24，联合体的最大类型为8字节，所以联合体的起始位置必须满足偏移量为8的倍数，计算如下：&gt;Cat：1-4,&gt;DATE cow 8+24&gt;Double dog 32+8=40&gt;//联合体的计算公式：&gt;//最终的大小得是结构体中的类型的最大长度的整数倍，并且能容下所有类型&gt;union date&gt;&#123; char a; double b[3]; char c;&gt;&#125;;&gt;typedef union date DATE;&gt;/*&gt;结构体的计算：&gt;1.最终的大小得是结构体中的类型的最大长度的整数倍&gt;2.除了结构体中的联合体外，其他类型的偏移量必须是该类型的整数倍&gt;3.如果里面有联合体，该联合体的起始位置要满足该联合体的里面的最大长度类型的偏移量&gt;*/&gt;struct test&gt;&#123; char a;//1 DATE d;//8+24 char b;//33 char c; //34&gt;&#125;;//最终40&gt;typedef struct test TEST;&gt;int main()&gt;&#123; printf(&quot;%ld\\n&quot;,sizeof(DATE));//24 printf(&quot;%ld\\n&quot;,sizeof(TEST));//40 return 0;&gt;&#125; define &amp; typedef #define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。 typedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。 extern 变量声明：通过使用 extern，你可以在一个源文件中声明一个在另一个源文件中定义的全局变量，以便在当前源文件中使用它，而不需要重新定义。这对于在多个文件中共享全局变量非常有用。 1234// File1.cint globalVar; // 定义全局变量// File2.cextern int globalVar; // 声明在其他文件中定义的全局变量 函数声明：类似于变量，你也可以使用 extern 来声明在其他源文件中定义的函数。这允许你在当前文件中使用这些函数而无需重新定义它们。 1234// File1.cvoid someFunction(); // 定义函数// File2.cextern void someFunction(); // 声明在其他文件中定义的函数 解决多文件编程：extern 用于多文件编程中，特别是当你将程序拆分成多个源文件时，有助于确保这些文件之间的全局变量和函数能够正确共享。它允许你在一个文件中定义，而在其他文件中声明和使用这些全局实体。 避免重复定义：extern 声明允许你在一个文件中定义全局变量或函数，而在其他文件中声明，从而避免多次定义相同的变量或函数，这将导致链接错误。 register 建议寄存器存储：通过使用 register 关键字，程序员可以向编译器建议将某个变量存储在寄存器中。寄存器是位于中央处理单元（CPU）内部的存储区域，它的访问速度比内存要快得多。因此，将变量存储在寄存器中可以提高程序的执行速度。 1register int counter; // 建议编译器将 counter 存储在寄存器中 编译器决定：需要强调的是，register 只是一个建议，而非强制要求。编译器可以选择是否将变量存储在寄存器中。通常，编译器会根据代码的复杂性和寄存器的可用性来决定是否采纳这些建议。 限制使用：register 变量通常有一些限制，例如不能取地址或使用指针对其进行操作，因为寄存器变量不在内存中有地址。这也意味着 register 变量通常不能用于需要取地址的操作，如指针和数组的地址计算。 性能提升：使用 register 可以提高程序的性能，特别是在循环中对频繁访问的变量使用 register 可能会产生显著的性能提升。 const 创建常量变量：通过将 const 关键字应用于变量，你可以创建一个不可更改的常量。这意味着一旦给定值赋予这个变量，它的值将不再改变。 1const int max_value = 100; 防止无意的修改：使用 const 可以避免在代码中无意地修改常量的值。如果你尝试修改一个被声明为 const 的变量，编译器将生成错误或警告。 12const double pi = 3.14159;// 试图修改 pi 的值将导致编译错误 static 文件作用域变量：使用 static 可将全局变量的作用域限制在当前源文件中，防止其他文件访问或修改。 1static int globalVar = 5; // 限制作用域在当前文件中 静态局部变量：在函数内部使用 static 可使局部变量在函数调用之间保持其值。 1234void myFunction() &#123; static int counter = 0; // 保持在函数调用之间的值 counter++;&#125; 静态函数：使用 static 可将函数的作用域限制在当前源文件中，避免与其他文件的函数冲突。 123static void internalFunction() &#123; // 内部链接函数，只在当前文件中可见&#125; 模块局变量：通过将变量声明为 static，可以在不同的文件中创建具有持久性的变量，以避免冲突。 12345// File1.cstatic int globalVar = 42; // 只能在当前文件中访问// File2.cint anotherVar = 123; // 可以被其他文件访问的全局变量 核心 限制作用域 限制存储域 sizeof &amp; strlen() 区别 首先sizeof是关键字，strlen是函数，sizeof用来计算占用内存大小，strlen是用来计算字符串的长度，特别是对于需不需要包含\\0问题：Sizeof是需要给\\0计算空间的，strlen是不需要，sizeof是在编译的时候计算的，而strlen是在运行的时候计算 求指针大小 在32位机器下，对于sizeof(指针变量)都是4个字节，比如 Int *a; Sizeof(a); 求引用大小 Sizeof(char &amp;) &#x2F;&#x2F; 1 引用大小和数据类型有关 计算数组大小 1234567&gt;int num[5]=&#123;1,2,3,4&#125;;&gt;printf(&quot;%ld\\n&quot;,sizeof(num));//20&gt;char str[10]=&#123;&quot;hello&quot;&#125;;&gt;printf(&quot;%ld\\n&quot;,strlen(str));//5&gt;printf(&quot;%ld\\n&quot;,sizeof(str));//10 不使用sizeof求数据类型字节的大小 1#define mysieof(value) (char*)(&amp;value+1)-(char*)(&amp;value) strlen(“\\0”) &#x3D; ? sizeof(“\\0”) 12&gt;printf(&quot;%d\\n&quot;,sizeof(&quot;\\0&quot;));//2 因为这里有\\0\\0&gt;printf(&quot;%d\\n&quot;,strlen(&quot;\\0&quot;));//0 sizeof(a++) 1234&gt;int a = 2;&gt;printf(&quot;%d\\n&quot;,sizeof(a++)); //4&gt;printf(&quot;%d\\n&quot;,a); // a = 2&gt;// 注意：对于sizeof只会求所占内存大小，不会进行表达式运算 计算字符数组大小 123456&gt;char ch[] = &quot;hello&quot;;&gt;char str[10] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;&gt;printf(&quot;%d\\n&quot;,sizeof(ch));//6&gt;printf(&quot;%d\\n&quot;,strlen(ch));//5&gt;printf(&quot;%d\\n&quot;,sizeof(str));//10&gt;printf(&quot;%d\\n&quot;,strlen(str));//5 *char str1 &#x3D; “hello”和char str2[] &#x3D; “hello” 123456789&gt;char str[] = &quot;hello&quot;;&gt;char *str1 =&quot;hello&quot;;&gt;//区别一 数组名不可以自加,因为数组名是地址常量&gt;//str++;&gt;//str1++;&gt;//区别二 ,数组里面的元素可以修改，str1指向的地址的内容不可以修改 &gt;str[0] = &#x27;W&#x27;;&gt;*str1 = &#x27;w&#x27;;//段错误&gt;//总结： 数组名就相当于是指针常量，只可以修改里面的内容，不可以修改指向的地址，字符指针相当于是常量指针，不可以修改指向的地址的内容，可以修改地址","categories":[{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"关键字篇","slug":"关键字篇","permalink":"http://1nameccc.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97%E7%AF%87/"}],"author":"coucou"},{"title":"操作系统——进程&线程","slug":"2-1-操作系统-进程&线程/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:56:28.656Z","comments":true,"path":"2023/08/01/2-1-操作系统-进程&线程/index/","permalink":"http://1nameccc.github.io/2023/08/01/2-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B&%E7%BA%BF%E7%A8%8B/index/","excerpt":"操作系统——进程&amp;线程","text":"操作系统——进程&amp;线程 进程和线程的定义 进程是资源分配的基本单位，他是程序执行是的一个实例，在程序运行时创建 线程是程序执行的最小单位，是进程的一个执行流，一个进程里包含多个线程 进程和线程的区别 定义： 进程：进程是独立的执行单位，每个进程都有自己独立的内存空间和系统资源。进程之间通常是相互隔离的。 线程：线程是进程内的执行单元，多个线程可以共享同一个进程的内存空间和系统资源。 资源占用： 进程：每个进程都有独立的内存空间，因此占用较多的系统资源。 线程：线程共享同一个进程的内存空间，因此占用的系统资源较少。 通信和同步： 进程：不同进程之间的通信较复杂，需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等。进程之间的同步也需要额外的手段。 线程：线程之间可以直接共享内存，因此通信较为简单。线程之间的同步可以使用线程同步原语，如互斥锁、信号量等。 创建和销毁开销： 进程：创建和销毁进程通常需要较大的开销，包括分配和释放内存、建立和销毁进程控制块等。 线程：创建和销毁线程的开销较小，因为它们共享了大部分进程的资源。 独立性： 进程：进程是相对独立的，一个进程的崩溃通常不会影响其他进程。 线程：线程是共享同一个进程的资源，因此一个线程的错误可能会影响整个进程。 适用场景： 进程：适用于需要高度隔离和独立性的任务，如独立的应用程序。 线程：适用于需要轻量级并发、共享数据、协同工作的任务，如多线程编程和并行计算。 进程和线程的状态 创建状态（New）：当一个新的进程被创建，但操作系统尚未为其分配足够的资源或初始化必要的数据结构时，进程处于创建状态。在这个阶段，进程正在初始化，并等待操作系统分配资源。 就绪状态（Ready）：一旦进程获得了必要的资源，它进入就绪状态。在就绪状态下，进程已准备好运行，只等待CPU的分配。多个就绪状态的进程可以等待CPU时间片，等待操作系统的调度。 运行状态（Running）：进程进入运行状态时，它正在执行指令并占用CPU。在任何给定时间，只有一个进程可以处于运行状态。其他进程则处于就绪或阻塞状态。 阻塞状态（Blocked）：当进程在执行中遇到需要等待某些事件发生的情况（如等待I&#x2F;O操作完成或等待其他进程的信号）时，它会从运行状态切换到阻塞状态。在阻塞状态下，进程暂停执行，直到所需事件发生。 终止状态（Terminated）：当进程完成其任务或被操作系统终止时，它进入终止状态。在终止状态下，操作系统会回收进程的资源，包括内存空间、文件描述符等。 进程间通信方式 管道（Pipes）：管道是一种单向通信机制，通常用于父子进程之间或具有亲缘关系的进程之间。有命名管道和匿名管道两种。匿名管道在内存中创建，而命名管道则存在于文件系统中，允许无亲缘关系的进程之间通信。 消息队列（Message Queues）：消息队列是一种通过消息进行通信的IPC方式。进程可以将消息发送到队列中，而其他进程可以从队列中接收消息。这种方式适用于异步通信，不要求发送者和接收者同时在线。 共享内存（Shared Memory）：共享内存允许多个进程共享同一块内存区域，从而可以非常高效地进行数据交换。但需要额外的同步机制来避免数据竞争。 信号（Signals）：信号是一种用于通知进程发生特定事件的机制，如中断或错误。进程可以发送信号给其他进程，以请求它们采取某种动作。例如，SIGKILL信号用于终止进程。 套接字（Sockets）：套接字通常用于网络编程，但它们也可以在本地进程之间进行通信。本地套接字（Unix域套接字）可以实现进程之间的双向通信。 信号量（Semaphores）：信号量是一种用于控制并发访问共享资源的IPC方式。它们可以用于同步多个进程，以确保只有一个进程可以访问临界区。 线程间通信方式 共享内存：多个线程可以通过访问共享内存区域来进行通信。这是一种高效的通信方式，但需要额外的同步机制来避免数据竞争。 互斥锁（Mutex）：互斥锁用于保护共享资源，确保在任何时候只有一个线程可以访问它。当一个线程锁住互斥锁时，其他线程将被阻塞，直到该锁被释放。 信号量（Semaphores）：信号量是一种计数器，可以用于控制多个线程对共享资源的访问。它可以用于限制同时访问资源的线程数量。 消息队列：与进程间通信类似，线程间也可以使用消息队列进行通信。这是一种异步通信的方式。 管道：类似于进程间通信中的管道，线程间也可以使用管道进行通信。然而，它们通常用于父子线程之间或在同一进程中。 进程和线程通信区别 共享资源： 线程间通信：线程共享同一进程的内存空间，它们可以直接访问共享变量和数据结构，因此通信相对容易。但同时需要特别小心数据竞争和同步问题。 进程间通信：进程有各自独立的内存空间，彼此之间不能直接访问，因此进程间通信需要特殊的机制来交换数据，如管道、消息队列或共享内存。 资源开销： 线程间通信：由于线程共享进程的内存空间，通信的开销较小。 进程间通信：进程间通信需要操作系统提供额外的资源和机制，通常开销较大，例如在不同地址空间之间传递数据需要复制数据。 并发性： 线程间通信：由于线程共享相同的内存空间，它们可以更容易地实现并发操作，但也更容易出现竞争条件。 进程间通信：进程之间相对更独立，通信和同步需要更多的开销，但可以提供更好的隔离性和稳定性。 编程难度： 线程间通信：由于线程共享内存，开发者需要小心处理同步和竞争条件，以避免数据不一致或死锁等问题。 进程间通信：进程间通信需要使用特定的IPC机制，编写代码可能相对复杂，但它提供了更好的隔离性，降低了程序的耦合度。 安全性： 线程间通信：由于线程共享内存，必须小心处理同步，以避免数据竞争和不一致性。 进程间通信：进程间通信通常更安全，因为进程具有独立的地址空间，相互之间不会直接影响，降低了错误传播的风险。 僵尸&#x2F;孤儿&#x2F;守护进程 僵尸进程（Zombie Process）： 僵尸进程是已经完成执行的子进程，但其父进程尚未调用 wait() 或 waitpid() 系统调用来获取子进程的退出状态。 僵尸进程的进程控制块仍然存在，但它不再执行任何操作。僵尸进程占用系统资源，但不能执行任何操作。 通常，父进程会在子进程退出后获取其退出状态，以释放子进程的资源，并告诉操作系统该子进程不再需要保留。如果父进程没有处理僵尸进程，它们可能会累积并浪费系统资源。 孤儿进程（Orphan Process）： 孤儿进程是指其父进程已经终止或意外终止，但孤儿进程仍在运行。在这种情况下，孤儿进程会被操作系统的 init 进程（通常具有进程ID 1）接管。 init 进程成为孤儿进程的新父进程，负责回收孤儿进程的资源并管理它们的终止。 守护进程（Daemon Process）： 守护进程是在后台运行的系统进程，通常在系统启动时启动，以执行某种系统任务或服务，如日志记录、定时任务等。 守护进程通常以超级用户权限（root）运行，独立于用户会话，没有终端关联。 守护进程的目的是在后台执行任务，不与用户直接交互。它们通常会在系统启动时启动，并在系统关闭时停止。 内核线程和用户线程区别 特权级别： 内核线程在内核级别运行，具有更高的特权级别，可以执行特权指令和访问受限资源。 用户线程在用户级别运行，其执行受到限制，无法直接访问系统资源。 调度和管理： 内核线程由操作系统内核直接管理，包括调度、撤销等。 用户线程的创建和调度由用户级线程库完成，操作系统对其无直接感知。 开销和效率： 用户线程的切换和管理开销相对较小，因为它们不涉及内核的直接参与。 内核线程的管理开销相对较大，���它们可以更灵活地利用操作系统的各种功能。 进程调度算法即策略 先来先服务调度（First-Come, First-Served，FCFS）： 进程按照它们到达调度队列的顺序执行，先到达的进程先执行。 简单且容易实现，但可能导致”等待时间过长”（Convoy Effect）问题。 短作业优先调度（Shortest Job Next，SJN）： 选择估计执行时间最短的进程，以最小化平均等待时间。 也称为最短作业优先（Shortest Job First，SJF）。 优先级调度： 每个进程被分配一个优先级，优先级高的进程先执行。 静态优先级：由系统分配。 动态优先级：根据进程的行为和等待时间进行调整。 轮转调度（Round Robin，RR）： 每个进程在调度队列中轮流执行一个时间片，当时间片用尽时，被移到队列末尾等待。 确保每个进程都有机会执行，适用于时间共享系统。 多级反馈队列调度： 将就绪队列划分为多个队列，每个队列具有不同的优先级。 进程首先从最高优先级队列开始执行，如果时间片用尽而未完成，移至较低优先级队列。 最高响应比优先调度（Highest Response Ratio Next，HRRN）： 选择响应比最高的进程执行，响应比定义为（等待时间 + 服务时间）&#x2F; 服务时间。 优先选择等待时间较长且服务时间较短的进程。 并发和并行 并发是对于单个cpu来说，在一个是个只能一个进程运行，但是线程的切换时间则是减少到纳秒数量级，多个任务不停的来回切换; 并行是对于多个CPU来说，多个进程同时运行; 区别;并行的”同时”是同一时刻可以多个任务在运行(处于running)，并发的”同时”是经过不同线程快速切换; 死锁 死锁是指多个进程在执行过程中，因争夺资源而造成互相等待，此时系统产生了死锁; 产生条件： 互斥条件：进程对所分配的资源不允许其他进程访问，若其他进程需要访问，只能等待，知道该进程使用完毕后释放资源 请求保持条件：进程获得一定资源后，有对其他资源发出请求，但该资源被其他进程占用，此时请求阻塞，而且这个进程不会释放自己已经占有的资源 不可剥夺条件：进程获得资源，只能自己释放，不可剥夺 环路等待条件：若干进程之间形成一种头尾相接等待资源关系 解决： 资源一次性分配，从而解决请求保持的问题 可剥夺资源：当进程新的资源未得到满足时，释放已有的资源； 资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反 多线程程序考虑加锁 因为线程锁只要是用来实现线程的同步和通信，在抢占是操作系统中，通常为每个县城分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突 线程的中断切换 中断发生：与进程中断一样，硬件或软件引发中断。 内核响应：操作系统内核捕获到中断并选择相应的中断服务例程。 当前线程上下文保存：操作系统保存当前运行线程的上下文信息，如寄存器状态、程序计数器、栈指针等。 中断处理程序执行：执行与中断相关的处理程序，可能包括设备驱动程序、系统调用等。 线程调度：操作系统可能决定切换到另一个线程。这可能会涉及线程调度算法。 新线程上下文加载：如果发生线程切换，操作系统加载新线程的上下文信息。 中断处理完成：中断处理程序执行完毕，控制返回到新的或原始的线程。 多线程和单线程 多线程 vs. 单线程： 并行执行： 多线程允许多个线程同时执行，以提高系统性能，尤其在多核处理器上。 单线程一次只能执行一个任务，无法充分利用多核处理器。 资源共享： 多线程可以共享相同的内存空间，这使得线程之间的通信更容易。 单线程通常无法轻松地实现资源共享，因为它们运行在相对隔离的环境中。 复杂性： 多线程编程通常更复杂，因为需要处理竞争条件和并发问题。 单线程编程通常更简单，因为不需要担心并发。 多线程编程注意事项： 线程同步：确保多个线程之间的安全访问共享资源。使用互斥锁、信号量等机制来控制线程访问。 避免竞争条件：竞争条件会导致不可预测的结果。通过合理的同步和锁定来避免竞争条件。 线程安全数据结构：使用线程安全的数据结构，如线程安全的队列，以减少自己实现同步逻辑的复杂性。 避免死锁：死锁是多线程编程中的常见问题。确保良好的锁定管理和避免相互等待。 多线程加锁注意事项： 锁粒度：选择适当的锁粒度。锁的范围应该足够小，以减少竞争，但不应过小，以避免锁争用带来的开销。 锁顺序：在多个锁的情况下，确保按照相同的顺序获取锁，以减少死锁的风险。 锁超时：在尝试获取锁时，考虑设置锁超时机制，以避免长时间等待锁导致的性能问题。 锁性能：了解锁的性能特性，以确保不会因锁开销而降低程序性能。 避免锁滥用：不是每个代码段都需要锁，避免过度使用锁，以避免不必要的同步开销。 线程池 线程池是为了有效管理和复用线程资源而创建的一种机制。它的存在有以下主要原因和优势： 降低线程创建和销毁开销：线程的创建和销毁代价较高。线程池维护一组可重用的线程，避免频繁地创建和销毁线程，从而降低开销。 控制并发度：线程池允许您限制同时执行的线程数量，以控制系统的并发度。这有助于防止系统过载和资源饱和。 提高响应时间：线程池使任务能够迅速排队并执行，而不必等待新线程的创建。这有助于提高系统的响应时间。 资源管理：线程池可以帮助有效管理系统的资源，防止不受控制的线程数量导致资源耗尽。 线程池的设计思路通常包括以下要点： 线程池大小：决定线程池可以容纳多少线程。线程池大小的选择通常取决于系统资源、性能需求和可用硬件。如果线程池太小，可能无法满足并发需求；如果太大，可能导致资源浪费和竞争条件。 任务队列：线程池通常维护一个任务队列，其中等待执行的任务排队。新任务被提交到队列中，并由线程池中的线程异步执行。 线程复用：线程池中的线程是可重用的，它们在完成一个任务后会从队列中获取下一个任务而不被销毁。这减少了线程创建和销毁的开销。 线程调度：线程池负责调度线程以执行任务，通常使用调度算法（如先进先出、最短作业优先等）来选择下一个任务。 线程池中线程的数量由以下因素确定： 系统资源：线程池的大小应受限于可用的物理内存和处理器核心数量。不宜创建过多线程，以避免资源耗尽和上下文切换开销。 性能需求：线程池的大小应该根据应用程序的性能需求来确定。如果需要高并发性能，可以增加线程池的大小。 任务性质：不同类型的任务可能需要不同数量的线程来获得最佳性能。某些任务可能需要更多线程来并行执行。 硬件特性：线程池的大小还取决于硬件特性，如多核处理器的数量，以充分利用硬件资源。 自旋锁和信号量区别 自旋锁： 自旋锁是一种轻量级的锁，通常用于保护临界区，确保同时只有一个线程可以进入临界区执行。 当一个线程尝试获取自旋锁时，如果锁已被其他线程占用，它会不断自旋（循环检查锁状态），而不是立即被阻塞挂起。 自旋锁适用于短时间内的临界区保护，因为它减少了线程的上下文切换开销。但如果锁被占用时间较长，自旋可能会浪费CPU资源。 信号量： 信号量是一种更通用的同步机制，可以用于控制并发线程的访问或控制资源的分配。 信号量有两种类型：二进制信号量（只有0和1）和计数信号量（可以大于1）。 二进制信号量通常用于互斥，即只有一个线程可以访问临界区。计数信号量用于限制同时访问某些资源的线程数量。 区别： 等待机制： 自旋锁通过忙等待来获取锁，不会阻塞线程，不会进入睡眠 信号量使用阻塞和唤醒机制，当线程无法获得信号量时，它将被阻塞，直到信号量可用，会进入睡眠 用途： 自旋锁通常用于短时间内的临界区保护，以减少上下文切换开销。 信号量更通用，可以用于控制线程数量、资源分配和同步多个线程之间的操作。 适用性： 自旋锁适合用于低竞争和低争用的情况，例如多核CPU上的短期临界区。 信号量更适合于需要阻塞等待的场景，例如生产者-消费者问题或限制同时访问资源的情况。 线程的同步和互斥的区别 同步： 同步是一种协调多个线程之间的操作顺序或执行时机的机制，以确保它们按照一定的顺序或条件来执行。 同步通常涉及在多个线程之间建立依赖关系，以便它们协同工作或按照特定的规则执行。 同步机制可以包括等待其他线程完成、通知其他线程继续执行、等待条件变为真等。 互斥： 互斥是一种同步机制，用于确保在同一时间只有一个线程可以访问共享资源或进入临界区。 互斥锁、信号量、互斥量等是用于实现互斥的工具，它们用于防止多个线程同时访问或修改共享资源，从而避免数据竞争和不一致性。 区别： 同步是更广泛的概念，它可以包括协调线程的任何方式，而不仅限于互斥。同步可以用于等待事件、通信、任务协作等。 互斥是同步的一种特定形式，它关注的是线程在访问共享资源或执行临界区时的互斥性。 联系： 互斥通常用于同步的实现中，以确保在某个时间点只有一个线程可以执行共享资源的操作。 同步机制可以包括互斥，但也可以包括其他形式的同步，如条件变量、信号量、屏障等，用于线程之间的协调和通信。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程&线程","slug":"进程-线程","permalink":"http://1nameccc.github.io/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}],"author":"coucou"},{"title":"操作系统——杂项","slug":"2-0-操作系统-杂项/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:56:22.782Z","comments":true,"path":"2023/08/01/2-0-操作系统-杂项/index/","permalink":"http://1nameccc.github.io/2023/08/01/2-0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%82%E9%A1%B9/index/","excerpt":"操作系统——杂项MISC","text":"操作系统——杂项MISC Linux内核的组成部分 进程管理：Linux内核负责管理系统中的进程。这包括创建、调度和终止进程，以及分配和回收资源，如CPU时间、内存和文件描述符。 文件系统：文件系统部分处理文件和目录的创建、访问、修改和删除操作。它还负责维护文件的权限、属性和结构。 内存管理：内存管理组件负责分配和释放内存，以及管理虚拟内存和物理内存之间的映射。它还处理内存分页、页面置换、内存保护和地址空间分配。 设备驱动程序：Linux内核包括各种设备驱动程序，以支持硬件设备与操作系统的通信。这涵盖硬盘、网络适配器、图形卡等设备。 网络协议栈：Linux内核实现了多种网络协议，如TCP&#x2F;IP、UDP、ICMP等，以支持网络通信。它还管理套接字和网络连接。 系统调用接口：系统调用是用户空间应用程序与内核之间的接口。它们允许应用程序请求内核执行特定的操作，如文件操作、进程管理、网络通信等。 调度器：调度器负责分派CPU时间片给不同的进程。它确定哪个进程在何时运行，以实现多任务处理和时间共享。 进程间通信：Linux提供多种进程间通信（IPC）机制，如管道、消息队列、信号等，以便不同进程之间交换数据和通信。 定时器和中断处理：内核需要管理定时器以触发事件，并处理硬件中断以响应外部设备的请求。 安全和权限：Linux内核实施安全性和权限控制，确保只有授权的进程可以访问资源。这包括用户和组的权限管理。 虚拟内存管理：虚拟内存系统允许操作系统将虚拟地址映射到物理内存，并管理页面置换、内存保护和内存隔离。 电源管理：内核包括电源管理功能，用于管理系统的能源消耗和设备的节能，以实现系统的高效性。 多路IO复用 多路 I&#x2F;O 复用技术是一种用于管理多个 I&#x2F;O 通道的方法，以实现高效的 I&#x2F;O 操作。它可以同时监视和处理多个 I&#x2F;O 通道，例如套接字、文件描述符等，而不需要为每个通道创建一个单独的线程或进程。以下是几种常见的多路 I&#x2F;O 复用技术及它们之间的区别： select： select 是一种最早引入的多路 I&#x2F;O 复用技术，适用于多种操作系统。 它通过一个用于监视的位掩码和一组文件描述符集合来实现多路复用。 缺点包括低效，最大文件描述符数量受限，复杂的参数设置，以及在每次调用后需要重新初始化描述符集合。 poll： poll 是与 select 类似的多路 I&#x2F;O 复用技术，但在某些情况下更灵活。 它使用一个 pollfd 结构的数组来监视文件描述符。 缺点仍然包括效率问题，特别是在大规模的文件描述符监视时。 epoll： epoll 是 Linux 特有的多路 I&#x2F;O 复用技术，设计用于解决 select 和 poll 的性能问题。 它使用三种不同的系统调用：epoll_create、epoll_ctl 和 epoll_wait，允许有效监视大量文件描述符。 epoll 是当前在 Linux 上广泛使用的多路 I&#x2F;O 复用技术，具有高效、可扩展性和低延迟的特点。 kqueue： kqueue 是类似于 epoll 的多路 I&#x2F;O 复用技术，用于 BSD 系统（如 FreeBSD）。 它使用一个事件队列来监视文件描述符。 kqueue 提供了高性能和可扩展性，尤其在高并发应用中表现出色。 区别： 主要区别在于支持的操作系统和性能。 select 和 poll 是跨平台的，但它们在处理大量文件描述符时可能效率低下。 epoll 和 kqueue 针对特定的操作系统（Linux 和 BSD 系统）设计，具有更好的性能和可扩展性，尤其在高并发环境中表现出色。 例子： 聊天服务器 假设您正在构建一个聊天服务器，多个客户端可以通过网络连接到服务器并进行实时聊天。服务器需要同时处理来自多个客户端的消息，以确保消息能够即时传递给正确的收件人，而无需为每个客户端创建一个单独的线程。 在这种情况下，多路 I&#x2F;O 复用可以用于管理多个客户端的连接。服务器可以使用 select、epoll（对于Linux）或 kqueue（对于BSD系统）等技术来同时监视多个套接字，以检测它们是否准备好进行读取或写入操作。这允许服务器同时处理多个客户端的消息而无需为每个客户端创建一个线程。 例如，当一个客户端发送消息给服务器时，服务器可以使用多路 I&#x2F;O 复用来检测该套接字准备好接收数据。一旦套接字准备好，服务器可以读取并处理消息，然后使用同样的机制将响应消息发送回给相应的客户端。这个过程可以同时处理多个客户端，使服务器更加高效。 这个例子突显了多路 I&#x2F;O 复用的强大之处，它允许服务器同时处理多个客户端的连接和消息，而无需为每个客户端创建独立的线程或进程。这有助于提高服务器的性能和扩展性。 软链接和硬链接的区别 硬链接： 硬链接是指多个文件名指向同一个物理存储位置的文件，它们共享相同的 inode 和数据块。 删除原始文件并不影响硬链接文件的存在，只有所有链接文件都被删除后，文件的内容才会被释放。 硬链接不能跨越文件系统，即不能链接到不同分区或不同文件系统上的文件。 软链接： 软链接（符号链接）是一个特殊类型的文件，它包含指向另一个文件或目录的路径名。 软链接本身包含指向目标文件的路径名，而不是实际的数据和权限信息。 删除原始文件不会影响软链接的存在，但如果原始文件被移动或删除，则软链接将指向一个无效的位置。 区别： 文件类型：硬链接是原始文件的副本，而软链接只是一个指向目标文件的符号。 跨文件系统：硬链接不能跨越文件系统，软链接可以跨越文件系统。 受影响方式：如果原始文件被删除或移动，硬链接不受影响，但软链接会失效。 文件大小：硬链接不会增加文件系统的使用空间，而软链接会占用一定的空间。 静态库和动态库 静态库： 制作静态库： 制作静态库的过程涉及将一组源文件编译成目标文件（.o文件），然后使用工具（如ar）将这些目标文件打包成一个单独的静态库文件（通常以.a为扩展名）。 使用静态库： 开发者在编译时将静态库链接到他们的应用程序中，形成一个独立的可执行文件。 静态库的函数和数据在编译时被复制到可执行文件中，因此可执行文件独立，不需要外部的库文件。 优点： 静态库的使用非常简单，不依赖外部库文件。 保证了应用程序与特定版本的库的兼容性。 缺点： 每个应用程序都包含一份库的副本，可能导致可执行文件变得庞大。 需要重新编译整个应用程序，即使只有库中的一个函数发生了变化。 动态库： 制作动态库： 制作动态库的过程与制作静态库类似，但生成的文件是一个共享库文件（通常以.so或.dll为扩展名）。 使用动态库： 应用程序在运行时链接到动态库，而不是在编译时。 动态库的函数和数据被加载到内存中，并可供多个应用程序共享。 优点： 节省磁盘空间，因为共享库只需一份副本。 允许库的更新，而不需要重新编译应用程序。 减小内存占用，因为动态库只加载一次，供多个应用程序共享。 缺点： 需要确保应用程序能够找到正确版本的动态库。 可能导致一些版本兼容性问题，因为应用程序依赖于库的特定版本。 区别： 静态库在编译时与应用程序链接，而动态库在运行时加载。 静态库会使可执行文件变得庞大，而动态库可在多个应用程序之间共享。 动态库更适合更新和维护，静态库更适合独立分发的应用程序。 动态库具有更好的资源利用率，但需要额外的管理和处理。 内核态和用户态 用户态： 用户态是指在这种模式下运行的用户应用程序或用户进程。 用户态下的程序无法直接访问或执行内核的关键功能，如硬件控制、I&#x2F;O 操作、系统调用等。 内核态（系统态）： 内核态是操作系统内核运行的特权模式，用于执行操作系统内核代码和处理系统级任务。 内核态具有更高的权限和访问权，可以执行特权指令，访问硬件设备和执行敏感操作，如内核数据结构的访问。 何时会进入系统态： 进入系统态通常是通过系统调用、中断或异常来触发的。以下是一些触发进入系统态的情况： 系统调用：当用户应用程序需要执行需要内核权限的操作时，例如文件读写、网络通信、进程管理等，它会通过系统调用请求内核执行这些操作。内核会在执行系统调用时从用户态切换到内核态，完成请求后再切换回用户态。 中断：硬件设备（如定时器、键盘、磁盘等）生成中断信号，通知内核需要处理。内核会在收到中断信号时从用户态切换到内核态，执行中断处理程序，然后返回用户态。 异常：异常是不寻常的事件，如除零、访问无效内存等。内核会处理这些异常，通常导致进程终止或操作系统崩溃。 虚拟内存 虚拟地址空间：每个进程都有自己的虚拟地址空间，通常是从零开始的连续地址范围。这使得每个进程感觉自己独占整个内存，而不需要关心其他进程的内存使用情况。 物理内存和磁盘空间结合：只有一小部分虚拟地址空间是映射到实际的物理内存。其余部分可能存储在磁盘上的交换文件中。当一个进程访问虚拟内存的某个部分时，如果该部分不在物理内存中，操作系统会将相应的数据页面从磁盘加载到物理内存中。 分页机制：虚拟内存通常通过分页机制来实现。内存被划分为固定大小的页面，同样大小的页面也被用来划分虚拟地址空间。页面是内存和磁盘之间数据传输的基本单位。 页面置换：当物理内存不足以容纳所有活跃的进程时，操作系统会使用页面置换算法，将一些不常用的页面从物理内存移到磁盘上，为更需要的页面腾出空间。 内存保护：虚拟内存系统通过硬件和操作系统的协同工作，提供了对内存的保护机制。每个页面都有相应的权限位，用于限制对页面的访问，防止非法访问。 进程间隔离：每个进程都有自己的虚拟地址空间，使得不同进程的内存空间相互隔离，不会相互干扰。 页表 页表是操作系统中用于虚拟内存管理的重要数据结构。它用于将虚拟内存地址映射到物理内存地址，以实现虚拟内存的抽象和隔离。页表的主要目的是提供内存保护、内存共享和虚拟内存的功能。 虚拟内存：虚拟内存是一种计算机内存管理技术，它允许程序访问比物理内存更大的地址空间。每个进程都有自己的虚拟地址空间，这使得每个进程感觉自己在拥有整个计算机内存。虚拟内存使得多个进程能够并行运行，而不会相互干扰。 内存隔离：虚拟内存通过将虚拟地址映射到物理内存，从而使每个进程都在自己的隔离地址空间中运行，互相不干扰。这可以提高系统的稳定性，因为一个进程的错误不会破坏其他进程。 内存保护：页表允许操作系统实施内存保护机制，防止一个进程访问其他进程的内存空间，以及防止进程访问操作系统内核空间。如果一个程序试图访问未经授权的内存，会触发异常，从而保护了系统的安全性。 内存共享：虚拟内存也使内存共享变得更容易。多个进程可以共享相同的物理内存页面，这在共享库、进程间通信和内存映射文件等方面非常有用。 实现页面置换：如果物理内存不足以容纳所有进程的数据，操作系统可以使用页面置换策略将不常用的页面交换到磁盘上，从而实现虚拟内存。页表记录了页面的位置，使操作系统能够追踪和管理这些页面。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"杂项","slug":"杂项","permalink":"http://1nameccc.github.io/tags/%E6%9D%82%E9%A1%B9/"}],"author":"coucou"},{"title":"操作系统——Linux","slug":"2-4-操作系统-Linux/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T01:01:36.698Z","comments":true,"path":"2023/08/01/2-4-操作系统-Linux/index/","permalink":"http://1nameccc.github.io/2023/08/01/2-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux/index/","excerpt":"Linux操作系统","text":"Linux操作系统 Linux 简介 UNIX 是一个交互式系统，用于同时处理多进程和多用户同时在线。为什么要说 UNIX，那是因为 Linux 是由 UNIX 发展而来的，UNIX 是由程序员设计，它的主要服务对象也是程序员。Linux 继承了 UNIX 的设计目标。从智能手机到汽车，超级计算机和家用电器，从家用台式机到企业服务器，Linux 操作系统无处不在。 Linux 接口Linux 系统是一种金字塔模型的系统，如下所示 应用程序发起系统调用把参数放在寄存器中(有时候放在栈中)，并发出 trap 系统陷入指令切换用户态至内核态。因为不能直接在 C 中编写 trap 指令，因此 C 提供了一个库，库中的函数对应着系统调用。有些函数是使用汇编编写的，但是能够从 C 中调用。每个函数首先把参数放在合适的位置然后执行系统调用指令。因此如果你想要执行 read 系统调用的话，C 程序会调用 read 函数库来执行。这里顺便提一下，是由 POSIX 指定的库接口而不是系统调用接口。也就是说，POSIX 会告诉一个标准系统应该提供哪些库过程，它们的参数是什么，它们必须做什么以及它们必须返回什么结果。 除了操作系统和系统调用库外，Linux 操作系统还要提供一些标准程序，比如文本编辑器、编译器、文件操作工具等。直接和用户打交道的是上面这些应用程序。因此我们可以说 Linux 具有三种不同的接口：系统调用接口、库函数接口和应用程序接口 Linux 组成部分 引导程序(Bootloader)：引导程序是管理计算机启动过程的软件，对于大多数用户而言，只是弹出一个屏幕，但其实内部操作系统做了很多事情 内核(Kernel)：内核是操作系统的核心，负责管理 CPU、内存和外围设备等。 初始化系统(Init System)：这是一个引导用户空间并负责控制守护程序的子系统。一旦从引导加载程序移交了初始引导，它就是用于管理引导过程的初始化系统。 后台进程(Daemon)：后台进程顾名思义就是在后台运行的程序，比如打印、声音、调度等，它们可以在引导过程中启动，也可以在登录桌面后启动 图形服务器(Graphical server)：这是在监视器上显示图形的子系统。通常将其称为 X 服务器或 X。 桌面环境(Desktop environment)：这是用户与之实际交互的部分，有很多桌面环境可供选择，每个桌面环境都包含内置应用程序，比如文件管理器、Web 浏览器、游戏等 应用程序(Applications)：桌面环境不提供完整的应用程序，就像 Windows 和 macOS 一样，Linux 提供了成千上万个可以轻松找到并安装的高质量软件。 Shell Linux 内核结构在上面我们看到了 Linux 的整体结构，下面我们从整体的角度来看一下 Linux 的内核结构 内核直接坐落在硬件上，内核的主要作用就是 I&#x2F;O 交互、内存管理和控制 CPU 访问。上图中还包括了 中断 和 调度器，中断是与设备交互的主要方式。中断出现时调度器就会发挥作用。这里的低级代码停止正在运行的进程，将其状态保存在内核进程结构中，并启动驱动程序。进程调度也会发生在内核完成一些操作并且启动用户进程的时候。 I&#x2F;O 部分负责与设备进行交互以及执行网络和存储 I&#x2F;O 操作的所有内核部分。从图中可以看出 I&#x2F;O 层次的关系，最高层是一个虚拟文件系统(VFS)，也就是说不管文件是来自内存还是磁盘中，都是经过虚拟文件系统中的。从底层看，所有的驱动都是字符驱动或者块设备驱动。二者的主要区别就是是否允许随机访问。网络驱动设备并不是一种独立的驱动设备，它实际上是一种字符设备，不过网络设备的处理方式和字符设备不同。 网络软件通常是模块化的，由不同的设备和协议来支持。大多数 Linux 系统在内核中包含一个完整的硬件路由器的功能，但是这个不能和外部路由器相比，路由器上面是协议栈，包括 TCP&#x2F;IP 协议，协议栈上面是 socket 接口，socket 负责与外部进行通信，充当了门的作用。 磁盘驱动上面是 I&#x2F;O 调度器，它负责排序和分配磁盘读写操作，以尽可能减少磁头的无用移动。 I&#x2F;O 右边的是内存部件，程序被装载进内存，由 CPU 执行，这里会涉及到虚拟内存的部件，页面的换入和换出是如何进行的，坏页面的替换和经常使用的页面会进行缓存。 进程模块负责进程的创建和终止、进程的调度、Linux 把进程和线程看作是可运行的实体，并使用统一的调度策略来进行调度。 在内核最顶层的是系统调用接口，所有的系统调用都是经过这里，系统调用会触发一个 trap，将系统从用户态转换为内核态，然后将控制权移交给上面的内核部件。 Linux 进程和线程基本概念每个进程都会运行一段独立的程序，并且在初始化的时候拥有一个独立的控制线程。换句话说，每个进程都会有一个自己的程序计数器，这个程序计数器用来记录下一个需要被执行的指令。Linux 允许进程在运行时创建额外的线程。 Linux 是一个多道程序设计系统，因此系统中存在彼此相互独立的进程同时运行。此外，每个用户都会同时有几个活动的进程。因为如果是一个大型系统，可能有数百上千的进程在同时运行。 在某些用户空间中，即使用户退出登录，仍然会有一些后台进程在运行，这些进程被称为 守护进程(daemon)。 Linux 中有一种特殊的守护进程被称为 计划守护进程(Cron daemon) ，计划守护进程可以每分钟醒来一次检查是否有工作要做，做完会继续回到睡眠状态等待下一次唤醒。 Cron 是一个守护程序，可以做任何你想做的事情，比如说你可以定期进行系统维护、定期进行系统备份等。 Linux 进程创建 fork 后，父进程和子进程相互独立。 虽然父进程和子进程保持相互独立，但是它们却能够共享相同的文件，如果在 fork 之前，父进程已经打开了某个文件，那么 fork 后，父进程和子进程仍然共享这个打开的文件。对共享文件的修改会对父进程和子进程同时可见。 那么该如何区分父进程和子进程呢？子进程只是父进程的拷贝，所以它们几乎所有的情况都一样，包括内存映像、变量、寄存器等。区分的关键在于 fork 函数调用后的返回值，如果 fork 后返回一个非零值，这个非零值即是子进程的 **进程标识符(Process Identiier, PID)**，而会给子进程返回一个零值，可以用下面代码来进行表示 12345678910pid = fork(); // 调用 fork 函数创建进程if(pid &lt; 0)&#123; error() // pid &lt; 0,创建失败&#125;else if(pid &gt; 0)&#123; parent_handle() // 父进程代码&#125;else &#123; child_handle() // 子进程代码&#125; 父进程在 fork 后会得到子进程的 PID，这个 PID 即能代表这个子进程的唯一标识符也就是 PID。如果子进程想要知道自己的 PID，可以调用 getpid 方法。当子进程结束运行时，父进程会得到子进程的 PID，因为一个进程会 fork 很多子进程，子进程也会 fork 子进程，所以 PID 是非常重要的。我们把第一次调用 fork 后的进程称为 原始进程，一个原始进程可以生成一颗继承树 Linux 进程间通信Linux 进程间的通信机制通常被称为 Internel-Process communication,IPC 下面我们来说一说 Linux 进程间通信的机制，大致来说，Linux 进程间的通信机制可以分为 6 种 信号 signal信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送异步事件信号来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。 你可以在 Linux 系统上输入 kill -l 来列出系统使用的信号，下面是我提供的一些信号 进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：SIGSTOP 和 SIGKILL 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。 管道 pipeLinux 系统中的进程可以通过建立管道 pipe 进行通信。 在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。 共享内存两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。 在使用共享内存前，需要经过一系列的调用流程，流程如下 创建共享内存段或者使用已创建的共享内存段(shmget()) 将进程附加到已经创建的内存段中(shmat()) 从已连接的共享内存段分离进程(shmdt()) 对共享内存段执行控制操作(shmctl()) 先入先出队列 FIFO先入先出队列 FIFO 通常被称为 命名管道(Named Pipes)，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为 写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。 消息队列 消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是严格模式， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 非严格模式，消息的顺序性不是非常重要。 套接字 Socket 还有一种管理两个进程间通信的是使用 socket，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如TCP（传输控制协议）或较低级别 UDP（用户数据报协议）等基础协议的支持。 套接字有以下几种分类 顺序包套接字(Sequential Packet Socket)： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。数据报套接字(Datagram Socket)：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。流式套接字(Stream Socket)：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。原始套接字(Raw Socket)： 可以使用原始套接字访问基础通信协议。 Linux 进程管理系统调用 操作系统可以分为两种模式 内核态：操作系统内核使用的模式用户态：用户应用程序所使用的模式 我们常说的 上下文切换 指的就是内核态模式和用户态模式的频繁切换。而 系统调用 指的就是引起内核态和用户态切换的一种方式，系统调用通常在后台静默运行，表示计算机程序向其操作系统内核请求服务。 fork 调用用于创建一个与父进程相同的子进程，创建完进程后的子进程拥有和父进程一样的程序计数器、相同的 CPU 寄存器、相同的打开文件。 exec 系统调用用于执行驻留在活动进程中的文件，调用 exec 后，新的可执行文件会替换先前的可执行文件并获得执行。也就是说，调用 exec 后，会将旧文件或程序替换为新文件或执行，然后执行文件或程序。新的执行程序被加载到相同的执行空间中，因此进程的 PID不会修改，因为我们没有创建新进程，只是替换旧进程。但是进程的数据、代码、堆栈都已经被修改。如果当前要被替换的进程包含多个线程，那么所有的线程将被终止，新的进程映像被加载执行。 进程映像什么是进程映像呢？进程映像是执行程序时所需要的可执行文件，通常会包括下面这些东西 代码段（codesegment&#x2F;textsegment）又称文本段，用来存放指令，运行代码的一块内存空间 数据段（datasegment）可读可写, 存储初始化的全局变量和初始化的 static 变量 bss 段（bsssegment）：可读可写, 存储未初始化的全局变量和未初始化的 static 变量, bss 段中的数据一般默认为 0 Data 段: 是可读写的，因为变量的值可以在运行时更改。此段的大小也固定。 栈（stack）：可读可写, 存储的是函数或代码中的局部变量(非 static 变量), 栈的生存期随代码块持续性，代码块运行就给你分配空间，代码块结束，就自动回收空间 堆（heap）：可读可写, 存储的是程序运行期间动态分配的 malloc&#x2F;realloc 的空间, 堆的生存期随进程持续性，从 malloc&#x2F;realloc 到 free 一直存在 Linux 进程和线程的实现Linux 进程 对于每个进程来说，在内存中都会有一个 task_struct 进程描述符与之对应。进程描述符包含了内核管理进程所有有用的信息，包括 调度参数、打开文件描述符等等。进程描述符从进程创建开始就一直存在于内核堆栈中。进程描述符是存在用户的任务结构中，当进程位于内存并开始运行时，进程描述符才会被调入内存。 Linux 和 Unix 一样，都是通过 PID 来区分不同的进程，内核会将所有进程的任务结构组成为一个双向链表。PID 能够直接被映射称为进程的任务结构所在的地址，从而不需要遍历双向链表直接访问。 进程描述符可以归为下面这几类 调度参数(scheduling parameters)：进程优先级、最近消耗 CPU 的时间、最近睡眠时间一起决定了下一个需要运行的进程 内存映像(memory image)：我们上面说到，进程映像是执行程序时所需要的可执行文件，它由数据和代码组成。 信号(signals)：显示哪些信号被捕获、哪些信号被执行 寄存器：当发生内核陷入 (trap) 时，寄存器的内容会被保存下来。 系统调用状态(system call state)：当前系统调用的信息，包括参数和结果 文件描述符表(file descriptor table)：有关文件描述符的系统被调用时，文件描述符作为索引在文件描述符表中定位相关文件的 i-node 数据结构 统计数据(accounting)：记录用户、进程占用系统 CPU 时间表的指针，一些操作系统还保存进程最多占用的 CPU 时间、进程拥有的最大堆栈空间、进程可以消耗的页面数等。 内核堆栈(kernel stack)：进程的内核部分可以使用的固定堆栈 其他： 当前进程状态、事件等待时间、距离警报的超时时间、PID、父进程的 PID 以及用户标识符等 创建新流程实际上非常简单。为子进程开辟一块新的用户空间的进程描述符，然后从父进程复制大量的内容。为这个子进程分配一个 PID，设置其内存映射，赋予它访问父进程文件的权限，注册并启动。 当执行 fork 系统调用时，调用进程会陷入内核并创建一些和任务相关的数据结构，比如内核堆栈(kernel stack) 和 thread_info 结构。 这个结构中包含进程描述符，进程描述符位于固定的位置，使得 Linux 系统只需要很小的开销就可以定位到一个运行中进程的数据结构。 进程描述符的主要内容是根据 父进程 的描述符来填充。Linux 操作系统会寻找一个可用的 PID，并且此 PID 没有被任何进程使用，更新进程标示符使其指向一个新的数据结构即可。为了减少 hash table 的碰撞，进程描述符会形成链表。它还将 task_struct 的字段设置为指向任务数组上相应的上一个&#x2F;下一个进程。 从原则上来说，为子进程开辟内存区域并为子进程分配数据段、堆栈段，并且对父进程的内容进行复制，但是实际上 fork 完成后，子进程和父进程没有共享内存，所以需要复制技术来实现同步，但是复制开销比较大，因此 Linux 操作系统使用了一种 欺骗 方式。即为子进程分配页表，然后新分配的页表指向父进程的页面，同时这些页面是只读的。当进程向这些页面进行写入的时候，会开启保护错误。内核发现写入操作后，会为进程分配一个副本，使得写入时把数据复制到这个副本上，这个副本是共享的，这种方式称为 写入时复制(copy on write)，这种方式避免了在同一块内存区域维护两个副本的必要，节省内存空间。 在子进程开始运行后，操作系统会调用 exec 系统调用，内核会进行查找验证可执行文件，把参数和环境变量复制到内核，释放旧的地址空间。 现在新的地址空间需要被创建和填充。如果系统支持映射文件，就像 Unix 系统一样，那么新的页表就会创建，表明内存中没有任何页，除非所使用的页面是堆栈页，其地址空间由磁盘上的可执行文件支持。新进程开始运行时，立刻会收到一个缺页异常(page fault)，这会使具有代码的页面加载进入内存。最后，参数和环境变量被复制到新的堆栈中，重置信号，寄存器全部清零。新的命令开始运行。 下面是一个示例，用户输出 ls，shell 会调用 fork 函数复制一个新进程，shell 进程会调用 exec 函数用可执行文件 ls 的内容覆盖它的内存。 Linux 线程 用户级线程避免使用内核，通常，每个线程会显示调用开关，发送信号或者执行某种切换操作来放弃 CPU，同样，计时器可以强制进行开关，用户线程的切换速度通常比内核线程快很多。在用户级别实现线程会有一个问题，即单个线程可能会垄断 CPU 时间片，导致其他线程无法执行从而 饿死。如果执行一个 I&#x2F;O 操作，那么 I&#x2F;O 会阻塞，其他线程也无法运行。 一种解决方案是，一些用户级的线程包解决了这个问题。可以使用时钟周期的监视器来控制第一时间时间片独占。然后，一些库通过特殊的包装来解决系统调用的 I&#x2F;O 阻塞问题，或者可以为非阻塞 I&#x2F;O 编写任务。 内核级线程通常使用几个进程表在内核中实现，每个任务都会对应一个进程表。在这种情况下，内核会在每个进程的时间片内调度每个线程。 所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。 混合实现, 结合用户空间和内核空间的优点，设计人员采用了一种 内核级线程 的方式，然后将用户级线程与某些或者全部内核线程多路复用起来 在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。 Linux 调度 Linux 系统的调度算法，首先需要认识到，Linux 系统的线程是内核线程，所以 Linux 系统是基于线程的，而不是基于进程的。为了进行调度，Linux 系统将线程分为三类 实时先入先出 实时轮询 分时 实时先入先出线程具有最高优先级，它不会被其他线程所抢占，除非那是一个刚刚准备好的，拥有更高优先级的线程进入。实时轮转线程与实时先入先出线程基本相同，只是每个实时轮转线程都有一个时间量，时间到了之后就可以被抢占。如果多个实时线程准备完毕，那么每个线程运行它时间量所规定的时间，然后插入到实时轮转线程末尾。 Linux O(1) 调度器是历史上很流行的一个调度器。这个名字的由来是因为它能够在常数时间内执行任务调度。在 O(1) 调度器里，调度队列被组织成两个数组，一个是任务正在活动的数组，一个是任务过期失效的数组。如下图所示，每个数组都包含了 140 个链表头，每个链表头具有不同的优先级。 大致流程如下： 调度器从正在活动数组中选择一个优先级最高的任务。如果这个任务的时间片过期失效了，就把它移动到过期失效数组中。如果这个任务阻塞了，比如说正在等待 I&#x2F;O 事件，那么在它的时间片过期失效之前，一旦 I&#x2F;O 操作完成，那么这个任务将会继续运行，它将被放回到之前正在活动的数组中，因为这个任务之前已经消耗一部分 CPU 时间片，所以它将运行剩下的时间片。当这个任务运行完它的时间片后，它就会被放到过期失效数组中。 一旦正在活动的任务数组中没有其他任务后，调度器将会交换指针，使得正在活动的数组变为过期失效数组，过期失效数组变为正在活动的数组。使用这种方式可以保证每个优先级的任务都能够得到执行，不会导致线程饥饿。 在这种调度方式中，不同优先级的任务所得到 CPU 分配的时间片也是不同的，高优先级进程往往能得到较长的时间片，低优先级的任务得到较少的时间片。 **公平调度器(Completely Fair Scheduler, CFS)**。 CFS 的主要思想是使用一颗红黑树作为调度队列。CFS 会根据任务在 CPU 上的运行时间长短而将其有序地排列在树中，时间精确到纳秒级。下面是 CFS 的构造模型 CFS 的调度过程如下： CFS 算法总是优先调度哪些使用 CPU 时间最少的任务。最小的任务一般都是在最左边的位置。当有一个新的任务需要运行时，CFS 会把这个任务和最左边的数值进行对比，如果此任务具有最小时间值，那么它将进行运行，否则它会进行比较，找到合适的位置进行插入。然后 CPU 运行红黑树上当前比较的最左边的任务。 在红黑树中选择一个节点来运行的时间可以是常数时间，但是插入一个任务的时间是 O(loog(N))，其中 N 是系统中的任务数。考虑到当前系统的负载水平，这是可以接受的。 调度器只需要考虑可运行的任务即可。这些任务被放在适当的调度队列中。不可运行的任务和正在等待的各种 I&#x2F;O 操作或内核事件的任务被放入一个等待队列中。等待队列头包含一个指向任务链表的指针和一个自旋锁。自旋锁对于并发处理场景下用处很大。 Linux 启动 整个系统启动过程如下 当计算机电源通电后，BIOS会进行开机自检(Power-On-Self-Test, POST)，对硬件进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 MBR(Master Boot Record) 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 boot 独立程序，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。 复制完成后，boot 程序读取启动设备的根目录。boot 程序要理解文件系统和目录格式。然后 boot 程序被调入内核，把控制权移交给内核。直到这里，boot 完成了它的工作。系统内核开始运行。 内核启动代码是使用汇编语言完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。 然后操作系统会进行自动配置，检测设备，加载配置文件，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。 配置完所有硬件后，接下来要做的就是仔细手工处理进程0，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。**创建 init 进程(进程 1 ) 和 守护进程(进程 2)**。 init 进程会检测它的标志以确定它是否为单用户还是多用户服务。在前一种情况中，它会调用 fork 函数创建一个 shell 进程，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 &#x2F;etc&#x2F;rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。 然后 &#x2F;etc&#x2F;rc 这个进程会从 &#x2F;etc&#x2F;ttys 中读取数据，&#x2F;etc&#x2F;ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 getty 的程序。 getty 程序会在终端上输入login: 等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 &#x2F;bin&#x2F;login 开始运行。login 程序需要输入密码，并与保存在 &#x2F;etc&#x2F;passwd 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。 Linux 内存管理基本概念每个 Linux 进程都会有地址空间，这些地址空间由三个段区域组成：text 段、data 段、stack 段。下面是进程地址空间的示例。 数据段(data segment) 包含了程序的变量、字符串、数组和其他数据的存储。数据段分为两部分，已经初始化的数据和尚未初始化的数据。其中 尚未初始化的数据 就是我们说的 BSS。数据段部分的初始化需要编译就期确定的常量以及程序启动就需要一个初始值的变量。所有 BSS 部分中的变量在加载后被初始化为 0 。 和 代码段(Text segment) 不一样，data segment 数据段可以改变。程序总是修改它的变量。而且，许多程序需要在执行时动态分配空间。Linux 允许数据段随着内存的分配和回收从而增大或者减小。为了分配内存，程序可以增加数据段的大小。在 C 语言中有一套标准库 malloc 经常用于分配内存。进程地址空间描述符包含动态分配的内存区域称为 堆(heap)。 第三部分段是 **栈段(stack segment)**。在大部分机器上，栈段会在虚拟内存地址顶部地址位置处，并向低位置处（向地址空间为 0 处）拓展。举个例子来说，在 32 位 x86 架构的机器上，栈开始于 0xC0000000，这是用户模式下进程允许可见的 3GB 虚拟地址限制。如果栈一直增大到超过栈段后，就会发生硬件故障并把页面下降一个页面。 当两个用户运行在相同程序中，例如编辑器(editor)，那么就会在内存中保持编辑器程序代码的两个副本，但是这种方式并不高效。Linux 系统支持共享文本段作为替代。下面图中我们会看到 A 和 B 两个进程，它们有着相同的文本区域。 数据段和栈段只有在 fork 之后才会共享，共享也是共享未修改过的页面。如果任何一个都需要变大但是没有相邻空间容纳的话，也不会有问题，因为相邻的虚拟页面不必映射到相邻的物理页面上。 除了动态分配更多的内存，Linux 中的进程可以通过 内存映射文件 来访问文件数据。这个特性可以使我们把一个文件映射到进程空间的一部分而该文件就可以像位于内存中的字节数组一样被读写。把一个文件映射进来使得随机读写比使用 read 和 write 之类的 I&#x2F;O 系统调用要容易得多。共享库的访问就是使用了这种机制。如下所示 我们可以看到两个相同文件会被映射到相同的物理地址上，但是它们属于不同的地址空间。 映射文件的优点是，两个或多个进程可以同时映射到同一文件中，任意一个进程对文件的写操作对其他文件可见。通过使用映射临时文件的方式，可以为多线程共享内存 提供高带宽，临时文件在进程退出后消失。但是实际上，并没有两个相同的地址空间，因为每个进程维护的打开文件和信号不同。 Linux 内存管理系统调用事实上，POSIX 并没有给内存管理指定任何的系统调用。然而，Linux 却有自己的内存系统调用，主要系统调用如下 123s = brk(addr) // 改变数据段大小a = mmap(addr,len,prot,flags,fd,offset) // 进行映射s = unmap(addr,len) // 取消映射 Linux 内存管理实现 虚拟内存子系统主要包括下面这些概念。 大地址空间: 操作系统使系统使用起来好像比实际的物理内存要大很多，那是因为虚拟内存要比物理内存大很多倍。 保护 : 系统中的每个进程都会有自己的虚拟地址空间。这些虚拟地址空间彼此完全分开，因此运行一个应用程序的进程不会影响另一个。并且，硬件虚拟内存机制允许内存保护关键内存区域。 内存映射: 内存映射用来向进程地址空间映射图像和数据文件。在内存映射中，文件的内容直接映射到进程的虚拟空间中。 公平的物理内存分配: 内存管理子系统允许系统中的每个正在运行的进程公平分配系统的物理内存。 共享虚拟内存: 尽管虚拟内存让进程有自己的内存空间，但是有的时候你是需要共享内存的。例如几个进程同时在 shell 中运行，这会涉及到 IPC 的进程间通信问题，这个时候你需要的是共享内存来进行信息传递而不是通过拷贝每个进程的副本独立运行。 处理器在执行指令时，会从内存中读取指令并将其 解码(decode)，在指令解码时会获取某个位置的内容并将他存到内存中。然后处理器继续执行下一条指令。这样，处理器总是在访问存储器以获取指令和存储数据。 在虚拟内存系统中，所有的地址空间都是虚拟的而不是物理的。但是实际存储和提取指令的是物理地址，所以需要让处理器根据操作系统维护的一张表将虚拟地址转换为物理地址。 为了简单的完成转换，虚拟地址和物理地址会被分为固定大小的块，称为 页(page)。这些页有相同大小，如果页面大小不一样的话，那么操作系统将很难管理。Alpha AXP系统上的 Linux 使用 8 KB 页面，而 Intel x86 系统上的 Linux 使用 4 KB 页面。每个页面都有一个唯一的编号，即页面框架号（PFN）。 上面就是 Linux 内存映射模型了，在这个页模型中，虚拟地址由两部分组成：偏移量和虚拟页框号。每次处理器遇到虚拟地址时都会提取偏移量和虚拟页框号。处理器必须将虚拟页框号转换为物理页号，然后以正确的偏移量的位置访问物理页。 上图中展示了两个进程 A 和 B 的虚拟地址空间，每个进程都有自己的页表。这些页表将进程中的虚拟页映射到内存中的物理页中。页表中每一项均包含 有效标志(valid flag)： 表明此页表条目是否有效 该条目描述的物理页框号 访问控制信息，页面使用方式，是否可写以及是否可以执行代码 要将处理器的虚拟地址映射为内存的物理地址，首先需要计算虚拟地址的页框号和偏移量。页面大小为 2 的次幂，可以通过移位完成操作。 按需分页 由于物理内存要比虚拟内存少很多，因此操作系统需要注意尽量避免直接使用低效的物理内存。节省物理内存的一种方式是仅加载执行程序当前使用的页面（这何尝不是一种懒加载的思想呢？）。例如，可以运行数据库来查询数据库，在这种情况下，不是所有的数据都装入内存，只装载需要检查的数据。这种仅仅在需要时才将虚拟页面加载进内中的技术称为按需分页。 交换 如果某个进程需要将虚拟页面传入内存，但是此时没有可用的物理页面，那么操作系统必须丢弃物理内存中的另一个页面来为该页面腾出空间。 如果页面已经修改过，那么操作系统必须保留该页面的内容，以便以后可以访问它。这种类型的页面被称为脏页，当将其从内存中移除时，它会保存在称为交换文件的特殊文件中。相对于处理器和物理内存的速度，对交换文件的访问非常慢，并且操作系统需要兼顾将页面写到磁盘的以及将它们保留在内存中以便再次使用。 Linux 使用最近最少使用(LRU)页面老化技术来公平的选择可能会从系统中删除的页面，这个方案涉及系统中的每个页面，页面的年龄随着访问次数的变化而变化，如果某个页面访问次数多，那么该页就表示越 年轻，如果某个呃页面访问次数太少，那么该页越容易被 换出。 物理和虚拟寻址模式 大多数多功能处理器都支持 物理地址模式和虚拟地址模式的概念。物理寻址模式不需要页表，并且处理器不会在此模式下尝试执行任何地址转换。 Linux 内核被链接在物理地址空间中运行。 访问控制 页面表的每一项还包含访问控制信息，访问控制信息主要检查进程是否应该访问内存。 必要时需要对内存进行访问限制。 例如包含可执行代码的内存，自然是只读内存； 操作系统不应允许进程通过其可执行代码写入数据。 相比之下，包含数据的页面可以被写入，但是尝试执行该内存的指令将失败。 大多数处理器至少具有两种执行模式：内核态和用户态。 你不希望访问用户执行内核代码或内核数据结构，除非处理器以内核模式运行。 Linux缓存 缓冲区缓存 缓冲区高速缓存包含 块设备 驱动程序使用的数据缓冲区。与字符设备相比，块设备通常需要较少的引脚。缓冲区高速缓存通过设备标识符和块编号用于快速查找数据块。 如果可以在缓冲区高速缓存中找到数据，则无需从物理块设备中读取数据，这种访问方式要快得多。 页缓存 页缓存用于加快对磁盘上图像和数据的访问, 它用于一次一页地缓存文件中的内容，并且可以通过文件和文件中的偏移量进行访问。当页面从磁盘读入内存时，它们被缓存在页面缓存中。 交换区缓存 仅仅已修改（脏页）被保存在交换文件中, 只要这些页面在写入交换文件后没有修改，则下次交换该页面时，无需将其写入交换文件，因为该页面已在交换文件中。 可以直接丢弃。 在大量交换的系统中，这节省了许多不必要的和昂贵的磁盘操作。 硬件缓存 处理器中通常使用一种硬件缓存。页表条目的缓存。在这种情况下，处理器并不总是直接读取页表，而是根据需要缓存页的翻译。 这些是转换后备缓冲区 也被称为 TLB，包含来自系统中一个或多个进程的页表项的缓存副本。 引用虚拟地址后，处理器将尝试查找匹配的 TLB 条目。 如果找到，则可以将虚拟地址直接转换为物理地址，并对数据执行正确的操作。 如果处理器找不到匹配的 TLB 条目， 它通过向操作系统发信号通知已发生 TLB 丢失获得操作系统的支持和帮助。系统特定的机制用于将该异常传递给可以修复问题的操作系统代码。 操作系统为地址映射生成一个新的 TLB 条目。 清除异常后，处理器将再次尝试转换虚拟地址。这次能够执行成功。 使用缓存也存在缺点，为了节省精力，Linux 必须使用更多的时间和空间来维护这些缓存，并且如果缓存损坏，系统将会崩溃。 Linux 页表Linux 假定页表分为三个级别。访问的每个页表都包含下一级页表 图中的 PDG 表示全局页表，当创建一个新的进程时，都要为新进程创建一个新的页面目录，即 PGD。 要将虚拟地址转换为物理地址，处理器必须获取每个级别字段的内容，将其转换为包含页表的物理页的偏移量，并读取下一级页表的页框号。这样重复三次，直到找到包含虚拟地址的物理页面的页框号为止。 页分配和取消分配对系统中物理页面有很多需求。例如，当图像加载到内存中时，操作系统需要分配页面。 系统中所有物理页面均由 mem_map 数据结构描述，这个数据结构是 mem_map_t 的列表。它包括一些重要的属性 count ：这是页面的用户数计数，当页面在多个进程之间共享时，计数大于 1 age：这是描述页面的年龄，用于确定页面是否适合丢弃或交换 map_nr ：这是此mem_map_t描述的物理页框号。 页面分配代码使用 free_area向量查找和释放页面，free_area 的每个元素都包含有关页面块的信息。 页面分配 Linux 的页面分配使用一种著名的伙伴算法来进行页面的分配和取消分配。页面以 2 的幂为单位进行块分配。这就意味着它可以分配 1页、2 页、4页等等，只要系统中有足够可用的页面来满足需求就可以。判断的标准是nr_free_pages&gt; min_free_pages，如果满足，就会在 free_area 中搜索所需大小的页面块完成分配。free_area 的每个元素都有该大小的块的已分配页面和空闲页面块的映射。 分配算法会搜索请求大小的页面块。如果没有任何请求大小的页面块可用的话，会搜寻一个是请求大小二倍的页面块，然后重复，直到一直搜寻完 free_area 找到一个页面块为止。如果找到的页面块要比请求的页面块大，就会对找到的页面块进行细分，直到找到合适的大小块为止。 因为每个块都是 2 的次幂，所以拆分过程很容易，因为你只需将块分成两半即可。空闲块在适当的队列中排队，分配的页面块返回给调用者。 如果请求一个 2 个页的块，则 4 页的第一个块（从第 4 页的框架开始）将被分成两个 2 页的块。第一个页面（从第 4 页的帧开始）将作为分配的页面返回给调用方，第二个块（从第 6 页的页面开始）将作为 2 页的空闲块排队到 free_area 数组的元素 1 上。 页面取消分配 上面的这种内存方式最造成一种后果，那就是内存的碎片化，会将较大的空闲页面分成较小的页面。页面解除分配代码会尽可能将页面重新组合成为更大的空闲块。每释放一个页面，都会检查相同大小的相邻的块，以查看是否空闲。如果是，则将其与新释放的页面块组合以形成下一个页面大小块的新的自由页面块。 每次将两个页面块重新组合为更大的空闲页面块时，页面释放代码就会尝试将该页面块重新组合为更大的空闲页面。 通过这种方式，可用页面的块将尽可能多地使用内存。 例如上图，如果要释放第 1 页的页面，则将其与已经空闲的第 0 页页面框架组合在一起，并作为大小为 2页的空闲块排队到 free_area 的元素 1 中 内存映射内核有两种类型的内存映射：**共享型（shared）和私有型(private)**。私有型是当进程为了只读文件，而不写文件时使用，这时，私有映射更加高效。 但是，任何对私有映射页的写操作都会导致内核停止映射该文件中的页。所以，写操作既不会改变磁盘上的文件，对访问该文件的其它进程也是不可见的。 按需分页一旦可执行映像被内存映射到虚拟内存后，它就可以被执行了。因为只将映像的开头部分物理的拉入到内存中，因此它将很快访问物理内存尚未存在的虚拟内存区域。当进程访问没有有效页表的虚拟地址时，操作系统会报告这项错误。 页面错误描述页面出错的虚拟地址和引起的内存访问（RAM）类型。 Linux 必须找到代表发生页面错误的内存区域的 vm_area_struct 结构。由于搜索 vm_area_struct 数据结构对于有效处理页面错误至关重要，因此它们以 AVL（Adelson-Velskii和Landis）树结构链接在一起。如果引起故障的虚拟地址没有 vm_area_struct 结构，则此进程已经访问了非法地址，Linux 会向进程发出 SIGSEGV 信号，如果进程没有用于该信号的处理程序，那么进程将会终止。 然后，Linux 会针对此虚拟内存区域所允许的访问类型，检查发生的页面错误类型。 如果该进程以非法方式访问内存，例如写入仅允许读的区域，则还会发出内存访问错误信号。 现在，Linux 已确定页面错误是合法的，因此必须对其进行处理。 文件系统Linux 文件系统基本概念Linux 中的文件是一个任意长度的字节序列，Linux 中的文件可以包含任意信息，比如 ASCII 码、二进制文件和其他类型的文件是不加区分的。 Linux 系统根目录下面的目录名 12345678910111213141516/bin， //它是重要的二进制应用程序，包含二进制文件，系统的所有用户使用的命令都在这里/boot //，启动包含引导加载程序的相关文件/dev， //包含设备文件，终端文件，USB 或者连接到系统的任何设备/etc， //配置文件，启动脚本等，包含所有程序所需要的配置文件，也包含了启动/停止单个应用程序的启动和关闭 shell 脚本/home //，本地主要路径，所有用户用 home 目录存储个人信息/lib， //系统库文件，包含支持位于 /bin 和 /sbin 下的二进制库文件/lost //+found，在根目录下提供一个遗失+查找系统，必须在 root 用户下才能查看当前目录下的内容/medi //a，挂载可移动介质/mnt， //挂载文件系统/opt， //提供一个可选的应用程序安装目录/proc //，特殊的动态目录，用于维护系统信息和状态，包括当前运行中进程信息/root //，root 用户的主要目录文件夹/sbin //，重要的二进制系统文件/tmp， // 系统和用户创建的临时文件，系统重启时，这个目录下的文件都会被删除/usr， //包含绝大多数用户都能访问的应用程序和文件/var， //经常变化的文件，诸如日志文件或数据库等 Linux 文件系统的另外一个特性是支持 **加锁(locking)**。在一些应用中会出现两个或者更多的进程同时使用同一个文件的情况，这样很可能会导致竞争条件(race condition)。一种解决方法是对其进行加不同粒度的锁，就是为了防止某一个进程只修改某一行记录从而导致整个文件都不能使用的情况。 POSIX 提供了一种灵活的、不同粒度级别的锁机制，允许一个进程使用一个不可分割的操作对一个字节或者整个文件进行加锁。加锁机制要求尝试加锁的进程指定其 要加锁的文件，开始位置以及要加锁的字节 Linux 系统提供了两种锁：共享锁和互斥锁。如果文件的一部分已经加上了共享锁，那么再加排他锁是不会成功的；如果文件系统的一部分已经被加了互斥锁，那么在互斥锁解除之前的任何加锁都不会成功。为了成功加锁、请求加锁的部分的所有字节都必须是可用的。 在加锁阶段，进程需要设计好加锁失败后的情况，也就是判断加锁失败后是否选择阻塞，如果选择阻塞式，那么当已经加锁的进程中的锁被删除时，这个进程会解除阻塞并替换锁。如果进程选择非阻塞式的，那么就不会替换这个锁，会立刻从系统调用中返回，标记状态码表示是否加锁成功，然后进程会选择下一个时间再次尝试。 加锁区域是可以重叠的。 Linux 文件系统调用 当程序要求打开一个文件时，内核会进行如下操作 授予访问权限 在全局文件表(global file table)中创建一个条目(entry) 向软件提供条目的位置 文件描述符由唯一的非负整数组成，系统上每个打开的文件至少存在一个文件描述符。文件描述符最初在 Unix 中使用，并且被包括 , 当一个进程成功访问一个打开的文件时，内核会返回一个文件描述符，这个文件描述符指向全局文件表的 entry 项。这个文件表项包含文件的 inode 信息，字节位移，访问限制等。例如下图所示 默认情况下，前三个文件描述符为 STDIN(标准输入)、STDOUT(标准输出)、STDERR(标准错误)。 在文件系统调用中，开销最大的就是 read 和 write 了。read 和 write 都有三个参数 文件描述符：告诉需要对哪一个打开文件进行读取和写入 缓冲区地址：告诉数据需要从哪里读取和写入哪里 统计：告诉需要传输多少字节 对于每个文件，Linux 都会跟踪文件模式（常规，目录，特殊文件），大小，最后修改时间以及其他信息。程序能够通过 stat 系统调用看到这些信息。第一个参数就是文件名，第二个是指向要放置请求信息结构的指针。这些结构的属性如下图所示。 存储文件的设备 存储文件的设备 i-node 编号 文件模式(包括保护位信息) 文件链接的数量 文件所有者标识 文件所属的组 文件大小(字节) 创建时间 最后一个修改&#x2F;访问时间 Linux 文件系统的实现 **虚拟文件系统(Virtual File System)**。 为了能够使应用程序能够在不同类型的本地或者远程设备上的文件系统进行交互，因为在 Linux 当中文件系统千奇百种，比较常见的有 EXT3、EXT4，还有基于内存的 ramfs、tmpfs 和基于网络的 nfs，和基于用户态的 fuse，当然 fuse 应该不能完全的文件系统，只能算是一个能把文件系统实现放到用户态的模块，满足了内核文件系统的接口，他们都是文件系统的一种实现。对于这些文件系统，Linux 做了一层抽象就是 VFS虚拟文件系统 VFS 支持的四个主要的文件系统结构 超级块 特定的文件系统, 包含了有关文件系统布局的重要信息，超级块如果遭到破坏那么就会导致整个文件系统不可读。 Dentry 目录项，路径的一个组成部分 I-node 特定的文件, i-node 索引节点，包含了每一个文件的描述符。 File 跟一个进程相关联的打开文件 四个 VFS 对象中每个对象的操作数据结构的元素都是指向基础文件系统中功能的指针 Linux Ext2 文件系统一个 ext2 Linux 磁盘分区包含了一个文件系统，这个文件系统的布局如下所示 Boot 块也就是第 0 块不是让 Linux 使用的，而是用来加载和引导计算机启动代码的。在块 0 之后，磁盘分区被分成多个组，这些组与磁盘柱面边界所处的位置无关。 第一个块是 **超级块(superblock)**。它包含有关文件系统布局的信息，包括 i-node、磁盘块数量和以及空闲磁盘块列表的开始。下一个是 组描述符(group descriptor)，其中包含有关位图的位置，组中空闲块和 i-node 的数量以及组中的目录数量的信息。图中的两个位图用来记录空闲块和空闲 i-node，这是从 MINIX 1文件系统继承的选择，大多数 UNIX 文件系统使用位图而不是空闲列表。每个位图的大小是一个块。如果一个块的大小是 1 KB，那么就限制了块组的数量是 8192 个块和 8192 个 i-node。块的大小是一个严格的限制，块组的数量不固定，在 4KB 的块中，块组的数量增大四倍。 在超级块之后分布的是 i-node 它们自己，i-node 取值范围是 1 - 某些最大值。每个 i-node 是 128 字节的 long ，这些字节恰好能够描述一个文件。i-node 包含了统计信息(包含了 stat 系统调用能获得的所有者信息，实际上 stat 就是从 i-node 中读取信息的)，以及足够的信息来查找保存文件数据的所有磁盘块。 在 i-node 之后的是 **数据块(data blocks)**。所有的文件和目录都保存在这。如果一个文件或者目录包含多个块，那么这些块在磁盘中的分布不一定是连续的，也有可能不连续。事实上，大文件块可能会被拆分成很多小块散布在整个磁盘上。 为了达到访问的目的，需要首先使用 Linux 系统调用，例如 open，这个系统调用会确定打开文件的路径。路径分为两种，相对路径 和 绝对路径。如果使用相对路径，那么就会从当前目录开始查找，否则就会从根目录进行查找。 目录文件的文件名最高不能超过 255 个字符，它的分配如下图所示每一个目录都由整数个磁盘块组成，这样目录就可以整体的写入磁盘。在一个目录中，文件和子目录的目录项都是未经排序的，并且一个挨着一个。目录项不能跨越磁盘块，所以通常在每个磁盘块的尾部会有部分未使用的字节。 上图中每个目录项都由四个固定长度的属性和一个长度可变的属性组成。第一个属性是 i-node 节点数量，文件 first 的 i-node 编号是 19 ，文件 second 的编号是 42，目录 third 的 i-node 编号是 88。紧随其后的是 rec_len 域，表明目录项大小是多少字节，名称后面会有一些扩展，当名字以未知长度填充时，这个域被用来寻找下一个目录项，直至最后的未使用。这也是图中箭头的含义。紧随其后的是 类型域：F 表示的是文件，D 表示的是目录，最后是固定长度的文件名，上面的文件名的长度依次是 5、6、5，最后以文件名结束。 rec_len 域是如何扩展的呢？如下图所示我们可以看到，中间的 second 被移除了，所以将其所在的域变为第一个目录项的填充。当然，这个填充可以作为后续的目录项。 由于目录是按照线性的顺序进行查找的，因此可能需要很长时间才能在大文件末尾找到目录项。因此，系统会为近期的访问目录维护一个缓存。这个缓存用文件名来查找，如果缓存命中，那么就会避免线程搜索这样昂贵的开销。组成路径的每个部分都在目录缓存中保存一个 dentry 对象，并且通过 i-node 找到后续的路径元素的目录项，直到找到真正的文件 i - node。 比如说要使用绝对路径来寻找一个文件，我们暂定这个路径是 &#x2F;usr&#x2F;local&#x2F;file，那么需要经过如下几个步骤： 首先，系统会确定根目录，它通常使用 2 号 i -node ，也就是索引 2 节点，因为索引节点 1 是 ext2 &#x2F;3&#x2F;4 文件系统上的坏块索引节点。系统会将一项放在 dentry 缓存中，以应对将来对根目录的查找。然后，在根目录中查找字符串 usr，得到 &#x2F;usr 目录的 i - node 节点号。&#x2F;usr 的 i - node 同样也进入 dentry 缓存。然后节点被取出，并从中解析出磁盘块，这样就可以读取 &#x2F;usr 目录并查找字符串 local 了。一旦找到这个目录项，目录 &#x2F;usr&#x2F;local 的 i - node 节点就可以从中获得。有了 &#x2F;usr&#x2F;local 的 i - node 节点号，就可以读取 i - node 并确定目录所在的磁盘块。最后，从 &#x2F;usr&#x2F;local 目录查找 file 并确定其 i - node 节点呢号。如果文件存在，那么系统会提取 i - node 节点号并把它作为索引在 i - node 节点表中定位相应的 i - node 节点并装入内存。i - node 被存放在 i - node 节点表(i-node table) 中，节点表是一个内核数据结构，它会持有当前打开文件和目录的 i - node 节点号。下面是一些 Linux 文件系统支持的 i - node 数据结构。 文件读取过程，还记得 read 函数是如何调用的吗？ n &#x3D; read(fd,buffer,nbytes); 当内核接管后，它会从这三个参数以及内部表与用户有关的信息开始。内部表的其中一项是文件描述符数组。文件描述符数组用文件描述符 作为索引并为每一个打开文件保存一个表项。 文件是和 i - node 节点号相关的。那么如何通过一个文件描述符找到文件对应的 i - node 节点呢？ 这里使用的一种设计思想是在文件描述符表和 i - node 节点表之间插入一个新的表，叫做 打开文件描述符(open-file-description table)。文件的读写位置会在打开文件描述符表中存在，如下图所示 我们使用 shell 、P1 和 P2 来描述一下父进程、子进程、子进程的关系。Shell 首先生成 P1，P1 的数据结构就是 Shell 的一个副本，因此两者都指向相同的打开文件描述符的表项。当 P1 运行完成后，Shell 的文件描述符仍会指向 P1 文件位置的打开文件描述。然后 Shell 生成了 P2，新的子进程自动继承文件的读写位置，甚至 P2 和 Shell 都不知道文件具体的读写位置。 上面描述的是父进程和子进程这两个 相关 进程，如果是一个不相关进程打开文件时，它将得到自己的打开文件描述符表项，以及自己的文件读写位置，这是我们需要的。 因此，打开文件描述符相当于是给相关进程提供同一个读写位置，而给不相关进程提供各自私有的位置。 i - node 包含三个间接块的磁盘地址，它们每个指向磁盘块的地址所能够存储的大小不一样。 Linux Ext4 文件系统 为了防止由于系统崩溃和电源故障造成的数据丢失，ext2 系统必须在每个数据块创建之后立即将其写入到磁盘上，磁盘磁头寻道操作导致的延迟是无法让人忍受的。为了增强文件系统的健壮性，Linux 依靠日志文件系统，ext3 是一个日志文件系统，它在 ext2 文件系统的基础之上做了改进，ext4 也是 ext3 的改进，ext4 也是一个日志文件系统。ext4 改变了 ext3 的块寻址方案，从而支持更大的文件和更大的文件系统大小。下面我们就来描述一下 ext4 文件系统的特性。 具有记录的文件系统最基本的功能就是记录日志，这个日志记录了按照顺序描述所有文件系统的操作。通过顺序写出文件系统数据或元数据的更改，操作不受磁盘访问期间磁盘头移动的开销。最终，这个变更会写入并提交到合适的磁盘位置上。如果这个变更在提交到磁盘前文件系统宕机了，那么在重启期间，系统会检测到文件系统未正确卸载，那么就会遍历日志并应用日志的记录来对文件系统进行更改。 日志是作为循环缓冲区管理的文件。日志可以存储在与主文件系统相同或者不同的设备上。日志记录的读写操作会由单独的 JBD(Journaling Block Device) 来扮演。 JBD 中有三个主要的数据结构，分别是 log record(日志记录)、原子操作和事务。一个日志记录描述了一个低级别的文件系统操作，这个操作通常导致块内的变化。因为像是 write 这种系统调用会包含多个地方的改动 — i - node 节点，现有的文件块，新的文件块和空闲列表等。相关的日志记录会以原子性的方式分组。ext4 会通知系统调用进程的开始和结束，以此使 JBD 能够确保原子操作的记录都能被应用，或者一个也不被应用。最后，主要从效率方面考虑，JBD 会视原子操作的集合为事务。一个事务中的日志记录是连续存储的。只有在所有的变更一起应用到磁盘后，日志记录才能够被丢弃。 由于为每个磁盘写出日志的开销会很大，所以 ext4 可以配置为保留所有磁盘更改的日志，或者仅仅保留与文件系统元数据相关的日志更改。仅仅记录元数据可以减少系统开销，提升性能，但不能保证不会损坏文件数据。其他的几个日志系统维护着一系列元数据操作的日志，例如 SGI 的 XFS。 NFS 网络文件系统NFS 架构 每一个 NFS 服务都会导出一个或者多个目录供远程客户端访问。当一个目录可用时，它的所有子目录也可用。因此，通常整个目录树都会作为一个整体导出。服务器导出的目录列表会用一个文件来维护，这个文件是 &#x2F;etc&#x2F;exports，当服务器启动后，这些目录可以自动的被导出。客户端通过挂载这些导出的目录来访问它们。当一个客户端挂载了一个远程目录，这个目录就成为客户端目录层次的一部分，如下图所示。 NFS 实现 即使客户端和服务器的代码实现是独立于 NFS 协议的，大部分的 Linux 系统会使用一个下图的三层实现，顶层是系统调用层，系统调用层能够处理 open 、 read 、 close 这类的系统调用。在解析和参数检查结束后调用第二层，虚拟文件系统 (VFS) 层。 VFS 层的任务是维护一个表，每个已经打开的文件都在表中有一个表项。VFS 层为每一个打开的文件维护着一个虚拟i节点，简称为 v - node。v 节点用来说明文件是本地文件还是远程文件。如果是远程文件的话，那么 v - node 会提供足够的信息使客户端能够访问它们。对于本地文件，会记录其所在的文件系统和文件的 i-node ，因为现代操作系统能够支持多文件系统。虽然 VFS 是为了支持 NFS 而设计的，但是现代操作系统都会使用 VFS，而不管有没有 NFS。 Linux IOLinux IO 基本概念 Linux 中也有磁盘、打印机、网络等 I&#x2F;O 设备，Linux 把这些设备当作一种 特殊文件 整合到文件系统中，一般通常位于 &#x2F;dev 目录下。可以使用与普通文件相同的方式来对待这些特殊文件。 特殊文件一般分为两种： 块特殊文件是一个能存储固定大小块信息的设备，它支持以固定大小的块，扇区或群集读取和（可选）写入数据。每个块都有自己的物理地址。通常块的大小在 512 - 65536 之间。所有传输的信息都会以连续的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 硬盘、蓝光光盘、USB 盘与字符设备相比，块设备通常需要较少的引脚。块特殊文件的缺点基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。 另一类 I&#x2F;O 设备是字符特殊文件。字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 打印机、网络设备、鼠标、以及大多数与磁盘不同的设备。 每个设备特殊文件都会和 设备驱动 相关联。每个驱动程序都通过一个 主设备号 来标识。如果一个驱动支持多个设备的话，此时会在主设备的后面新加一个 次设备号 来标识。主设备号和次设备号共同确定了唯一的驱动设备。 套接字(socket)I&#x2F;O 的另外一个概念是网络， 也是由 UNIX 引入，网络中一个很关键的概念就是 套接字(socket)。套接字允许用户连接到网络，正如邮筒允许用户连接到邮政系统，套接字的示意图如下 套接字的位置如上图所示，套接字可以动态创建和销毁。**成功创建一个套接字后，系统会返回一个文件描述符(file descriptor)**，在后面的创建链接、读数据、写数据、解除连接时都需要使用到这个文件描述符。每个套接字都支持一种特定类型的网络类型，在创建时指定。一般最常用的几种 可靠的面向连接的字节流 可靠的面向连接的数据包 不可靠的数据包传输 一旦套接字在源计算机和目的计算机建立成功，那么两个计算机之间就可以建立一个链接。通信一方在本地套接字上使用 listen 系统调用，它就会创建一个缓冲区，然后阻塞直到数据到来。另一方使用 connect 系统调用，如果另一方接受 connect 系统调用后，则系统会在两个套接字之间建立连接。 socket 连接建立成功后就像是一个管道，一个进程可以使用本地套接字的文件描述符从中读写数据，当连接不再需要的时候使用 close 系统调用来关闭。 Linux IO 实现Linux 中的 IO 是通过一系列设备驱动实现的，每个设备类型对应一个设备驱动。设备驱动为操作系统和硬件分别预留接口，通过设备驱动来屏蔽操作系统和硬件的差异。 当用户访问一个特殊的文件时，由文件系统提供此特殊文件的主设备号和次设备号，并判断它是一个块特殊文件还是字符特殊文件。主设备号用于标识字符设备还是块设备，次设备号用于参数传递。 每个驱动程序 都有两部分：这两部分都是属于 Linux 内核，也都运行在内核态下。上半部分运行在调用者上下文并且与 Linux 其他部分交互。下半部分运行在内核上下文并且与设备进行交互。驱动程序可以调用内存分配、定时器管理、DMA 控制等内核过程。可被调用的内核功能都位于 驱动程序 - 内核接口 的文档中。 块设备实现 系统中处理块特殊文件 I&#x2F;O 部分的目标是为了使传输次数尽可能的小。为了实现这个目标，Linux 系统在磁盘驱动程序和文件系统之间设置了一个 高速缓存(cache) ，如下图所示 2.2 版本以后 Linux 内核只有一个统一的缓存一个 通用数据块层(generic block layer) 把这些融合在一起，实现了磁盘、数据块、缓冲区和数据页之间必要的转换。那么什么是通用数据块层？ 通用数据块层是一个内核的组成部分，用于处理对系统中所有块设备的请求。通用数据块主要有以下几个功能 将数据缓冲区放在内存高位处，当 CPU 访问数据时，页面才会映射到内核线性地址中，并且此后取消映射实现 零拷贝机制，磁盘数据可以直接放入用户模式的地址空间，而无需先复制到内核内存中管理磁盘卷，会把不同块设备上的多个磁盘分区视为一个分区。 利用最新的磁盘控制器的高级功能，例如 DMA 等。 cache 是提升性能的利器，不管以什么样的目的需要一个数据块，都会先从 cache 中查找，如果找到直接返回，避免一次磁盘访问，能够极大的提升系统性能。 如果页面 cache 中没有这个块，操作系统就会把页面从磁盘中调入内存，然后读入 cache 进行缓存。 cache 除了支持读操作外，也支持写操作，一个程序要写回一个块，首先把它写到 cache 中，而不是直接写入到磁盘中，等到磁盘中缓存达到一定数量值时再被写入到 cache 中。 字符设备实现 和字符设备的交互是比较简单的。由于字符设备会产生并使用字符流、字节数据，因此对随机访问的支持意义不大。一个例外是使用 行规则(line disciplines)。一个行规可以和终端设备相关联，使用 tty_struct 结构来表示，它表示与终端设备交换数据的解释器，当然这也属于内核的一部分。例如：行规可以对行进行编辑，映射回车为换行等一系列其他操作。 网络设备实现 网络设备的交互是不一样的，虽然 网络设备(network devices) 也会产生字符流，因为它们的异步(asynchronous) 特性是他们不易与其他字符设备在同一接口下集成。网络设备驱动程序会产生很多数据包，经由网络协议到达用户应用程序中。 Linux 安全 一个 Linux 系统的用户群里由一系列注册用户组成，他们每一个都有一个唯一的 UID (User ID)。一个 UID 是一个位于 0 到 65535 之间的整数。文件（进程或者是其他资源）都标记了它的所有者的 UID。默认情况下，文件的所有者是创建文件的人，文件的所有者是创建文件的用户。 用户可以被分成许多组，每个组都会由一个 16 位的整数标记，这个组叫做 GID(组 ID)。给用户分组是手动完成的，它由系统管理员执行，分组就是在数据库中添加一条记录指明哪个用户属于哪个组。一个用户可以属于不同组。 Linux 中的基本安全机制比较容易理解，每个进程都会记录它所有者的 UID 和 GID。当文件创建后，它会获取创建进程的 UID 和 GID。当一个文件被创建时，它的 UID 和 GID 就会被标记为进程的 UID 和 GID。这个文件同时会获取由该进程决定的一些权限。这些权限会指定所有者、所有者所在组的其他用户及其他用户对文件具有什么样的访问权限。对于这三类用户而言，潜在的访问权限是 读、写和执行，分别由 r、w 和 x 标记。当然，执行文件的权限仅当文件时可逆二进制程序时才有意义。试图执行一个拥有执行权限的非可执行文件，系统会报错。 Linux 用户分为三种 root（超级管理员），它的 UID 为 0，这个用户有极大的权限，可以直接无视很多的限制 ，包括读写执行的权限。 系统用户，UID 为 1～499。 普通用户，UID 范围一般是 500～65534。这类用户的权限会受到基本权限的限制，也会受到来自管理员的限制。不过要注意 nobody","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"Linux","permalink":"http://1nameccc.github.io/tags/Linux/"}],"author":"coucou"},{"title":"操作系统——进程&线程实操","slug":"2-2-操作系统-进程线程实操/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:56:58.033Z","comments":true,"path":"2023/08/01/2-2-操作系统-进程线程实操/index/","permalink":"http://1nameccc.github.io/2023/08/01/2-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%93%8D/index/","excerpt":"Linux 多进程和多线程编程","text":"Linux 多进程和多线程编程 多进程123456789101112n=fork() // 创建一个子进程，该命令执行后将产生一个子进程，子进程的PCB以及进程空间都是由父进程拷贝而来的，因而两者相同，差别是返回值。对子进程，n＝0；对父进程，n等于子进程的进程号（即n&gt;0）；n=-1，创建失败。 // 通过判断返回值便可安排父进程和子进程的后继活动，使两者完成不同的任务，通常用法：n=fork();if (n==0) &#123;/*子进程所要执行的代码*/ &#125;else &#123;/*父进程所要执行的代码*/&#125; exec( )系列系统调用 exec()系列，也可用于新程序的运行。fork()只是将父进程的用户级上下文拷贝到新进程中，而 exec()系列可以将一个可执行的二进制文件覆盖在新进程的用户级上下文的存储空间上，以更改新进程的用户级上下文。exec()系列中的系统调用都完成相同的功能，它们把一个新程序装入内存，来改变调用进程的执行代码，从而形成新进程。 如果exec( )调用成功，调用进程将被覆盖，然后从新程序的入口开始执行，这样就产生了一个新进程，新进程的进程标识符id 与调用进程相同。 exec( )没有建立一个与调用进程并发的子进程，而是用新进程取代了原来进程。所以 exec()调用成功后，没有任何数据返回，这与 fork()不同。exec()系列系统调用在UNIX系统库unistd.h中，共有execl、execlp、execle、execv、execvp五个，其基本功能相同，只是以不同的方式来给出参数。 123456789101112131415161718// 一种是直接给出参数的指针，如：Int execl(char *path, char *arg0[,arg1,...argn],0);// 另一种是给出指向参数表的指针，如：Int execv(char *path, char *argv[]);// exec( )和fork( )联合使用// 系统调用 exec 和 fork()联合使用能为程序开发提供有力支持。用 fork()建立子进程，然后在子进程中使用exec( )，这样就实现了父进进程与一个与它完全不同子进程的并发执行。一般，wait、exec 联合使用的模型为：int status; ............if (fork( )= =0) &#123; ...........;execl(...); ...........; &#125;wait(&amp;status);// wait(NULL)的作用是:使子进程优先执行 管道 管道 指能够连接一个写进程和一个读进程的、并允许它们以生产者—消费者方式进行通信的一个共享文件，又称为pipe文件。由写进程从管道的写入端（句柄1）将数据写入管道，而读进程则从管道的读出端（句柄0）读出数据。管道的类型 1、有名管道一个可以在文件系统中长期存在的、具有路径名的文件。用系统调用mknod( )建立。它克服无名管道使用上的局限性，可让更多的进程也能利用管道进行通信。因而其它进程可以知道它的存在，并能利用路径名来访问该文件。对有名管道的访问方式与访问其他文件一样，需先用open( )打开。2、无名管道一个临时文件。利用pipe( )建立起来的无名文件（无路径名）。只用该系统调用所返回的文件描述符来标识该文件，故只有调用pipe( )的进程及其子孙进程才能识别此文件描述符，才能利用该文件（管道）进行通信。3、pipe文件的建立分配磁盘和内存索引结点、为读进程分配文件表项、为写进程分配文件表项、分配用户文件描述符4、读&#x2F;写进程互斥为使读、写进程互斥地访问pipe文件，需使各进程互斥地访问pipe文件索引结点中的直接地址项。因此，每次进程在访问pipe文件前，都需检查该索引结点是否已被上锁。若是，进程便睡眠等待，否则，将其上锁，进行读&#x2F;写。操作结束后解锁，并唤醒因该索引结点上锁而睡眠的进程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511、pipe()// 功能：建立一无名管道// 参数定义int pipe(filedes);int filedes[2];// 其中，filedes[1]是写入端，filedes[0]是读出端。// 该函数使用头文件如下：#include &lt;unistd.h&gt;#inlcude &lt;signal.h&gt;#include &lt;stdio.h&gt;2、read()//功能：从fd所指示的文件中读出nbyte个字节的数据，并将它们送至由指针buf所指示的缓冲区中。如该文件被加锁，等待，直到锁打开为止。//参数定义int read(fd,buf,nbyte);int fd;char *buf;unsigned nbyte;3、write()//系统调用格式// 功能：把nbyte 个字节的数据，从buf所指向的缓冲区写到由fd所指向的文件中。如文件加锁，暂停写入，直至开锁。write (fd,buf,nbyte) 4、exit()// 终止进程的执行。// 系统调用格式：void exit(status)int status;//其中，status是返回给父进程的一个整数。UNIX/LINUX利用exit( )来实现进程的自我终止，通常父进程在创建子进程时，应在进程的末尾安排一条exit( )，使子进程自我终止。exit(0)表示进程正常终止，exit(1)表示进程运行有错，异常终止。如果调用进程在执行exit( )时，其父进程正在等待它的终止，则父进程可立即得到其返回的整数。核心须为exit( )完成以下操作：（1）关闭软中断（2）回收资源（3）写记帐信息（4）置进程为“僵死状态” 5、wait()//等待子进程运行结束。如果子进程没有完成，父进程一直等待。wait( )将调用进程挂起，直至其子进程因暂停或终止而发来软中断信号为止。如果在wait( )前已有子进程暂停或终止，则调用进程做适当处理后便返回。//系统调用格式：int wait(status) int *status;其中，status是用户空间的地址。它的低8位反应子进程状态，为0表示子进程正常结束，非0则表示出现了各种各样的问题；高8位则带回了exit( )的返回值。exit( )返回值由系统给出。6、lockf（files，function,size）// 用做锁定文件的某些段或者整个文件，本函数适用的头文件为：#include&lt;unistd.h&gt;参数定义：int lockf(files,function,size) Int files,function; Long size;// 其中，：files是文件描述符；function是锁定和解锁；1表示锁定，0表示解锁。Size是锁定或解锁的字节数，若为0，表示从文件的当前位置到文件尾。 共享存储区 共享存储区（Share Memory）是UNIX系统中通信速度最高的一种通信机制。该机制可使若干进程共享主存中的某一个区域，且使该区域出现（映射）在多个进程的虚地址空间中。另一方面，一个进程的虚地址空间中又可连接多个共享存储区，每个共享存储区都有自己的名字。当进程间欲利用共享存储区进行通信时，必须先在主存中建立一共享存储区，然后将它附接到自己的虚地址空间上。此后，进程对该区的访问操作，与对其虚地址空间的其它部分的操作完全相同。进程之间便可通过对共享存储区中数据的读、写来进行直接通信。图示列出二个进程通过共享一个共享存储区来进行通信的例子 应当指出，共享存储区机制只为进程提供了用于实现通信的共享存储区和对共享存储区进行操作的手段，然而并未提供对该区进行互斥访问及进程同步的措施。因而当用户需要使用该机制时，必须自己设置同步和互斥措施才能保证实现正确的通信。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071721、shmget( )// 创建、获得一个共享存储区。系统调用格式： shmid=shmget(key,size,flag)// 该函数使用头文件如下：#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;int shmget(key,size,flag);key_t key;int size,flag;// 其中，key是共享存储区的名字；size是其大小（以字节计）；flag是用户设置的标志，如IPC_CREAT。IPC_CREAT表示若系统中尚无指名的共享存储区，则由核心建立一个共享存储区；若系统中已有共享存储区，便忽略IPC_CREAT。附： 操作允许权 八进制数 用户可读 00400 用户可写 00200 小组可读 00040 小组可写 00020 其它可读 00004 其它可写 00002 控制命令 值 IPC_CREAT 0001000 IPC_EXCL 0002000例：shmid=shmget(key,size,(IPC_CREAT|0400))// 创建一个关键字为key，长度为size的共享存储区 2、shmat( )//共享存储区的附接。从逻辑上将一个共享存储区附接到进程的虚拟地址空间上。系统调用格式： virtaddr=shmat(shmid,addr,flag)该函数使用头文件如下：#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;char *shmat(shmid,addr,flag);int shmid,flag;char * addr; // 其中，shmid是共享存储区的标识符；addr是用户给定的，将共享存储区附接到进程的虚地址空间；flag规定共享存储区的读、写权限，以及系统是否应对用户规定的地址做舍入操作。其值为SHM_RDONLY时，表示只能读；其值为0时，表示可读、可写；其值为SHM_RND（取整）时，表示操作系统在必要时舍去这个地址。该系统调用的返回值是共享存储区所附接到的进程虚地址viraddr。3、shmdt()// 把一个共享存储区从指定进程的虚地址空间断开。系统调用格式： shmdt(addr)该函数使用头文件如下：#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt; int shmdt(addr);char addr;// 其中，addr是要断开连接的虚地址，亦即以前由连接的系统调用shmat( )所返回的虚地址。调用成功时，返回0值，调用不成功，返回-1。4、shmctl()// 共享存储区的控制，对其状态信息进行读取和修改。系统调用格式： shmctl(shmid,cmd,buf)该函数使用头文件如下：#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt; int shmctl(shmid,cmd,buf);int shmid,cmd;struct shmid_ds *buf;// 其中，buf是用户缓冲区地址，cmd是操作命令。命令可分为多种类型：（1）用于查询有关共享存储区的情况。如其长度、当前连接的进程数、共享区的创建者标识符等；（2）用于设置或改变共享存储区的属性。如共享存储区的许可权、当前连接的进程计数等；（3）对共享存储区的加锁和解锁命令；（4）删除共享存储区标识符等。// 上述的查询是将shmid所指示的数据结构中的有关成员，放入所指示的缓冲区中；而设置是用由buf所指示的缓冲区内容来设置由shmid所指示的数据结构中的相应成员。 消息的创建,发送和接收 消息 消息（message）是一个格式化的可变长的信息单元。消息机制允许由一个进程给其它任意的进程发送一个消息。当一个进程收到多个消息时，可将它们排成一个消息队列。消息使用二种重要的数据结构：一是消息首部，其中记录了一些与消息有关的信息，如消息数据的字节数；二个消息队列头表，其每一表项是作为一个消息队列的消息头，记录了消息队列的有关信息。 1、消息机制的数据结构 （1）消息首部 记录一些与消息有关的信息，如消息的类型、大小、指向消息数据区的指针、消息队列的链接指针等。 （2）消息队列头表 其每一项作为一个消息队列的消息头，记录了消息队列的有关信息如指向消息队列中第一个消息和指向最后一个消息的指针、队列中消息的数目、队列中消息数据的总字节数、队列所允许消息数据的最大字节总数，还有最近一次执行发送操作的进程标识符和时间、最近一次执行接收操作的进程标识符和时间等。 2、消息队列的描述符 UNIX中，每一个消息队列都有一个称为关键字（key）的名字，是由用户指定的；消息队列有一消息队列描述符，其作用与用户文件描述符一样，也是为了方便用户和系统对消息队列的访问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697981. msgget()//创建一个消息，获得一个消息的描述符。核心将搜索消息队列头表，确定是否有指定名字的消息队列。若无，核心将分配一新的消息队列头，并对它进行初始化，然后给用户返回一个消息队列描述符，否则它只是检查消息队列的许可权便返回。系统调用格式： msgqid=msgget(key,flag)该函数使用头文件如下：#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/msg.h&gt;int msgget(key,flag)key_t key;int flag;// key是用户指定的消息队列的名字；flag是用户设置的标志和访问方式。如 IPC_CREAT |0400 是否该队列已被创建。无则创建，是则打开；IPC_EXCL |0400 是否该队列的创建应是互斥的。msgqid 是该系统调用返回的描述符，失败则返回-1。 2. msgsnd()// 发送一消息。向指定的消息队列发送一个消息，并将该消息链接到该消息队列的尾部。系统调用格式： msgsnd(msgqid,msgp,size,flag)该函数使用头文件如下：#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgsnd(msgqid,msgp,size,flag)int msgqid,size,flag;struct msgbuf * msgp;其中msgqid是返回消息队列的描述符；msgp是指向用户消息缓冲区的一个结构体指针。缓冲区中包括消息类型和消息正文，即&#123; long mtype; /*消息类型*/ char mtext[ ]; /*消息的文本*/&#125;// size指示由msgp指向的数据结构中字符数组的长度；即消息的长度。这个数组的最大值由MSG-MAX( )系统可调用参数来确定。flag规定当核心用尽内部缓冲空间时应执行的动作:进程是等待，还是立即返回。若在标志flag中未设置IPC_NOWAIT位，则当该消息队列中的字节数超过最大值时，或系统范围的消息数超过某一最大值时，调用msgsnd进程睡眠。若是设置IPC_NOWAIT，则在此情况下，msgsnd立即返回。对于msgsnd( )，核心须完成以下工作：（1）对消息队列的描述符和许可权及消息长度等进行检查。若合法才继续执行，否则返回；（2）核心为消息分配消息数据区。将用户消息缓冲区中的消息正文，拷贝到消息数据区；（3）分配消息首部，并将它链入消息队列的末尾。在消息首部中须填写消息类型、消息大小和指向消息数据区的指针等数据；（4）修改消息队列头中的数据，如队列中的消息数、字节总数等。最后，唤醒等待消息的进程。 3. msgrcv()// 接受一消息。从指定的消息队列中接收指定类型的消息。系统调用格式： msgrcv(msgqid,msgp,size,type,flag)本函数使用的头文件如下：#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgrcv(msgqid,msgp,size,type,flag)int msgqid,size,flag;struct msgbuf *msgp;long type;// 其中，msgqid,msgp,size,flag与msgsnd中的对应参数相似，type是规定要读的消息类型，flag规定倘若该队列无消息，核心应做的操作。如此时设置了IPC_NOWAIT标志，则立即返回，若在flag中设置了MS_NOERROR，且所接收的消息大于size，则核心截断所接收的消息。对于msgrcv系统调用，核心须完成下述工作：（1）对消息队列的描述符和许可权等进行检查。若合法，就往下执行；否则返回；（2）根据type的不同分成三种情况处理： type=0，接收该队列的第一个消息，并将它返回给调用者； type为正整数，接收类型type的第一个消息； type为负整数，接收小于等于type绝对值的最低类型的第一个消息。（3）当所返回消息大小等于或小于用户的请求时，核心便将消息正文拷贝到用户区，并从消息队列中删除此消息，然后唤醒睡眠的发送进程。但如果消息长度比用户要求的大时，则做出错返回。 4. msgctl()// 消息队列的操纵。读取消息队列的状态信息并进行修改，如查询消息队列描述符、修改它的许可权及删除该队列等。系统调用格式： msgctl(msgqid,cmd,buf);本函数使用的头文件如下：#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgctl(msgqid,cmd,buf);int msgqid,cmd;struct msgqid_ds *buf;// 其中，函数调用成功时返回0，不成功则返回-1。buf是用户缓冲区地址，供用户存放控制参数和查询结果；cmd是规定的命令。命令可分三类：（1）IPC_STAT。查询有关消息队列情况的命令。如查询队列中的消息数目、队列中的最大字节数、最后一个发送消息的进程标识符、发送时间等；（2）IPC_SET。按buf指向的结构中的值，设置和改变有关消息队列属性的命令。如改变消息队列的用户标识符、消息队列的许可权等；（3）IPC_RMID。消除消息队列的标识符。// msgqid_ds 结构定义如下：struct msgqid_ds &#123; struct ipc_perm msg_perm; /*许可权结构*/ short pad1[7]; /*由系统使用*/ ushort msg_qnum; /*队列上消息数*/ ushort msg_qbytes; /*队列上最大字节数*/ ushort msg_lspid; /*最后发送消息的PID*/ ushort msg_lrpid; /*最后接收消息的PID*/ time_t msg_stime; /*最后发送消息的时间*/ time_t msg_rtime; /*最后接收消息的时间*/ time_t msg_ctime; /*最后更改时间*/ &#125;;struct ipc_perm &#123; ushort uid; /*当前用户*/ ushort gid; /*当前进程组*/ ushort cuid; /*创建用户*/ ushort cgid; /*创建进程组*/ ushort mode; /*存取许可权*/ &#123; short pid1; long pad2;&#125; /*由系统使用*/ &#125; 线程与同步 POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。 该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;pthread.h&gt; // 头文件数据类型：pthread_t：线程ID操纵函数1、int pthread_create(pthread_t* thread, pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);//创建一个由调用线程控制的新的线程并发运行。新的线程使用start_routine作为实现体，并以arg作为第一个参数。//新的线程可以通过调用pthread_exit显式结束，或者通过start_routine return来隐式结束。 其中后者等价于调用pthread_exit并以start_routine 的返回值作为退出码。//attr参数指明新线程的属性，如果attr=NULL,则使用默认属性：新线程是joinable(not detached),和默认的调度策略(非实时) //返回值：如果成功，新线程的指针会被存储到thread的参数中，并返回0。如果错误则一个非0的错误码返回。 如果返回EAGAIN，没有足够的系统资源创建一个线程，或者已经存在大于PTHREAD_THREADS_MAX个活跃线程。2、int pthread_join(pthread_t th, void **thread_return); // 阻塞当前的线程，直到另外一个线程运行结束// 挂载一个在执行的线程直到线程通过调用pthread_exit或者cancelled结束。//如果thread_return不为空，则线程th的返回值会保存到thread_return所指的区域。 //th的返回值是它给pthread_exit的参数，或者是pthread_canceled 如果是被cancelled的。 //被依附的线程th必须是joinable状态。一定不能是detached通过使用pthread_detach或者pthread_create中使用pthread_create_detached属性。 //当一个joinable线程结束时，他的资源(线程描述符和堆栈)不会被释放直到另一个线程对它执行pthread_join操作。 如果成功，返回值存储在thread_return中，并返回0，否则返回错误码：• ESRCH:找不到指定线程• EINVAL:线程th是detached或者已经存在另一个线程在等待线程th结束• EDEADLK:th的参数引用它自己(即线程不能join自身)互斥锁类型：pthread_mutex_t操纵函数pthread_mutex_init()： // 初始化互斥锁pthread_mutex_lock()： // 加锁pthread_mutex_unlock()： // 解锁gcc main.c -lpthread // 使用 Pthreads 时，编译时必须加上 -lpthread 信号量12345678910111213#include &lt;semaphore.h&gt; // 头文件1. sem_init()int sem_init(sem_t *sem, int pshared, unsigned int value);// sem: 要初始化的信号量// pshared: 非0表示此信号量是在进程间共享，0表示是线程间共享// value： 是信号量的初始值。 2. sem_wait()int sem_wait(sem_t *sem); // 等待信号量，如果信号量的值大于0,将信号量的值减1,立即返回。如果信号量的值为0,则线程阻塞。 3. sem_post()int sem_post(sem_t *sem); // 释放信号量，让信号量的值加1。 文件操作123456789101112131415161718192021222324251. fopen() // 打开一个文件。 FILE * fopen(const char * filename, const char * mode);// mode模式说明: r 以只读方式打开文件，该文件必须存在。 w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件. + 以可读写方式打开文件，该文件必须存在。 b 打开一个二进制文件，只允许读写数据。 a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留） 2. fclose() // 关闭一个文件。如果成功关闭，fclose 返回 0，否则返回EOF（-1）。int fclose(FILE *stream);3. fgetc() // 从文件中读取字符。返回读取的一个字节。如果读到文件末尾返回EOF。int fgetc(FILE *stream);4. fputc() // 输出一个字符到文件中。int fputc(int ch, FILE *stream);5. putchar() // 输出一个字符到标准输出（即显示器）中。等价于：fputc(ch, STDOUT);int putchar(int ch);","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程&线程实操","slug":"进程-线程实操","permalink":"http://1nameccc.github.io/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%93%8D/"}],"author":"coucou"},{"title":"操作系统——FreeRTOS","slug":"2-3-操作系统-FreeRTOS/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:57:02.765Z","comments":true,"path":"2023/08/01/2-3-操作系统-FreeRTOS/index/","permalink":"http://1nameccc.github.io/2023/08/01/2-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-FreeRTOS/index/","excerpt":"操作系统——FreeRTOS","text":"操作系统——FreeRTOS 创建任务 在FreeRTOS中，动态创建任务和静态创建任务是两种不同的任务创建方式，它们有一些重要的区别。 动态创建任务： 内存动态分配： 动态创建任务会在运行时动态分配内存。这意味着任务的堆栈和控制块等资源将在运行时从内存中分配，因此需要在运行时调用 xTaskCreate() 函数，并提供足够的堆栈和控制块内存。 灵活性： 动态创建任务允许在运行时根据需要动态创建和删除任务。这使得可以根据系统的实际需求来动态调整任务的数量。 返回值： xTaskCreate() 返回一个 TaskHandle_t 类型的句柄，可以用于后续对任务的操作。 静态创建任务： 预先分配内存： 静态创建任务需要在编译时就为任务分配足够的内存，这可以在任务创建之前通过定义一个 StaticTask_t 类型的变量和一个 StackType_t 类型的数组来实现。 效率： 静态创建任务相对于动态创建任务来说，效率可能会更高，因为它不需要在运行时进行内存分配和释放操作。 固定数量： 静态创建任务的数量是固定的，因为内存是在编译时分配的。这也意味着你需要提前知道系统中可能存在的任务数量。 如何选择： 如果你知道在编译时就可以确定系统中的任务数量，并且希望在运行时减少动态内存分配的开销，可以考虑使用静态创建任务。 如果你的系统需要在运行时动态地创建和删除任务，或者你无法提前确定任务的数量，那么动态创建任务可能是更好的选择。 任务优先级相同 在FreeRTOS中，如果有多个任务具有相同的优先级，任务的运行顺序将取决于FreeRTOS的任务调度策略。FreeRTOS支持两种任务调度策略：抢占式调度（Preemptive Scheduling）和协作式调度（Cooperative Scheduling）。这两种策略决定了当具有相同优先级的多个任务都准备好运行时，哪个任务将获得CPU执行的机会。 抢占式调度（Preemptive Scheduling）： 在抢占式调度下，具有相同优先级的多个任务中，具有更高运行时间的任务将首先获得CPU执行的机会。如果一个任务具有更高的优先级，它可以随时抢占具有较低优先级的任务，并立即执行。这种策略确保了任务按照其优先级的重要性进行执行，高优先级任务可以随时中断低优先级任务。 协作式调度（Cooperative Scheduling）： 在协作式调度下，具有相同优先级的多个任务必须自行让出CPU执行的机会。如果一个任务不主动让出CPU，那么其他具有相同优先级的任务可能无法执行，导致系统死锁或任务饥饿。在协作式调度中，任务必须显示调用任务切换函数，例如 taskYIELD()，以便让出CPU。 因此，如果您的FreeRTOS应用程序中有多个具有相同优先级的任务，并且您正在使用抢占式调度策略，那么具有更高运行时间的任务将首先获得CPU执行的机会。如果您使用协作式调度策略，则需要确保任务主动调用任务切换函数以让出CPU。在任务之间进行合适的任务切换是确保系统正常工作的关键。如果没有明确的任务切换，那么可能会导致任务无法正常执行或产生不可预测的行为。 消息队列 在FreeRTOS中，队列是一种常用的通信和同步机制，用于在任务之间传递数据。队列实现了一个先进先出（FIFO）的数据结构，任务可以向队列发送数据或从队列接收数据。以下是FreeRTOS队列的基本原理： 队列的数据结构： 队列控制块（Queue Control Block）： FreeRTOS中的每个队列都由一个队列控制块（Queue_t）来管理。队列控制块包含了队列的属性（如队列的长度、每个元素的大小等）以及指向队列中存储数据的缓冲区的指针。 缓冲区： 队列的实际数据存储在一个缓冲区中。当任务发送数据到队列时，数据会被复制到缓冲区。当任务从队列接收数据时，数据会从缓冲区复制到任务的接收变量中。 队列的基本操作： 创建队列： 首先，使用xQueueCreate()函数创建一个队列。这个函数接受两个参数：队列的长度（能够容纳的元素数量）和每个元素的大小（以字节为单位）。 1QueueHandle_t xQueue = xQueueCreate(queueLength, itemSize); 发送数据到队列： 使用xQueueSend()函数将数据发送到队列。这个函数接受队列句柄、待发送的数据指针和阻塞时间（如果队列已满）作为参数。 1xQueueSend(xQueue, &amp;data, portMAX_DELAY); // 阻塞直到队列可用 从队列接收数据： 使用xQueueReceive()函数从队列接收数据。这个函数接受队列句柄、接收数据的指针和阻塞时间（如果队列为空）作为参数。 1xQueueReceive(xQueue, &amp;receivedData, portMAX_DELAY); // 阻塞直到队列中有数据 队列的阻塞和非阻塞操作： 阻塞操作： 在阻塞模式下，如果队列已满（对于发送操作）或者队列为空（对于接收操作），任务将被阻塞，直到队列可用或者超时。 非阻塞操作： 如果在非阻塞模式下，如果队列已满或者队列为空，xQueueSend()和xQueueReceive()函数会立即返回，而不是等待。 队列的使用可以实现任务间的同步和通信，使得任务能够安全地交换数据而不需要使用全局变量或者其他共享资源。请根据您的应用需求选择合适的队列操作函数，并在发送和接收数据时考虑阻塞和非阻塞的需求。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"http://1nameccc.github.io/tags/FreeRTOS/"}],"author":"coucou"},{"title":"操作系统——Linux命令","slug":"2-5-操作系统-Linux常用命令/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:57:44.254Z","comments":true,"path":"2023/08/01/2-5-操作系统-Linux常用命令/index/","permalink":"http://1nameccc.github.io/2023/08/01/2-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/index/","excerpt":"Linux命令集","text":"Linux命令集 1. linux常用命令1.1 目录切换12345cd / # 绝对路径 cd ./ # 相对路径cd .. # 返回上一级 cd ~ # 回到根目录cd - # 回到桌面 1.2 增删改查1234567mkdir [dir] || mkdir /user/[dir] (指定目录) # 创建目录touch [file] # 创建文件rm [file] || rm -f [file] || rm -rf [file] || rm -rf * # 删除文件或者文件夹mv [file1] [file2] # 重命名mv [file1] /user/dir(新位置) # 剪切find /user/dir -name &#x27;a*&#x27;ls -l || -a ls /[dir] # 指定目录 1.3 Linux复制粘贴123456# 终端下：复制：ctrl + shift + c粘贴：ctrl + shift + v# 控制台下：复制：ctrl + [insert](url) 或 鼠标选中粘贴：shift + insert 或 单击鼠标左键 1.4 系统相关1234su # 所有使用者 sudo # 以管理员身份运行ps -ef # 查看进程kill pid # 结束进程 1.5 其他12345shutdown -h nowpower offifconfig --help # 查看网卡信息man shutdown # 查看帮助tar -zxvf test.tar.gz # 解压缩 2. vim文件操作2.1 三种模式12345命令模式 （移动光标，剪切，复制，粘贴）默认进入命令 输入模式（编辑） # 命令&#x27;a/i/o&#x27; -&gt; 输入 -&gt; &#x27;esc&#x27; -&gt; 命令 末行模式（保存，退出，替换） # 输入 -&gt; esc -&gt; 命令&#x27;:&#x27; -&gt; 末行 # 进入末行模式: 命令模式输入： w：保存 q：退出 q!：强制退出 wq：保存退出 2.2 插入文本123456i 在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动I 在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令o 在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本O 在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本a 在当前光标所在位置之后插入随后输入的文本A 在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行 a 命令 2.3 查找文本123456/abc 从光标所在位置向前查找字符串 abc/^abc 查找以 abc 为行首的行/abc$ 查找以 abc 为行尾的行?abc 从光标所在为主向后查找字符串 abcn 向同一方向重复上次的查找指令N 向相反方向重复上次的查找指定 2.4 替换文本12345r 替换光标所在位置的字符R 从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束:s/a1/a2/g 将当前光标所在行中的所有 a1 用 a2 替换:n1,n2s/a1/a2/g 将文件中 n1 到 n2 行中所有 a1 都用 a2 替换:g/a1/a2/g 将文件中所有的 a1 都用 a2 替换 2.5 文本删除123456x 删除光标所在位置的字符dd 删除光标所在行ndd 删除当前行（包括此行）后 n 行文本dG 删除光标所在行一直到文件末尾的所有内容D 删除光标位置到行尾的内容:a1,a2d 函数从 a1 行到 a2 行的文本内 2.6 复制粘贴12345p 将剪贴板中的内容粘贴到光标后P 将剪贴板中的内容粘贴到光标前y 复制已选中的文本到剪贴板yy 将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行yw 将光标位置的单词复制到剪贴板 2.7 方向快捷键12345678910111213141516171819202122h 光标向左移动一位j 光标向下移动一行（以回车为换行符），也就是光标向下移动k 光标向上移动一行（也就是向上移动）l 光标向右移动一位w 或 W 光标移动至下一个单词的单词首b 或 B 光标移动至上一个单词的单词首e 或 E 光标移动至下一个单词的单词尾nw 或 nW n 为数字，表示光标向右移动 n 个单词nb 或 nB n 为数字，表示光标向左移动 n 个单词0 或 ^ 光标移动至当前行的行首$ 光标移动至当前行的行尾n$ 光标移动至当前行只有 n 行的行尾，n为数字gg 光标移动到文件开头G 光标移动至文件末尾nG 光标移动到第 n 行，n 为数字:n 编辑模式下使用的快捷键，可以将光标快速定义到指定行的行首","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux命令","slug":"Linux命令","permalink":"http://1nameccc.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"}],"author":"coucou"},{"title":"操作系统——UCOS3","slug":"2-6-操作系统-UCOS3/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:57:43.290Z","comments":true,"path":"2023/08/01/2-6-操作系统-UCOS3/index/","permalink":"http://1nameccc.github.io/2023/08/01/2-6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-UCOS3/index/","excerpt":"实时操作系统之UCOS3","text":"实时操作系统之UCOS3 简介 RTOS的内核负责管理所有的任务，内核决定了运行哪个任务，何时停止当前任务切换到其他任务，这个是内核的多任务管理能力。多任务管理给人的感觉就好像芯片有多个CPU，多任务管理实现了CPU资源的最大化利用，多任务管理有助于实现程序的模块化开发，能够实现复杂的实时应用。 RTOS操作系统：UCOS，FreeRTOS，RTX，RT-Thread，DJYOS等 任务管理延时函数 函数 描述 delay_osschedlock() 任务调度器加锁，对UCOS中的对应函数做封装。 delay_osschedunlock() 任务调度器解锁，对UCOS中的对应函数做封装。 delay_ostimedly() 延时，按照节拍数延时，对UCOS中的对应函数做封装。 SysTick_Handler() 滴答定时器中断服务函数。 delay_init() 滴答定时器&#x2F;延时初始化。 delay_us() 微秒延时，不会引发任务调度。 Delay_ms() 毫秒延时，最小ms延时时间为UCOS系统心跳时间。 任务组成 UCOSIII中的任务由三部分组成：任务堆栈、任务控制块和任务函数。 任务堆栈：上下文切换的时候用来保存任务的工作环境，就是STM32的内部寄存器值 任务控制块：任务控制块用来记录任务的各个属性 任务函数：由用户编写的任务处理代码 系统任务 UCOSIII默认有5个系统任务： 空闲任务 1、空闲任务是UCOSIII创建的第一个任务。 2、空闲任务是UCOSIII必须创建的。 3、空闲任务优先级总是为OS_CFG_PRIO_MAK-1。 4、空闲任务中不能调用任何可使空闲任务进入等待态的函数！ 时钟节拍任务 时钟节拍任务用来跟踪任务延时和任务等待超时，任务函数为OS_TickTask()，是UCOSIII必须创建的一个任务，任务优先级用宏OS_CFG_TICK_TASK_PRIO来定义 ，一般时钟节拍任务的任务应该设置一个相对较高的优先级。 统计任务 可选任务，用来统计CPU使用率和各个任务的堆栈使用量。此任务是可选任务，由宏OS_CFG_STAT_TASK_EN控制是否使用此任务。使用步骤： 1、将宏OS_CFG_STAT_TASK_EN置1。 2、必须在main函数创建的以一个任务也是唯一的一个应用任务里面调用函数OSStatTaskCPUUsageInit()。 3、统计任务的优先级通过宏OS_CFG_STAT_TASK_PRIO来设置，一般设置OS_CFG_PRIO_MAX-2,也就是倒数第二个优先级。 定时任务 UCOSIII提供软件定时器功能，定时任务是可选的，将宏OS_CFG_TMR_EN设置为1就会使能定时任务，在OSInit()中将会调用函数**OS_TmrInit()**来创建定时任务。定时任务的优先级通过宏OS_CFG_TMR_TASK_PRIO定义，ALIENTEK默认将定时器任务优先级设置为2。 中断服务管理任务 当把os_cfg.h文件中的宏OS_CFG_ISR_POST_DEFERRED_EN置1就会使能中断服务管理任务，当ISR(中断服务函数)调用UCOSIII提供的“post”函数时，要发送的数据和发送的目的地都会存入一个特别的缓冲队列中，当所有嵌套的ISR都执行完成以后UCOSIII会做任务切换，运行中断服务管理任务，该任务会把缓存队列中存放的信息重发给相应的任务。这样做的好处就是可以减少中断关闭的时间，否则，在ISR中还需要把任务从等待列表中删除，并把任务放入就绪表，以及做一些其他的耗时操作。 中断服务管理任务的优先级永远为0，不可更改！ 123456789钩子函数一般主要是用来扩展其他函数(任务)功能的，钩子函数有如下几个： 1、OSIdleTaskHook()，空闲任务调用这个函数，可以用来让CPU进入低功耗模式 2、OSInitHook()，系统初始化函数OSInit()调用此函数。 3、OSStatTaskHook(),统计任务每秒中都会调用这个函数，此函数允许你向统计任务中添加自己的应用函数。 4、OSTaskCreateHook(),任务创建的钩子函数。 5、OSTaskDelHook(),任务删除的钩子函数。 6、OSTaskReturnHook(),任务意外返回时调用的钩子函数，比如删除某个任务 7、OSTaskSwHook(),任务切换时候调用的钩子函数。 8、OSTimeTickHook()，滴答定时器调用的钩子函数。 任务状态 1、休眠态：任务已经在CPU的flash中了，但是还不受UCOSIII管理。 2、就绪态：系统为任务分配了任务控制块，并且任务已经在就绪表中登记，这时这个任务就具有了运行的条件，此时任务的状态就是就绪态。 3、运行态：任务获得CPU的使用权，正在运行。 4、等待态：正在运行的任务需要等待一段时间，或者等待某个事件，这个任务就进入了等待态，此时系统就会把CPU使用权转交给别的任务。 5、中断服务态：当发送中断，当前正在运行的任务会被挂起，CPU转而去执行中断服务函数，此时任务的任务状态叫做中断服务态。 任务堆栈的创建 任务堆栈是任务的重要部分，堆栈是在RAM中按照“先进先出(FIFO)”的原则组织的一块连续的存储空间。为了满足任务切换和响应中断时保存CPU寄存器中的内容及任务调用其它函数时的需要，每个任务都应该有自己的堆栈。 #define START_STK_SIZE 512 &#x2F;&#x2F;堆栈大小 CPU_STK START_TASK_STK[START_STK_SIZE]; &#x2F;&#x2F;定义一个数组来作为任务堆栈 CPU_STK为CPU_INT32U类型，也就是unsigned int类型，为4字节的，那么任务堆栈START_TASK_STK的大小就为：512 X 4&#x3D;2048字节! 12345678910111213141516171819202122// 任务堆栈的初始化,用户一般不会直接操作堆栈初始化函数，任务堆栈初始化函数由任务创建函数OSTaskCreate()调用。不同的CPU对于的寄存器和对堆栈的操作方式不同，因此在移植UCOSIII的时候需要用户根据各自所选的CPU来编写任务堆栈初始化函数。CPU_STK *OSTaskStkInit (OS_TASK_PTR p_task, void *p_arg, CPU_STK *p_stk_base, CPU_STK *p_stk_limit, CPU_STK_SIZE stk_size, OS_OPT opt)// 任务创建void OSTaskCreate (OS_TCB *p_tcb, CPU_CHAR *p_name, OS_TASK_PTR p_task, void *p_arg, OS_PRIO prio, CPU_STK *p_stk_base, //任务堆栈基地址 CPU_STK_SIZE stk_limit, //任务堆栈栈深 CPU_STK_SIZE stk_size, //任务堆栈大小 OS_MSG_QTY q_size, OS_TICK time_quanta, void *p_ext, OS_OPT opt, OS_ERR *p_err)// 函数OSTaskCreate()中的参数p_stk_base是任务堆栈基地址，那么如果CPU的堆栈是向上增长的话那么基地址就&amp;START_TASK_STK[0],如果CPU堆栈是向下增长的话基地址就是&amp;START_TASK_STK[START_STK_SIZE-1]STM32的堆栈是向下增长的！ 任务控制块 任务控制块是用来记录与任务相关的信息的数据结构，每个任务都要有自己的任务控制块。任务控制块由用户自行创建，如下代码为创建一个任务控制块： OS_TCB StartTaskTCB; &#x2F;&#x2F;创建一个任务控制块 OS_TCB为一个结构体，描述了任务控制块，任务控制块中的成员变量用户不能直接访问，更不可能改变他们。 任务优先级和就绪表 UCOSIII中任务优先级数由宏OS_CFG_PRIO_MAX来配置，UCOSIII中数值越小，优先级越高，最低可用优先级就是OS_CFG_PRIO_MAX-1。 UCOSIII中就绪表由2部分组成： 1、优先级位映射表OSPrioTbl[]：用来记录哪个优先级下有任务就绪。 2、就绪任务列表OSRdyList[]：用来记录每一个优先级下所有就绪的任务。 任务调度 任务级调度器为函数OSSched()。 中断级调度器为函数OSIntExit()，当退出外部中断服务函数的时候使用中断级任务调度。 任务调度点 1、释放信号量或者发送消息，也可通过配置相应的参数不发生任务调度。 2、使用延时函数OSTimeDly()或者OSTimeDlyHMSM()。 3、任务等待的事情还没发生(等待信号量，消息队列等)。 4、任务取消等待。 5、创建任务。 6、删除任务。 7、删除一个内核对象。 8、任务改变自身的优先级或者其他任务的优先级。 9、任务通过调用OSTaskSuspend()将自身挂起。 10、任务解挂某个挂起的任务。 11、退出所有的嵌套中断。 12、通过OSSchedUnlock()给调度器解锁。 13、任务调用OSSchedRoundRobinYield()放弃其执行时间片。 14、用户调用OSSched()。 任务调度上锁和解锁 有时候我们并不希望发生任务调度，因为始终有一些代码的执行过程是不能被打断的。此时我们就可以使用函数OSSchedLock()对调度器加锁，当我们想要恢复任务调度的时候就可以使用函数OSSchedUnlock()给已经上锁的任务调度器解锁 时间片轮转调度 UCOSIII允许一个优先级下有多个任务，每个任务可以执行指定的时间(时间片)，然后轮到下一个任务，这个过程就是时间片轮转调度，当一个任务不想在运行的时候就可以放弃其时间片。 时间片轮转调度器为：OS_SchedRoundRobin()。 任务 时间片数 Task1 4 Task2 4 Task3 4 任务切换 当UCOSIII需要切换到另外一个任务时，它将保存当前任务的现场到当前任务的堆栈中，主要是CPU寄存器值，然后恢复新的现场并且执行新的任务，这个过程就是任务切换。 任务切换分为两种：任务级切换和中断级切换。 任务级切换函数为：OSCtxSw()。 中断级切换函数为：OSIntCtxSw()。 系统初始化12345678910111213// 在使用UCOSIII之前我们必须先初始化UCOSIII，函数OSInit()用来完成UCOSIII的初始化，而且OSInit()必须先于其他UCOSIII函数调用，包括OSStart()。int main(void)&#123; OS_ERR err; …… //其他函数，一般为外设初始化函数 …… OSInit(&amp;err); …… //其他函数，一般为创建任务函数 …… OSStart(&amp;err);&#125; 任务创建和删除123456789101112131415161718192021222324// 任务创建void OSTaskCreate ( OS_TCB *p_tcb, CPU_CHAR *p_name, OS_TASK_PTR p_task, void *p_arg, OS_PRIO prio, CPU_STK *p_stk_base, CPU_STK_SIZE stk_limit, CPU_STK_SIZE stk_size, OS_MSG_QTY q_size, OS_TICK time_quanta, void *p_ext, OS_OPT opt, OS_ERR *p_err)// 任务删除void OSTaskDel (OS_TCB *p_tcb, OS_ERR *p_err)// 任务挂起void OSTaskSuspend ( OS_TCB *p_tcb, OS_ERR *p_err)// 任务恢复 void OSTaskResume (OS_TCB *p_tcb, OS_ERR *p_err) 时间片轮转调度 时间片轮转调度器用于时间片轮转调度，为函数OS_SchedRoundRobin(), 此函数由OSTimeTick或者OS_IntQTask()调用，函数在文件os_core.c中定义 如果我们想要使用UCOSIII的时间片轮转调度的话不仅要将宏OS_CFG_SCHED_ROUND_ROBIN_EN置1 1234567// 轮转调度配置void OSSchedRoundRobinCfg (CPU_BOOLEAN en, OS_TICK dflt_time_quanta, OS_ERR *p_err)// 放弃本次时间片void OSSchedRoundRobinYield (OS_ERR *p_err) 中断和时间管理中断123456789101112131415161718// 例，串口中断处理void USART1_IRQHandler(void)&#123; OSIntEnter(); //中断服务程序 OSIntExit();&#125; void OSIntEnter (void)&#123; if (OSRunning != OS_STATE_OS_RUNNING) &#123; return &#125; if (OSIntNestingCtr &gt;= (OS_NESTING_CTR)250u) &#123; return; &#125; OSIntNestingCtr++; // OSIntNestingCtr来记录中断嵌套次数，UCOSIII最多支持250级的中断嵌套。退出中断服务函数时要调用函数 OSIntExit()。&#125; 临界断代码保护 临界段代码也叫做临界区，是指那些必须完整连续运行，不可被打断的代码段。当访问这些临界段代码的时候需要对这些临界段代码进行保护。 当宏OS_CFG_ISR_POST_DEFERRED_EN为0时，UCOSIII使用关中断的方式来保护临界段代码，当设置为1的时候就会采用给调度器上锁的方式来保护临界段代码。 UCOSIII定义了一个进入临界段代码的宏：**OS_CRITICAL_ENTER()，定义了两个退出临界段代码的宏：OS_CRITICAL_EXIT()**和OS_CRITICAL_EXIT_NO_SCHED()。 任务延时 UCOSIII中的任务是一个无限循环并且还是一个抢占式内核，为了使高优先级的任务不至于独占CPU，可以给其他优先级较低任务获取CPU使用权的机会，UCOSIII中除空闲任务外的所有任务必须在合适的位置调用系统提供的延时函数，让当前的任务暂停运行一段时间并进行一个任务切换。 延时函数有两种，OSTimeDly()和OSTimeDlyHMSM()。 OSTimeDly()函数有三种工作模式：相对模式、周期模式和绝对模式。 OSTimeDlyHMSM()函数仅在相对模式下工作。 延时任务可通过在其他任务中调用函数**OSTimeDlyResume()**取消延时而进入就绪状态，此函数最后会引发一次任务调度。 获取和设置系统时间 UCOSIII定义了一个CPU_INT32U类型的全局变量OSTickCtr来记录系统时钟节拍数，在调用OSInit()时被初始化为0，以后每发生1个时钟节拍，OSTickCtr加1。 OSTimeSet()允许用户改变当前时钟节拍计数器的值，慎用！！！！！ OSTimeGet()用来获取动迁时钟节拍计数器的值。 软件定时器 定时器本质是递减计数器，当计数器减到零时可以触发某种动作的执行，这个动作通过回调函数来实现。当定时器计时完成时，定义的回调函数就会被立即调用，应用程序可以有任意数量的定时器，UCOSIII中定时器的时间分辨率由一个宏OS_CFG_TMR_TASK_RATE_HZ，单位为HZ，默认为100Hz。 函数名 作用 OSTmrCreate() 创建定时器并制定运行模式 OSTmrDel() 删除定时器 OSTmrRemainGet() 获取定时器的剩余时间 OSTmrStart() 启动定时器计数 OSTmrStateGet() 获取当前定时器状态 OSTmrStop() 停止计数器倒计时 123456789// 创建定时器OSTmrCreate (OS_TMR *p_tmr, CPU_CHAR *p_name, OS_TICK dly, OS_TICK period, OS_OPT opt, // 模式 OS_TMR_CALLBACK_PTR p_callback, void *p_callback_arg, OS_ERR *p_err) 信号量和互斥信号量信号量 信号量像是一种上锁机制，代码必须获得对应的钥匙才能继续执行，一旦获得了钥匙，也就意味着该任务具有进入被锁部分代码的权限。一旦执行至被锁代码段，则任务一直等待，直到对应被锁部分代码的钥匙被再次释放才能继续执行。 信号量用于控制对共享资源的保护，但是现在基本用来做任务同步用。 要想获取资源的任务必须执行等待操作，如果该资源对应的信号量有效值大于1，则任务可以获得该资源，任务继续运行。如果该信号量的有效值为0，则任务加入等待信号量的任务表中。如果等待时间超过某一个设定值，该信号量仍然没有被释放掉，则等待信号量的任务就进入就绪态，如果将等待时间设置为0的话任务就将一直等待该信号量 信号量通常分为两种：二进制信号量和计数型信号量。 二进制信号量只能取0和1两个值，计数型信号量的信号量值大于1，计数型信号量的范围由OS_SEM_CTR决定，OS_SEM_CTR可以为8位，16位和32位，取值范围分别为：0255,065535和0~4294967295。 二进制信号量用于那些一次只能一个任务使用的资源，比如I&#x2F;O设备，打印机计；计数型信号量用于某些资源可以同时被几个任务所使用，比如一个缓存池有10个缓存块，那么同时最多可以支持10个任务来使用内存池 函数名 作用 OSSemCreate() 建立一个信号量 OSSemDel() 删除一个信号量 OSSemPend() 等待一个信号量 OSSemPendAbrot() 取消等待 OSSemPost() 释放或者发出一个信号量 OSSemSet() 强制设置一个信号量的值 互斥信号量 函数名 作用 OSMutexCreate() 建立一个互斥信号量 OSMutexDel() 删除一个互斥信号量 OSMutexPend() 等待一个互斥信号量 OSMutexPendAbrot() 取消等待 OSMutexPost() 释放或者发布一个互斥信号量 在UCOSIII中每个任务都有自己的内嵌的信号量，这种功能不仅能够简化代码，而且比使用独立的信号量更有效。任务信号量是直接内嵌在UCOSIII中的，任务信号量相关代码在os_task.c中。 OSTaskSemPend() 等待一个任务信号量 OSTaskSemPendAbort() 取消等待任务信号量 OSTaskSemPost() 发布任务信号量 OSTaskSemSet() 强行设置任务信号量计数 消息传递 一个任务或者中断服务程序有时候需要和另一个任务交流信息，这个就是消息传递的过程就叫做任务间通信，任务间的消息传递可以通过2种途径：一是通过全局变量，二是通过发布消息。 使用全局变量的时候每个任务或者中断服务程序都必须保证其对全局变量的独占访问。消息也可以通过消息队列作为中介发布给任务。 消息包含一下几个部分：指向数据的指针，数据的长度和记录消息发布时刻的时间戳，指针指向的可以是一块数据区域或者甚至是一个函数。 123456789101112131415161718192021222324252627// 消息队列是UCOSIII中的一个内核对象，为结构体OS_Qstruct os_q &#123;OS_OBJ_TYPE Type; CPU_CHAR *NamePtr; OS_PEND_LIST PendList; #if OS_CFG_DBG_EN &gt; 0u OS_Q *DbgPrevPtr; OS_Q *DbgNextPtr; CPU_CHAR *DbgNamePtr;#endifOS_MSG_Q MsgQ //消息列表&#125;;// OS_MSG_Q也是一个结构体struct os_msg_q &#123; OS_MSG *InPtr; OS_MSG *OutPtr; OS_MSG_QTY NbrEntriesSize; OS_MSG_QTY NbrEntries; OS_MSG_QTY NbrEntriesMax;&#125;;// 消息发布以后会被存放在OS_MSG类型的数据结构中，OS_MSG如下struct os_msg &#123;OS_MSG *NextPtr; void *MsgPtr; OS_MSG_SIZE MsgSize; CPU_TS MsgTS;&#125;; 函数名 作用 OSQCreate() 创建一个消息 队列 OSQDel() 删除一个消息队列 OSQFlush() 清空消息队列 OSQPend() 等待消息 OSQPendAbort() 取消等待消息 OSQPost() 向消息队列发布一则消息 同任务内嵌信号量一样，UCOSIII的每个任务中也有内建消息队列。而且多个任务等待同一个消息队列的应用很少见，UCOSIII中每个任务多有其内建消息队列的话用户可以不用通过外部的消息队列而直接向任务发布消息。 如果需要使用任务内建消息队列功能的时候需要将宏OS_CFG_TASK_Q_EN置1来使能相关的代码。 函数名 作用 OSTaskQPend() 等待消息 OSTaskQPendAbort() 取消等待消息 OSTaskQPost() 向任务发布一则消息 OSTaskQFlush() 清空任务的消息队列 同时等待多个内核对象 有时候一个任务需要与多个事件同步，这个时候就需要使用事件标志组。事件标志组与任务之间有两种同步机制：“或”同步和“与”同步。 “或”同步：等待多个事件时，任何一个事件发生 ，任务都被同步，这个就称为“或”同步。 “与”同步：当所有的事件都发生时任务才被同步，这种同步机制被称为“与”同步。 在UCOSIII中事件标志组为OS_FLAG_GRP，如果需要使用事件标志组的时候需要将宏OS_CFG_FLAG_EN置1， 123456789101112struct os_flag_grp &#123; OS_OBJ_TYPE Type; CPU_CHAR *NamePtr; OS_PEND_LIST PendList; #if OS_CFG_DBG_EN &gt; 0u OS_FLAG_GRP *DbgPrevPtr; OS_FLAG_GRP *DbgNextPtr; CPU_CHAR *DbgNamePtr; #endif OS_FLAGS Flags; CPU_TS TS;&#125;; 函数名 作用 OSFlagCreate() 创建事件标志组 OSFlagDel() 删除事件标志组 OSFlagPend() 等待事件标志组 OSFlagPendAbort() 取消等待事件标志 OSFlagPendGetFlagsRdy() 获取使任务就绪的事件标志 OSFlagPost() 向事件标志组发布标志 前面我们讲过都是等待单个内核对象，包括：信号量、互斥信号量、消息队列和事件标志组。在UCOSIII中允许任务同时等待多个信号量和多个消息队列，也就是说，UCOSIII不支持同时等待多个事件标志组或互斥信号量。 一个任务可以等待任意数量的信号量和消息队列，第一个信号量或消息队列的发布会导致该任务进入就绪态。 123456789101112131415161718// 一个任务可以调用函数OSPendMulti()函数来等待多个对象，并且可以根据需要指定一个等待超时值OS_OBJ_QTY OSPendMulti (OS_PEND_DATA *p_pend_data_tbl, OS_OBJ_QTY tbl_size, OS_TICK timeout, OS_OPT opt, OS_ERR *p_err)// 在调用函数OSPendMulti()之前我们需要先初始化OS_PEND_DATA数组，数组的大小取决于任务同时等待的内核对象的总数量// 定义内核对象OS_SEM Test_Sem1; //信号量1OS_SEM Test_Sem2; //信号量2OS_Q Test_Q; //消息队列// 初始化OS_PEND_DATA数组OS_PEND_DATA pend_multi_tbl[CORE_OBJ_NUM]; //定义数组 pend_multi_tbl[0].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem1;pend_multi_tbl[1].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Sem2;pend_multi_tbl[2].PendObjPtr=(OS_PEND_OBJ*)&amp;Test_Q; 存储管理 作为一个RTOS操作系统，内存管理是必备的功能，因此UCOSIII也就内存管理能力。通常应用程序可以调用ANSIC编译器的malloc()和free()函数来动态的分配和释放内存，但是在嵌入式事实操作系统中最好不要这么做，多次这样的操作会把原来很大的一块连续存储区域逐渐地分割成许多非常小并且彼此不相邻的存储区域，这就是存储碎片。 UCOSIII中提供了一种替代malloc()和free()函数的方法，UCOSIII中将存储空间分成区和块，每个存储区有数量不等大小相同的存储块，在一个系统中可以有多个存储区。 一般存储区是固定的，在程序中可以用数组来表示一个存储区，比如u8 buffer[20]10]，就表示一个拥有20个存储块，每个存储块10个字节的存储区。 1234567891011121314// UCOSIII中用存储控制块来表示存储区，存储控制块为OS_MEMstruct os_mem &#123; OS_OBJ_TYPE Type; void *AddrPtr; CPU_CHAR *NamePtr; void *FreeListPtr; OS_MEM_SIZE BlkSize; OS_MEM_QTY NbrMax; OS_MEM_QTY NbrFree; #if OS_CFG_DBG_EN &gt; 0u OS_MEM *DbgPrevPtr; OS_MEM *DbgNextPtr; #endif&#125;; OSMemCreate() 创建一个存储分区 OSMemGet() 从存储分区中获得一个存储块 OSMemPut() 将一个存储块归还到存储分区中","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"UCOS3","slug":"UCOS3","permalink":"http://1nameccc.github.io/tags/UCOS3/"}],"author":"coucou"},{"title":"操作系统——imx6ull","slug":"2-7-操作系统-imx6ull/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:57:27.751Z","comments":true,"path":"2023/08/01/2-7-操作系统-imx6ull/index/","permalink":"http://1nameccc.github.io/2023/08/01/2-7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-imx6ull/index/","excerpt":"Linux学习（基于正点原子I.MX6U）","text":"Linux学习（基于正点原子I.MX6U） 常用linux命令12345678910lsmodrmmoddepmod # 一次加载驱动的时候需要运行此命令modprobe led.ko # 加载驱动mknod /dev/led c 200 0 #创建节点、rmmod led.ko # 卸载驱动ls /dev/newchrled -l # 查看设备cd proc/device-tree #查看设备树节点信息cd /sys/bus/platform/drivers/ # 查看platform节点 系统启动方式 I.MX6U 支持多种启动方式以及启动设备，比如可以从 SD&#x2F;EMMC、NAND Flash、QSPI Flash 等启动。 用户可以根据实际情况，选择合适的启动设备。不同的启动方式其启动方式和启动要求也不一样，比如上一章中的从 SD 卡启动就需要在 bin 文件前面添加一个数据头，其它的启 动设备也是需要这个数据头的。 启动 1 2 3 4 5 6 7 8 启动设备 0 1 x x x x x x 串行下载，可以通过 USB 烧写镜像文件 1 0 0 0 0 0 1 0 SD 卡启动 1 0 1 0 0 1 1 0 EMMC 启动 1 0 0 0 1 0 0 1 NAND FLASH 启动 123setenv bootcmd &#x27;fatload mmc 1:1 80800000 zImage;fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb;bootz 80800000 - 83000000;&#x27;setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27; Linux系统uboot123451、将 imxdownload 软件拷贝到 uboot 源码根目录下，然后使用 imxdownload 软件将 u-boot.bin烧写到 SD 卡中，烧写命令如下： chmod 777 imxdownload //给予 imxdownload 可执行权限 ./imxdownload u-boot.bin /dev/sdd //烧写到 SD 卡中，不能烧写到/dev/sda 或 sda1 里面2、烧写完成以后将 SD 卡插入 I.MX6U-ALPHA 开发板的 TF 卡槽中，最后设置开发板从 SD卡启动。 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354bdinfo # 查看板子信息printenv # 输出环境变量version # 版本# 环境变量操作setenv bootdelay 5 # 设置环境变量saveenv # 保存setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;saveenv# 内存操作命令md # 显示内存值nm # 修改指定地址的内存值mm # 修改指定地址内存值mw # 使用一个指定的数据填充一段内存cp # 将 DRAM 中的数据从一段内存拷贝到另一段内存中cmp # 比较两段内存的数据是否相等# 网络操作命令ping 192.168.1.253setenv ipaddr 192.168.1.50 # 开发板 ip 地址setenv ethaddr b8:ae:1d:01:00:00 # mac地址setenv gatewayip 192.168.1.1setenv netmask 255.255.255.0setenv serverip 192.168.1.253 # 服务器 IP 地址saveenvdhcp # 从路由器获取 IP 地址nfs 80800000 192.168.1.253:/home/zuozhongkai/linux/nfs/zImage # 将 zImage 下载到开发板 DRAM 的 0X80800000 地址处# EMMC 和 SD 卡操作命令mmc info 输出 MMC 设备信息mmc read 读取 MMC 中的数据……# NAND 操作命令nand info 命令……# BOOT 操作命令tftp 80800000 zImagetftp 83000000 imx6ull-alientek-emmc.dtbbootz 80800000 - 83000000 # 启动 zImage 镜像文件setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb;&#x27;bootz 80800000 - 83000000setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.2.30:/home/coucou/nfs/rootfs,proto=tcp rw ip=192.168.2.10:192.168.2.30:192.168.2.1:255.255.255.0::eth0:off&#x27;saveenvboot # 来启动 Linux 系统# 其他常用命令reset # 重启go # 跳到指定的地址处执行应用run # 用于运行环境变量中定义的命令 ZImage和设备树1使用tftp服务器挂载测试 rootfs根文件系统1编译busybox 烧写系统到emmc1使用MfgTool工具 linux驱动开发点灯 地址映射 物理内存和虚拟内存映射 **ioremap()**映射函数 和 **ioremap()**取消映射函数 API123456789101112131415161718192021222324252627282930313233343536373839// 将用户空间的数据复制到 writebuf 内核空间中copy_from_user();// 申请设备号int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)// 注册设备号int register_chrdev_region(dev_t from, unsigned count, const char *name)// 释放设备号void unregister_chrdev_region(dev_t from, unsigned count) // cdev 结构体表示一个字符设备struct cdev &#123; struct kobject kobj; struct module *owner; const struct file_operations *ops; // 文件操作 struct list_head list; dev_t dev; // 设备号 unsigned int count;&#125;;// cdev初始化和添加设备void cdev_init(struct cdev *cdev, const struct file_operations *fops)int cdev_add(struct cdev *p, dev_t dev, unsigned count)void cdev_del(struct cdev *p) // 删除设备 // 自动创建节点struct class *class_create (struct module *owner, const char *name) // 创建类void class_destroy(struct class *cls); // 删除类struct device *device_create( // 创建设备 struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)void device_destroy(struct class *class, dev_t devt) // 删除设备// 加载驱动和卸载驱动module_init();module_exit(); 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#include &lt;linux/types.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/ide.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/mach/map.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;/***************************************************************Copyright © ALIENTEK Co., Ltd. 1998-2029. All rights reserved.文件名 : newchrled.c作者 : 左忠凯版本 : V1.0描述 : LED驱动文件。其他 : 无论坛 : www.openedv.com日志 : 初版V1.0 2019/6/27 左忠凯创建***************************************************************/#define NEWCHRLED_CNT 1 /* 设备号个数 */#define NEWCHRLED_NAME &quot;newchrled&quot; /* 名字 */#define LEDOFF 0 /* 关灯 */#define LEDON 1 /* 开灯 */ /* 寄存器物理地址 */#define CCM_CCGR1_BASE (0X020C406C) #define SW_MUX_GPIO1_IO03_BASE (0X020E0068)#define SW_PAD_GPIO1_IO03_BASE (0X020E02F4)#define GPIO1_DR_BASE (0X0209C000)#define GPIO1_GDIR_BASE (0X0209C004)/* 映射后的寄存器虚拟地址指针 */static void __iomem *IMX6U_CCM_CCGR1;static void __iomem *SW_MUX_GPIO1_IO03;static void __iomem *SW_PAD_GPIO1_IO03;static void __iomem *GPIO1_DR;static void __iomem *GPIO1_GDIR;/* newchrled设备结构体 */struct newchrled_dev&#123; dev_t devid; /* 设备号 */ struct cdev cdev; /* cdev */ struct class *class; /* 类 */ struct device *device; /* 设备 */ int major; /* 主设备号 */ int minor; /* 次设备号 */&#125;;struct newchrled_dev newchrled; /* led设备 *//* * @description : LED打开/关闭 * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED * @return : 无 */void led_switch(u8 sta)&#123; u32 val = 0; if(sta == LEDON) &#123; val = readl(GPIO1_DR); val &amp;= ~(1 &lt;&lt; 3); writel(val, GPIO1_DR); &#125;else if(sta == LEDOFF) &#123; val = readl(GPIO1_DR); val|= (1 &lt;&lt; 3); writel(val, GPIO1_DR); &#125; &#125;/* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 */static int led_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = &amp;newchrled; /* 设置私有数据 */ return 0;&#125;/* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 */static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)&#123; return 0;&#125;/* * @description : 向设备写数据 * @param - filp : 设备文件，表示打开的文件描述符 * @param - buf : 要写给设备写入的数据 * @param - cnt : 要写入的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 写入的字节数，如果为负值，表示写入失败 */static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)&#123; int retvalue; unsigned char databuf[1]; unsigned char ledstat; retvalue = copy_from_user(databuf, buf, cnt); if(retvalue &lt; 0) &#123; printk(&quot;kernel write failed!\\r\\n&quot;); return -EFAULT; &#125; ledstat = databuf[0]; /* 获取状态值 */ if(ledstat == LEDON) &#123; led_switch(LEDON); /* 打开LED灯 */ &#125; else if(ledstat == LEDOFF) &#123; led_switch(LEDOFF); /* 关闭LED灯 */ &#125; return 0;&#125;/* * @description : 关闭/释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 */static int led_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;/* 设备操作函数 */static struct file_operations newchrled_fops = &#123; .owner = THIS_MODULE, .open = led_open, .read = led_read, .write = led_write, .release = led_release,&#125;;/* * @description : 驱动出口函数 * @param : 无 * @return : 无 */static int __init led_init(void)&#123; u32 val = 0; /* 初始化LED */ /* 1、寄存器地址映射 */ IMX6U_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, 4); SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, 4); SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, 4); GPIO1_DR = ioremap(GPIO1_DR_BASE, 4); GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, 4); /* 2、使能GPIO1时钟 */ val = readl(IMX6U_CCM_CCGR1); val &amp;= ~(3 &lt;&lt; 26); /* 清楚以前的设置 */ val |= (3 &lt;&lt; 26); /* 设置新值 */ writel(val, IMX6U_CCM_CCGR1); /* 3、设置GPIO1_IO03的复用功能，将其复用为 * GPIO1_IO03，最后设置IO属性。 */ writel(5, SW_MUX_GPIO1_IO03); /*寄存器SW_PAD_GPIO1_IO03设置IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认下拉 *bit [13]: 0 kepper功能 *bit [12]: 1 pull/keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 R0/6驱动能力 *bit [0]: 0 低转换率 */ writel(0x10B0, SW_PAD_GPIO1_IO03); /* 4、设置GPIO1_IO03为输出功能 */ val = readl(GPIO1_GDIR); val &amp;= ~(1 &lt;&lt; 3); /* 清除以前的设置 */ val |= (1 &lt;&lt; 3); /* 设置为输出 */ writel(val, GPIO1_GDIR); /* 5、默认关闭LED */ val = readl(GPIO1_DR); val |= (1 &lt;&lt; 3); writel(val, GPIO1_DR); /* 注册字符设备驱动 */ /* 1、创建设备号 */ if (newchrled.major) &#123; /* 定义了设备号 */ newchrled.devid = MKDEV(newchrled.major, 0); register_chrdev_region(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME); &#125; else &#123; /* 没有定义设备号 */ alloc_chrdev_region(&amp;newchrled.devid, 0, NEWCHRLED_CNT, NEWCHRLED_NAME); /* 申请设备号 */ newchrled.major = MAJOR(newchrled.devid); /* 获取分配号的主设备号 */ newchrled.minor = MINOR(newchrled.devid); /* 获取分配号的次设备号 */ &#125; printk(&quot;newcheled major=%d,minor=%d\\r\\n&quot;,newchrled.major, newchrled.minor); /* 2、初始化cdev */ newchrled.cdev.owner = THIS_MODULE; cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops); /* 3、添加一个cdev */ cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT); /* 4、创建类 */ newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME); if (IS_ERR(newchrled.class)) &#123; return PTR_ERR(newchrled.class); &#125; /* 5、创建设备 */ newchrled.device = device_create(newchrled.class, NULL, newchrled.devid, NULL, NEWCHRLED_NAME); if (IS_ERR(newchrled.device)) &#123; return PTR_ERR(newchrled.device); &#125; return 0;&#125;/* * @description : 驱动出口函数 * @param : 无 * @return : 无 */static void __exit led_exit(void)&#123; /* 取消映射 */ iounmap(IMX6U_CCM_CCGR1); iounmap(SW_MUX_GPIO1_IO03); iounmap(SW_PAD_GPIO1_IO03); iounmap(GPIO1_DR); iounmap(GPIO1_GDIR); /* 注销字符设备驱动 */ cdev_del(&amp;newchrled.cdev);/* 删除cdev */ unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT); /* 注销设备号 */ device_destroy(newchrled.class, newchrled.devid); class_destroy(newchrled.class);&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;zuozhongkai&quot;); 设备树点灯 路径 ： &#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts 设备树节点命名 node-name@unit-address ​ “unit-address”一般表示设备的地址或寄存器首地址 节点属性 compatible 属性：“兼容性”属性，用于将设备和驱动绑定起来 model 属性：描述设备模块信息 status 属性：设备状态 #address-cells 和 #size-cells 属性：表明子节点应该如何编写 reg 属性值 reg 属性：用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息 ranges 属性：ranges 是一个地址映射&#x2F;转换表，ranges 属性每个项目由子地址、父地址和地址空间长度组成 name 属性：用于记录节点名字 device_type 属性：用于描述设备的 FCode 节点内容追加 &amp;i2c1{ ​ &#x2F;* 要追加或修改的内容 *&#x2F; }; &#x2F;&#x2F; 在I2C节点下追加内容 单独编译设备树：make dtbs API12345678910111213141516171819202122232425262728// 通过节点名字查找指定的节点struct device_node *of_find_node_by_name(struct device_node *from, const char *name);// 通过 device_type 属性查找指定的节点struct device_node *of_find_node_by_type(struct device_node *from, const char *type)// device_type 和 compatible 这两个属性查找指定的节点struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compatible)// 通过 of_device_id 匹配表来查找指定的节点struct device_node *of_find_matching_node_and_match( struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match)// 通过路径来查找指定的节点inline struct device_node *of_find_node_by_path(const char *path)// 获取指定节点的父节点struct device_node *of_get_parent(const struct device_node *node)// 查找子节点struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev) // 查找指定的属性property *of_find_property(const struct device_node *np, const char *name, int *lenp)// 获取属性中元素的数量int of_property_count_elems_of_size(const struct device_node *np,const char *propname,int elem_size)// 读取整形值的属性int of_property_read_u32(const struct device_node *np, const char *propname, u32 *out_value)// 读取属性中字符串值int of_property_read_string(struct device_node *np, const char *propname, const char **out_string) 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320// 再该文件 imx6ull-alientek-emmc.dts 下添加alphaled &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; compatible = &quot;atkalpha-led&quot;; status = &quot;okay&quot;; reg = &lt; 0X020C406C 0X04 /* CCM_CCGR1_BAE */ 0X020E0068 0X04 /* SW_MUX_GPIO1_IO03_BASE */ 0X020E02F4 0X04 /* SW_PAD_GPIO1_IO03_BASE */ 0X0209C000 0X04 /* GPIO1_DR_BASE */ 0X0209C004 0X04&gt;; /* GPIO1_GDIR_BASE */ &#125;;// 驱动代码#include &lt;linux/types.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/ide.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_address.h&gt;#include &lt;asm/mach/map.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;/***************************************************************Copyright © ALIENTEK Co., Ltd. 1998-2029. All rights reserved.文件名 : dtsled.c作者 : 左忠凯版本 : V1.0描述 : LED驱动文件。其他 : 无论坛 : www.openedv.com日志 : 初版V1.0 2019/7/9 左忠凯创建***************************************************************/#define DTSLED_CNT 1 /* 设备号个数 */#define DTSLED_NAME &quot;dtsled&quot; /* 名字 */#define LEDOFF 0 /* 关灯 */#define LEDON 1 /* 开灯 *//* 映射后的寄存器虚拟地址指针 */static void __iomem *IMX6U_CCM_CCGR1;static void __iomem *SW_MUX_GPIO1_IO03;static void __iomem *SW_PAD_GPIO1_IO03;static void __iomem *GPIO1_DR;static void __iomem *GPIO1_GDIR;/* dtsled设备结构体 */struct dtsled_dev&#123; dev_t devid; /* 设备号 */ struct cdev cdev; /* cdev */ struct class *class; /* 类 */ struct device *device; /* 设备 */ int major; /* 主设备号 */ int minor; /* 次设备号 */ struct device_node *nd; /* 设备节点 */&#125;;struct dtsled_dev dtsled; /* led设备 *//* * @description : LED打开/关闭 * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED * @return : 无 */void led_switch(u8 sta)&#123; u32 val = 0; if(sta == LEDON) &#123; val = readl(GPIO1_DR); val &amp;= ~(1 &lt;&lt; 3); writel(val, GPIO1_DR); &#125;else if(sta == LEDOFF) &#123; val = readl(GPIO1_DR); val|= (1 &lt;&lt; 3); writel(val, GPIO1_DR); &#125; &#125;/* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 */static int led_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = &amp;dtsled; /* 设置私有数据 */ return 0;&#125;/* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 */static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)&#123; return 0;&#125;/* * @description : 向设备写数据 * @param - filp : 设备文件，表示打开的文件描述符 * @param - buf : 要写给设备写入的数据 * @param - cnt : 要写入的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 写入的字节数，如果为负值，表示写入失败 */static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)&#123; int retvalue; unsigned char databuf[1]; unsigned char ledstat; retvalue = copy_from_user(databuf, buf, cnt); if(retvalue &lt; 0) &#123; printk(&quot;kernel write failed!\\r\\n&quot;); return -EFAULT; &#125; ledstat = databuf[0]; /* 获取状态值 */ if(ledstat == LEDON) &#123; led_switch(LEDON); /* 打开LED灯 */ &#125; else if(ledstat == LEDOFF) &#123; led_switch(LEDOFF); /* 关闭LED灯 */ &#125; return 0;&#125;/* * @description : 关闭/释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 */static int led_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;/* 设备操作函数 */static struct file_operations dtsled_fops = &#123; .owner = THIS_MODULE, .open = led_open, .read = led_read, .write = led_write, .release = led_release,&#125;;/* * @description : 驱动出口函数 * @param : 无 * @return : 无 */static int __init led_init(void)&#123; u32 val = 0; int ret; u32 regdata[14]; const char *str; struct property *proper; /* 获取设备树中的属性数据 */ /* 1、获取设备节点：alphaled */ dtsled.nd = of_find_node_by_path(&quot;/alphaled&quot;); if(dtsled.nd == NULL) &#123; printk(&quot;alphaled node nost find!\\r\\n&quot;); return -EINVAL; &#125; else &#123; printk(&quot;alphaled node find!\\r\\n&quot;); &#125; /* 2、获取compatible属性内容 */ proper = of_find_property(dtsled.nd, &quot;compatible&quot;, NULL); if(proper == NULL) &#123; printk(&quot;compatible property find failed\\r\\n&quot;); &#125; else &#123; printk(&quot;compatible = %s\\r\\n&quot;, (char*)proper-&gt;value); &#125; /* 3、获取status属性内容 */ ret = of_property_read_string(dtsled.nd, &quot;status&quot;, &amp;str); if(ret &lt; 0)&#123; printk(&quot;status read failed!\\r\\n&quot;); &#125; else &#123; printk(&quot;status = %s\\r\\n&quot;,str); &#125; /* 4、获取reg属性内容 */ ret = of_property_read_u32_array(dtsled.nd, &quot;reg&quot;, regdata, 10); if(ret &lt; 0) &#123; printk(&quot;reg property read failed!\\r\\n&quot;); &#125; else &#123; u8 i = 0; printk(&quot;reg data:\\r\\n&quot;); for(i = 0; i &lt; 10; i++) printk(&quot;%#X &quot;, regdata[i]); printk(&quot;\\r\\n&quot;); &#125; /* 初始化LED */#if 0 /* 1、寄存器地址映射 */ IMX6U_CCM_CCGR1 = ioremap(regdata[0], regdata[1]); SW_MUX_GPIO1_IO03 = ioremap(regdata[2], regdata[3]); SW_PAD_GPIO1_IO03 = ioremap(regdata[4], regdata[5]); GPIO1_DR = ioremap(regdata[6], regdata[7]); GPIO1_GDIR = ioremap(regdata[8], regdata[9]);#else IMX6U_CCM_CCGR1 = of_iomap(dtsled.nd, 0); SW_MUX_GPIO1_IO03 = of_iomap(dtsled.nd, 1); SW_PAD_GPIO1_IO03 = of_iomap(dtsled.nd, 2); GPIO1_DR = of_iomap(dtsled.nd, 3); GPIO1_GDIR = of_iomap(dtsled.nd, 4);#endif /* 2、使能GPIO1时钟 */ val = readl(IMX6U_CCM_CCGR1); val &amp;= ~(3 &lt;&lt; 26); /* 清楚以前的设置 */ val |= (3 &lt;&lt; 26); /* 设置新值 */ writel(val, IMX6U_CCM_CCGR1); /* 3、设置GPIO1_IO03的复用功能，将其复用为 * GPIO1_IO03，最后设置IO属性。 */ writel(5, SW_MUX_GPIO1_IO03); /*寄存器SW_PAD_GPIO1_IO03设置IO属性 *bit 16:0 HYS关闭 *bit [15:14]: 00 默认下拉 *bit [13]: 0 kepper功能 *bit [12]: 1 pull/keeper使能 *bit [11]: 0 关闭开路输出 *bit [7:6]: 10 速度100Mhz *bit [5:3]: 110 R0/6驱动能力 *bit [0]: 0 低转换率 */ writel(0x10B0, SW_PAD_GPIO1_IO03); /* 4、设置GPIO1_IO03为输出功能 */ val = readl(GPIO1_GDIR); val &amp;= ~(1 &lt;&lt; 3); /* 清除以前的设置 */ val |= (1 &lt;&lt; 3); /* 设置为输出 */ writel(val, GPIO1_GDIR); /* 5、默认关闭LED */ val = readl(GPIO1_DR); val |= (1 &lt;&lt; 3); writel(val, GPIO1_DR); /* 注册字符设备驱动 */ /* 1、创建设备号 */ if (dtsled.major) &#123; /* 定义了设备号 */ dtsled.devid = MKDEV(dtsled.major, 0); register_chrdev_region(dtsled.devid, DTSLED_CNT, DTSLED_NAME); &#125; else &#123; /* 没有定义设备号 */ alloc_chrdev_region(&amp;dtsled.devid, 0, DTSLED_CNT, DTSLED_NAME); /* 申请设备号 */ dtsled.major = MAJOR(dtsled.devid); /* 获取分配号的主设备号 */ dtsled.minor = MINOR(dtsled.devid); /* 获取分配号的次设备号 */ &#125; printk(&quot;dtsled major=%d,minor=%d\\r\\n&quot;,dtsled.major, dtsled.minor); /* 2、初始化cdev */ dtsled.cdev.owner = THIS_MODULE; cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops); /* 3、添加一个cdev */ cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_CNT); /* 4、创建类 */ dtsled.class = class_create(THIS_MODULE, DTSLED_NAME); if (IS_ERR(dtsled.class)) &#123; return PTR_ERR(dtsled.class); &#125; /* 5、创建设备 */ dtsled.device = device_create(dtsled.class, NULL, dtsled.devid, NULL, DTSLED_NAME); if (IS_ERR(dtsled.device)) &#123; return PTR_ERR(dtsled.device); &#125; return 0;&#125;/* * @description : 驱动出口函数 * @param : 无 * @return : 无 */static void __exit led_exit(void)&#123; /* 取消映射 */ iounmap(IMX6U_CCM_CCGR1); iounmap(SW_MUX_GPIO1_IO03); iounmap(SW_PAD_GPIO1_IO03); iounmap(GPIO1_DR); iounmap(GPIO1_GDIR); /* 注销字符设备驱动 */ cdev_del(&amp;dtsled.cdev);/* 删除cdev */ unregister_chrdev_region(dtsled.devid, DTSLED_CNT); /* 注销设备号 */ device_destroy(dtsled.class, dtsled.devid); class_destroy(dtsled.class);&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;zuozhongkai&quot;); pinctl 和 gpio 控制点灯 使用须知！！ 检查 PIN 是否被其他外设使用 pinctrl 子系统 传统的配置 pin 的方式就是直接操作相应的寄存器，但是这种配置 方式比较繁琐、而且容易出问题(比如 pin 功能冲突)。pinctrl 子系统就是为了解决这个问题而引 入的，pinctrl 子系统主要工作内容如下： ①、获取设备树中 pin 信息。 ②、根据获取到的 pin 信息来设置 pin 的复用功能 ③、根据获取到的 pin 信息来设置 pin 的电气特性，比如上&#x2F;下拉、速度、驱动能力等。 gpio 子系统 gpio 子系统顾名思义，就是用于初始化 GPIO 并且提供相应的 API 函数，比如设置 GPIO 为输入输出，读取 GPIO 的值等 API123456789101112131415161718192021222324252627282930/* 打开 imx6ull-alientek-emmc.dts，在 iomuxc 节点中的“imx6ul-evk”子节点下添加“pinctrl_test”节点 MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 是设置这个 PIN 的复用功能 config 是设置一个 IO 的上/下拉、驱动能力和速度等*/pinctrl_test: testgrp &#123; fsl,pins = &lt; MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 config &gt;; int gpio_request(unsigned gpio, const char *label) // 申请一个 GPIO 管脚void gpio_free(unsigned gpio) // 释放int gpio_direction_input(unsigned gpio) // 设置某个 GPIO 为输入int gpio_direction_output(unsigned gpio, int value) // 设置某个 GPIO 为输出int __gpio_get_value(unsigned gpio) // 获取某个 GPIO 的值(0 或 1)void __gpio_set_value(unsigned gpio, int value) // 设置某个 GPIO 的值 /* 在根节点“/”下创建 test 设备子节点*/test &#123; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_test&gt;; gpio = &lt;&amp;gpio1 0 GPIO_ACTIVE_LOW&gt;;&#125;// 获取 GPIO 编号int of_get_named_gpio(struct device_node *np, const char *propname, int index)// 获取设备树某个属性里面定义了几个 GPIO 信息int of_gpio_named_count(struct device_node *np, const char *propname) 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224// 创建 GPIO1_IO03 pinctrl 节点pinctrl_led: ledgrp &#123; fsl,pins = &lt; MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 0x10B0 /* LED0 */ &gt;;&#125;;// 添加 LED 设备节点gpioled &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; compatible = &quot;atkalpha-gpioled&quot;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_led&gt;; led-gpio = &lt;&amp;gpio1 3 GPIO_ACTIVE_LOW&gt;; status = &quot;okay&quot;;&#125;;// 驱动程序#include &lt;linux/types.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/ide.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_address.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;asm/mach/map.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/io.h&gt;/***************************************************************Copyright © ALIENTEK Co., Ltd. 1998-2029. All rights reserved.文件名 : gpioled.c作者 : 左忠凯版本 : V1.0描述 : 采用pinctrl和gpio子系统驱动LED灯。其他 : 无论坛 : www.openedv.com日志 : 初版V1.0 2019/7/13 左忠凯创建***************************************************************/#define GPIOLED_CNT 1 /* 设备号个数 */#define GPIOLED_NAME &quot;gpioled&quot; /* 名字 */#define LEDOFF 0 /* 关灯 */#define LEDON 1 /* 开灯 *//* gpioled设备结构体 */struct gpioled_dev&#123; dev_t devid; /* 设备号 */ struct cdev cdev; /* cdev */ struct class *class; /* 类 */ struct device *device; /* 设备 */ int major; /* 主设备号 */ int minor; /* 次设备号 */ struct device_node *nd; /* 设备节点 */ int led_gpio; /* led所使用的GPIO编号 */&#125;;struct gpioled_dev gpioled; /* led设备 *//* * @description : 打开设备 * @param - inode : 传递给驱动的inode * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量 * 一般在open的时候将private_data指向设备结构体。 * @return : 0 成功;其他 失败 */static int led_open(struct inode *inode, struct file *filp)&#123; filp-&gt;private_data = &amp;gpioled; /* 设置私有数据 */ return 0;&#125;/* * @description : 从设备读取数据 * @param - filp : 要打开的设备文件(文件描述符) * @param - buf : 返回给用户空间的数据缓冲区 * @param - cnt : 要读取的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 读取的字节数，如果为负值，表示读取失败 */static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)&#123; return 0;&#125;/* * @description : 向设备写数据 * @param - filp : 设备文件，表示打开的文件描述符 * @param - buf : 要写给设备写入的数据 * @param - cnt : 要写入的数据长度 * @param - offt : 相对于文件首地址的偏移 * @return : 写入的字节数，如果为负值，表示写入失败 */static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)&#123; int retvalue; unsigned char databuf[1]; unsigned char ledstat; struct gpioled_dev *dev = filp-&gt;private_data; retvalue = copy_from_user(databuf, buf, cnt); if(retvalue &lt; 0) &#123; printk(&quot;kernel write failed!\\r\\n&quot;); return -EFAULT; &#125; ledstat = databuf[0]; /* 获取状态值 */ if(ledstat == LEDON) &#123; gpio_set_value(dev-&gt;led_gpio, 0); /* 打开LED灯 */ &#125; else if(ledstat == LEDOFF) &#123; gpio_set_value(dev-&gt;led_gpio, 1); /* 关闭LED灯 */ &#125; return 0;&#125;/* * @description : 关闭/释放设备 * @param - filp : 要关闭的设备文件(文件描述符) * @return : 0 成功;其他 失败 */static int led_release(struct inode *inode, struct file *filp)&#123; return 0;&#125;/* 设备操作函数 */static struct file_operations gpioled_fops = &#123; .owner = THIS_MODULE, .open = led_open, .read = led_read, .write = led_write, .release = led_release,&#125;;/* * @description : 驱动出口函数 * @param : 无 * @return : 无 */static int __init led_init(void)&#123; int ret = 0; /* 设置LED所使用的GPIO */ /* 1、获取设备节点：gpioled */ gpioled.nd = of_find_node_by_path(&quot;/gpioled&quot;); if(gpioled.nd == NULL) &#123; printk(&quot;gpioled node not find!\\r\\n&quot;); return -EINVAL; &#125; else &#123; printk(&quot;gpioled node find!\\r\\n&quot;); &#125; /* 2、 获取设备树中的gpio属性，得到LED所使用的LED编号 */ gpioled.led_gpio = of_get_named_gpio(gpioled.nd, &quot;led-gpio&quot;, 0); if(gpioled.led_gpio &lt; 0) &#123; printk(&quot;can&#x27;t get led-gpio&quot;); return -EINVAL; &#125; printk(&quot;led-gpio num = %d\\r\\n&quot;, gpioled.led_gpio); /* 3、设置GPIO1_IO03为输出，并且输出高电平，默认关闭LED灯 */ ret = gpio_direction_output(gpioled.led_gpio, 1); if(ret &lt; 0) &#123; printk(&quot;can&#x27;t set gpio!\\r\\n&quot;); &#125; /* 注册字符设备驱动 */ /* 1、创建设备号 */ if (gpioled.major) &#123; /* 定义了设备号 */ gpioled.devid = MKDEV(gpioled.major, 0); register_chrdev_region(gpioled.devid, GPIOLED_CNT, GPIOLED_NAME); &#125; else &#123; /* 没有定义设备号 */ alloc_chrdev_region(&amp;gpioled.devid, 0, GPIOLED_CNT, GPIOLED_NAME); /* 申请设备号 */ gpioled.major = MAJOR(gpioled.devid); /* 获取分配号的主设备号 */ gpioled.minor = MINOR(gpioled.devid); /* 获取分配号的次设备号 */ &#125; printk(&quot;gpioled major=%d,minor=%d\\r\\n&quot;,gpioled.major, gpioled.minor); /* 2、初始化cdev */ gpioled.cdev.owner = THIS_MODULE; cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops); /* 3、添加一个cdev */ cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_CNT); /* 4、创建类 */ gpioled.class = class_create(THIS_MODULE, GPIOLED_NAME); if (IS_ERR(gpioled.class)) &#123; return PTR_ERR(gpioled.class); &#125; /* 5、创建设备 */ gpioled.device = device_create(gpioled.class, NULL, gpioled.devid, NULL, GPIOLED_NAME); if (IS_ERR(gpioled.device)) &#123; return PTR_ERR(gpioled.device); &#125; return 0;&#125;/* * @description : 驱动出口函数 * @param : 无 * @return : 无 */static void __exit led_exit(void)&#123; /* 注销字符设备驱动 */ cdev_del(&amp;gpioled.cdev);/* 删除cdev */ unregister_chrdev_region(gpioled.devid, GPIOLED_CNT); /* 注销设备号 */ device_destroy(gpioled.class, gpioled.devid); class_destroy(gpioled.class);&#125;module_init(led_init);module_exit(led_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;zuozhongkai&quot;); platform设备驱动框架 驱动的分离与分层 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// platform 驱动框架/* 设备结构体 */struct xxx_dev&#123; struct cdev cdev; /* 设备结构体其他具体内容 */&#125;;struct xxx_dev xxxdev; /* 定义个设备结构体变量 */static int xxx_open(struct inode *inode, struct file *filp)&#123; /* 函数具体内容 */ return 0; &#125; static ssize_t xxx_write(struct file *filp, const char __user *buf,size_t cnt, loff_t *offt) &#123; /* 函数具体内容 */ return 0; &#125;static struct file_operations xxx_fops = &#123; .owner = THIS_MODULE, .open = xxx_open, .write = xxx_write, &#125;; /* * platform 驱动的 probe 函数 * 驱动与设备匹配成功以后此函数就会执行 */ static int xxx_probe(struct platform_device *dev) &#123; ...... cdev_init(&amp;xxxdev.cdev, &amp;xxx_fops); /* 注册字符设备驱动 */ /* 函数具体内容 */ return 0; &#125; static int xxx_remove(struct platform_device *dev) &#123; ...... cdev_del(&amp;xxxdev.cdev);/* 删除 cdev */ /* 函数具体内容 */ return 0; &#125; /* 匹配列表 */ static const struct of_device_id xxx_of_match[] = &#123; &#123; .compatible = &quot;xxx-gpio&quot; &#125;, &#123; /* Sentinel */ &#125; &#125;; /* * platform 平台驱动结构体 */ static struct platform_driver xxx_driver = &#123; .driver = &#123; .name = &quot;xxx&quot;, .of_match_table = xxx_of_match, &#125;, .probe = xxx_probe, .remove = xxx_remove, &#125;; /* 驱动模块加载 */ static int __init xxxdriver_init(void) &#123; return platform_driver_register(&amp;xxx_driver); &#125; /* 驱动模块卸载 */ static void __exit xxxdriver_exit(void) &#123; platform_driver_unregister(&amp;xxx_driver); &#125; 驱动测试1234567// led测试depmodmodporobe gpioled.ko./ledApp /deb/gpioled 1rmmod gpioled.ko linux应用开发","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"imx6ull","slug":"imx6ull","permalink":"http://1nameccc.github.io/tags/imx6ull/"}],"author":"coucou"},{"title":"单片机——杂项","slug":"3-0-单片机-杂项/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:57:35.407Z","comments":true,"path":"2023/08/01/3-0-单片机-杂项/index/","permalink":"http://1nameccc.github.io/2023/08/01/3-0-%E5%8D%95%E7%89%87%E6%9C%BA-%E6%9D%82%E9%A1%B9/index/","excerpt":"单片机","text":"单片机 51单片机的延时计算前言正文首先是时钟周期的算法：时钟周期（T）&#x3D;1（秒）&#x2F;晶振频率。其次是机器周期：机器周期是由时钟周期组成的，机器周期是单片机完成一个基本操作所需要的时间。1 传统的8051单片机：2 STC单片机：最后是指令周期：这个是单片机执行一条指令所需要的时间，它是由机器周期组成的。总结前言我使用51,STC这一类的单片机做控制好几年，一直是使用现成的程序，在其上修修改改，以达到需求动作目的即可。从来都是不求甚解。想法既是如此，会用即可，了解那么多做什么。此次又在做一项目，里面用到I2C通讯。本来是直接复制粘贴了事，却没想对里面的一个小小的延时函数起了兴趣，由于本人是基础功底只有5战斗力的渣渣，写写画画了一天才搞了个大体明白。以前总是在看其他博主的文章，默默潜水。然而此次，突然就忍不住想写篇文章发表一下费尽心思的微不足道的心得体会。 正文void Delay10us() &#x2F;&#x2F;@12.000MHz{ unsigned char i; _nop_(); _nop_(); i: 27; while (--i); }上面这段代码是用STC-ISP软件中的软件延时计算器给出的，选用的是8051指令集STC-Y5，延时10us。以前都是直接这么拿来用的，今天却突然想搞个明白，为什么代码要这么写。 于是查了各方资料。从单片机计时的源头找起，它由下面几部分依次组成。 首先是时钟周期的算法：时钟周期（T）&#x3D;1（秒）&#x2F;晶振频率。（比如：上面代码的时钟周期为1&#x2F;12M（秒））。这是单片机的基本时间单位。是由晶振震荡出来的，也叫震荡周期。 其次是机器周期：机器周期是由时钟周期组成的，机器周期是单片机完成一个基本操作所需要的时间。关于机器周期，每种单片机可能都不太一样，我也只用过传统51和STC这两款，就拿此来对比下 1 传统的8051单片机：它的1个机器周期是由12个时钟周期组成的。以12M晶振举例，它的一个机器周期就是：12（个时钟周期）*1（秒）&#x2F;12MHz &#x3D; 1（us) 2 STC单片机：拿我常用的STC12C5A60S2这款单片机来讲，它可以有两个模式选择，一个是1T模式，在这个模式下STC单片机1个时钟周期就是1个机器周期；另一个是12T模式，这个模式下STC单片就和传统的8051单片机一样，12个时钟周期组成1个机器周期。由此可见1T模式的速度就是12T模式的12倍。以12M晶振为例，1T模式下就可以算得机器周期是：1（个时钟周期）*1（秒）&#x2F;12Mhz &#x3D; 1&#x2F;12(us) 最后是指令周期：这个是单片机执行一条指令所需要的时间，它是由机器周期组成的。现在可以回到正文开头的代码中了。这个10us的函数是怎么得出来的呢？这个我之前查过很多资料，比如执行while语句需要多少个机器周期。赋值需要多少个周期。也就是查这个占用了我很大一部分时间。直到最后将上面的延时函数直接调到main函数中debug调试，才明白，问题其实很简单啊。无论是执行什么语句，最终都会回到汇编上来，debug里单步调试，所有的指令周期就会明明白白了。我用main函数直接调用延时函数,如下： void Delay10us() &#x2F;&#x2F;@12.000MHz{ unsigned char i; _nop_(); _nop_(); i = 27; while (--i); }main{ Delay10us();} 我用的keil软件，将上述build之后，点击debug，开始调试 看图片上，开始debug，程序的起始就在C:0x0183 020171 LJMP Delay10us(C:0171)，这里有个长转移指令LJMP，它要转移到C:0171行去执行Delay10us这个函数。那执行LJMP这个指令需要多长时间呢，查找STC数据手册，在1T模式下，此条指令在单片机上运行需要4个时钟周期。接下来，按单步调试F11键，如下图： 程序成功转移到C:0171行，跳转到Delay10us函数中，此行程序执行NOP指令，空操作。查STC数据手册，NOP指令占用1个时钟周期。接下来C:0172行，依然是NOP指令，1个时钟周期。接下来C:0173行，此行执行 MOV R7,#0x1B，将立即数送入寄存器。是将27赋值给i。依然查手册，此条指令2个时钟周期。继续： 此时执行到while语句了，这里执行的指令时 DJNZ R7,C:0175，寄存器减1非0转移。此条指令执行1次4个时钟周期。上面已经将寄存器填入27了，因此这条指令将执行27次。继续： 循环了27次，终于到0了，程序继续向下执行，此行指令RET，子程序返回。此条指令4个时钟周期。继续： 程序又回到了起点。好了，可以计算一下此次延时的时间了。1个LJMP，4时钟；2个NOP，2时钟;1个MOV，2时钟；27个DJNZ，108时钟；1个RET，4时钟。4+2+2+108+4&#x3D;120。单片机的时钟周期是：1（S）&#x2F;12MHz &#x3D; 1&#x2F;12（us）此次延时的时间是：120 × 1&#x2F;12（us）&#x3D; 10（us） 1. 输入输出以及复用模式1.1 输入（1）输入上拉：默认输入高电平 （2）输入下拉：默认输入低电平 （3）浮空输入：不稳定 （4）模拟输入：如AD模拟信号 1.2输出（1）推挽输出：P-MOS和N-MOS均有效，高低电平均有较强驱动能力 （2）开漏输出：N-MOS有效，低电平有较强的驱动能力 ​ 补充：TTL 是斯密特触发器：防止信号不稳定 2. 初始化过程（1）使能IO口时钟 （2）初始化IO口模式 （3）操作IO 3. 通信 形式 IO口 方式 UART TXD，RXD 全双工，异步 I2C SCL，SDA 半双工，同步 SPI SCLK，MOSI，MISO，CS 全双工，同步 1-wire DQ 半双工，异步 （1）全双工：同一时刻可互传数据 （2）半双工：同一时刻不可互传数据 （3）同步：双方靠一根时钟线来约定通信速率 （4）异步：双方各自约定通信速率 4. 单片机使用printf() 使用之前，一定要将配置里的【use microlLIB】选项卡勾上！不然用不了！！ 12345678#include &quot;stdio.h&quot;int fputc(int ch, FILE *f)&#123; while((USART1-&gt;SR &amp; 0X40)==0);//循环发送,直到发送完毕 USART1-&gt;DR = (u8) ch; return ch;&#125; 5. PWM和占空比PWM，是脉冲宽度调制，是控制在一个周期内，控制高电平多长时间，低电平多长时间，在数字电路中IO口就只有两种状态，0和1(高低)，对应就是0和5V或者0和3.3V）。也就是说，通过调节高低电平时间的变化来调节信号、能量等的变化 占空比是指 高电平持续 时间 比 一个 周期持续 的时间。所以可以通过控制占空比，来控制输出的等效电压。所以对于方波的话，频率和占空比就确定了一个波 6. 输入捕获 输入捕获模式可以用来测量脉冲宽度或者测量频率，下图以测量脉宽为例来说明输入捕获的原理 假定定时器工作在向上计数模式，图中t1-t2的时间就是我们需要测量的低电平时间。测量方法为：首先设置定时器通道x为下降沿捕获，在t1时刻就会捕获到当前的CNT值，然后立即清零CNT，并设置通道x为上升沿捕获，到t2时刻又会发送捕获事件，得到此时的CNT值（记为CCRx2）。在t1-t2之间可能产生N次定时器溢出，因此需要对定时器溢出做处理，防止低电平太长导致数据不准确。 t1-t2之间计数的次数为：N * ARR + CCRx2，再乘以CNT计数周期即可得到低电平持续时间 7. 定时器时间计算7.1 单片机的定时原理通过每一个机器周期，就加一，通过数1的方式进行计时。 7.2 基本概念1.晶振：又称晶体振荡器，是数字电路“心脏”，是电子元件中不可或缺的频率元件，对于数字电路系统，晶振的好还直接影响系统的稳定性。 2.时钟周期：将晶振的频率的倒数定义为时钟周期，在一个时钟周期内，CPU完成一个基础动作，对于更小的时钟周期，意味着CPU有更好的性能，更高的工作效率。 3.机器周期：将时钟周期的6倍或者12倍定义为一个机器周期，具体的设定需要通过人为进行控制 7.3 每一次“加1”经过的时间是多少当晶振频率是11.0592MHz的时候，等于11059.2KHz &#x3D; 11059200Hz 机器周期 &#x3D; 12 x 时钟周期 &#x3D;12 x (1&#x2F;时钟频率) 秒 &#x3D; 12 &#x2F; 11059200 秒 &#x3D; 12 000 000 &#x2F; 11059200 微秒 &#x3D; 1.085 微秒 也就是说对于11.0592Mhz的晶振，其机器周期就是1.085微秒 7.4 实际案例案例：通过单片机设定一个10ms的定时器有如下的部分 符号 含义TL0(Timer Low0) 定时器0的低8位寄存器TH0(Timer HIgh0) 定时器0的高8位寄存器根据上表，可以知道共16位的寄存器可以数2^16次，就是65536次，而每次计数一下，就会耗费1.085微秒，因此当计数超过65535时，定时器寄存器就会爆表，也就是经过之后就会爆表，通常可以理解为经过71ms之后就会爆表。 对于10ms而要，首先可以计算出10ms定时定时器需要数多少次，设需要数x次，则 设定时器的初始值为y，则 将56320转化成16进制数，通过计算可以知道16#DC00，因此TH &#x3D; DC ;TL &#x3D; 00 也就是说需要计数9612次，就可以认为经过了10ms，这时，我们可以用71ms减去10ms的次数，就可以知道定时开始计数的初始值，这个值就是y值 7.5 小结单片机定时器的原理就是通过计算出所定时间需要计数的次数x，通过65536减去x，算出定时器所需的初始值，然后将初始值转化成16进制，填入TH与TL寄存器中，然后通过读取定时器溢出标志位，就可以知道定时器的定时状态。 8. stm32内存映射摘要：要想把STM32单片机学好，芯片的内部结构就要必须搞清楚。所谓基础不牢，地动山摇。今天带大家来看看STM32F429的Memory map。 STM32F429芯片系统结构 STM32F429采用的是Cortex-M4内核，内核即CPU，由ARM公司设计。ARM公司并不生产芯片，而是出售其芯片技术授权。芯片生产厂商(SOC)如ST、TI、Freescale，负责在内核之外设计部件并生产整个芯片，这些内核之外的部件被称为核外外设或片上外设。如GPIO、USART(串口)、I2C、SPI等都叫做片上外设。 从上图我们可以清楚的看到芯片和外设之间通过各种总线连接，其中主控总线有 8条，被控总线有7条。主控总线通过一个总线矩阵来连接被控总线，总线矩阵用于主控总线之间的访问仲裁管理，仲裁采用循环调度算法。比如数据从Cotex-M4到高速外设USB，数据交给在总线矩阵后，总线矩阵就会判给USB，然后通过USB所在的AHB1传输给USB。 三大总线指令总线、数据总线、系统总线 ICode 着重传输指令，DCode 和 System 着重传输数据，至于更详细的区分，不用关心。实际上 ICode、DCode 和 System 内部都包含三个部分，即地址总线、控制总线、数据总线。 高速总线直接挂接在总线矩阵上的有哪些呢？ ICode、DCode、System；FLASH连接总线；SRAM 连接总线；高速外设连接总线 AHB1&#x2F;AHB2&#x2F;AHB3；连接“桥”的总线。 这些高速总线直接与总线矩阵连接在一起，其实这些高速总线实际上就是总线矩阵的延伸，或者说就是总线矩阵的一部分。 内存映射这张图太重要了，看懂这张图，你的STM32已经可以掌握50%了，下面就来着重讲解这一张图。这张图来自STM32F429参考手册第84页，由于原版是英文的，搞了一个翻译过来的版本。 1、STM32存储空间芯片能访问的存储空间有多大，是由谁定的？这个是由芯片内CPU的地址总线的数量决来定的，STM32芯片内部的地址总线为32根。 1根地址线：可以传输的地址为0和1的，那么理论上就可以访问2个字节。 2根地址线：可以传输地址为00、01、10、11，理论上可以访问4个字节。 3根地址线：可以传输的地址为000、001、010、011、100、101、110、111，理论上可以访问8个字节。 32根地址线：可以产生00000000 00000000 00000000 00000000 — 11111111 11111111 11111111 11111111的2^32个地址，范围刚好为4G，所以我们就说STM32的32根地址线，理论上可以访问4G字节的存储器空间。 在上图的最右边可以看到STM32地址是从0x00000000到0xFFFFFFFF，这就是4GB的存储空间。但是STM32真的有4GB的存储空间吗？ 你在想啥呢？答案当然不是，我们的PC电脑也才4GB的内存。一个小小的单片机怎么可能有4GB的存储空间！这个4GB的是STM32理论分配的地址空间。也就是说实际上并不是有这么大的存储单元。上图中第二排可以看到有很多预留的地址，这些地址并没有给他分配存储单元。 所有的存储器都是与地址线连着的，但是实际上如果你只接了一个10M的存储器，而且是从0地址开始映射的，那么32根地址线所产生的0~10M的地址信号其实才是有意义的，因为这些地址信号才有对应真实的存储器，而所产生的10M以上地址信号其实并无意义，因为并不对应真实的存储器。 举个例子，政府给你化了10栋楼房的面积用来盖房子，但是实际上你没有那么多钱，只盖了3栋楼，其他的7栋房子预留的面积只能放在那里，这样说你应该明白了吧。 STM32中的32是32根地址线的意思吗？ 答：不是，STM32的32不是32根地址线的意思，而是表示MCU芯片内部CPU在处理数据时，每次可以处理的数据位宽为32个bit。正是由于这个原因，STM32 内部的寄存器大小都是32位的，刚好等于位宽。 某个芯片是32位的，但是它的地址线完全可以只有16根、或者8根，对于 STM32 来说，刚好碰巧的是，CPU能够处理的数据位宽与地址线数量恰好都是 32，所以不少小伙伴往往被搞迷糊了，认为是一回事。 2、什么是存储器映射映射其实就是对应的意思。事实上存储器本身并不具备地址，将芯片理论上的地址分配给存储器，这就是存储器映射。 举例理解：比如前面举的10M存储器的例子，这个10M存储器原本并没有地址，我将10M存储器映射到理论32根地址线可以传输4G个地址信号，每个地址信号访问一个字节，4G地址信号则可以访问4G个字节，所以理论上的可访问范围为4G。 地址0往后的10M范围，这10M的存储器就有了0—10M的地址，地址线所产生的0~10M之间的地址信号，就可以访问10M的这个真实存储器。至于在生产芯片时，在工艺和技术上具体是怎么实现我们所描述的映射的，我们无需关心。 3、STM32F429的存储器映射STM32的所有片内外设其实都是存储器，所以所有的这些存储器都需要被映射，只是理论上的4G范围远远大与实际的存储器空间，也就说实际的存储器空间并没有4G。 存储器是很贵的，一个STM32单片机如果有4G存储器的话，那就很贵了，而且单片机的产品根本不需要这么大的存储空间。 理论上地址起始就是门牌号，存储中的每个字节就是房间，存储器生产出来后，这些房间是没有地址的(门牌号)，映射的过程其实就是将这些门牌号分配给这些房间，分配好后，每个门牌号只能访问自己的房间，没有被分配的地址就是保留地址，所谓保留地址的意思就是，没有对应实际存储空间。 可不可以保留一些地址不分配呢？ 当然可以，因为理论上可以有4G的地址，但是实际上不可能给你4G存储空间，否则这个单片机芯片你可买不起，PC机的内存也才4G&#x2F;8G，单片机怎么可能真的给你4G存储空间呢? 寄存器映射存储器本身没有地址，给存储器分配地址的过程叫存储器映射，那什么叫寄存器映射？寄存器到底是什么？ 在存储器Block2这块区域，也就是地址从0x4000000—0x5FFFFFF这块区域，设计的是片上外设，它们以四个字节为一个单元，共32bit，每一个单元对应不同的功能，当我们控制这些单元时就可以驱动外设工作。可以找到每个单元的起始地址，然后通过C语言指针的操作方式来访问这些单元，如果每次都是通过这种地址的方式来访问，不仅不好记忆还容易出错，聪明的工程师就根据每个单元功能的不同，以功能为名给这个内存单元取一个别名，这个别名就是我们经常说的寄存器，这个给已经分配好地址的有特定功能的内存单元取别名的过程就叫寄存器映射。 这一张图够清晰吧！ 因此如果我想往0x40020410这个地址写入数值0xFFFF，应该怎么操作呢？ 是不是只需要下面这一句话就可以了？ 1*(unsigned int*)(0x4002 0410) = 0xFFFF; 一直以为这句话很清楚，但是却发现有人看不懂这句话，那我来解释一下： 首先编译器不知道0x40020410是一个啥东西，它可能表示小猫，也可能表示小狗。但是我们知道这个16进制数是一个地址对吧？那么怎么把它变成一个地址呢？ 是不是在它的前面加上(unsigned int*)变成(unsigned int*)(0x40020410)就把这个数变成一个指针了也就是一个地址了？但是我们操作的是这个地址里面的内容，是不是再在前面加上一个星号变成*(unsigned int*)(0x40020410)就可以了，然后就可以给它赋值了：*(unsigned int*)(0x4002 0410) = 0xFFFF; 地址重映射自举(bootstrap)计算机设备使用硬件加载的程序，用于初始化足够的软件来查找并加载功能完整的操作系统。也用来描述加载自举程序的过程。什么是单片机的自举，单片机的自举就是单片机的启动。 我们说，单片机程序基本都是从0地址出开始运行的，F429的0x00000000-0x001FFFFF地址映射了到什么存储器上，那么就从该存储器上读取指令，开始运行。 至于说0x00000000-0x001FFFFF到底映射在了什么存储器上，这个要看F429 芯片 BOOT1、BOOT0这两个引脚的电平值，说白了就是，通过BOOT1和BOOT0 引脚的电平值，可以选择将0x00000000-0x001FFFFF映射到不同的存储器上。 STM32片内的FLASH分成两部分：主存储块、信息块。主存储块(主Flash)用于存储程序，我们写的程序一般存储在这里。信息块又分成两部分：系统存储器(系统FLASH)、选项字节。系统存储器存储用于存放在系统存储器自举模式下的启动程序(BootLoader)，当使用ISP方式加载程序时，就是由这个程序执行。这个区域由芯片厂写入BootLoader，然后锁死，用户是无法改变这个区域的。选项字节存储芯片的配置信息及对主存储块的保护信息。 主FLASH的地址 主FLASH地址为0x0800 0000-0x081FFFFF，Jlink下载时的FLASH设置是不是通过Jlink下载到了地址为0x08000000的地方，大小是0x00100000，也就是1MB。 疑问：明明代码是下载到0x80000000往后的存储空间中，为什么说运行又是从0x00000000地址运行的呢？为什么不是从0x80000000开始运行的呢？ 有关这个问题，就是我们说的单片机的自举。 正常情况下都是映射到主FLASH上，所以都是从主FLASH上启动的，为了从FLASH启动，我们需要将代码下载到主FLASH上。 什么是地址重映射 如果0x00000000-0x001FFFFF之前是映射在系统存储器或者嵌入式 SRAM上的，现在改变BOOT0、BOOT1 的电平为 0、x。0x00000000 -0x001FFFFF就被重新映射在了主FLASH上，这就是单片机的地址重映射。 重映射就是本来是和张三进行映射的的，现在改为了和李四映射。换句话说重映射就是0x00000000 -0x001FFFFF(1MB)本来映射在系统存储器 0x1FFF 0000-0x1FFF7A0F(30KB)上面，现在映射到了主FLASH 0x08000000 -0x081FFFFF(1MB)上面。 选择从主FLASH启动时，显然FLASH会被映射在了两片地址上。 原本映射的地址(1MB)：0x08000000-0x081F FFFF，进行Jlink下载时使用这个地址 重映射的地址(1MB)：0x00000000-0x001F FFFF，启动时CPU就是从重映射的地址读取指令 这两片地址都是有效的，重映射到FLASH上后，CPU从0地址开始运行时，就从FLASH上读取指令，当然前提是我们需要将代码下载FLASH中。 这就解释了为什么我们在keil中设置好程序的下载地址为0x8000000，但是单片机上电是确实从0开始执行。是因为我们在硬件上设置了BOOT0&#x3D;1,BOOT1&#x3D;X，从而导致了主FLASH区(也叫主闪存，大小1MB)被映射到了0x00000000-0x001FFFFF(1MB)，故而代码是下载到 0x80000000 往后的存储空间中，却说运行又是从0x00000000地址运行的。 疑问：下载时，能不能使用0x00000000地址来下载? 答：这个不行，因为下载时，0x00000000-0x001FFFFF还没有被重映射到FLASH上，只能使用0x08000000来下载。 上面说的是我们用JLink下载器下载代码，但是有时候我们还听说可以用串口来下载程序，这又是怎么回事？ 用串口下载程序，也就是我们说的ISP在系统中编程。从系统存储器启动，即STM32的ISP了。此时硬件电路B00T0&#x3D;1，B00T1&#x3D;0。由于串口不能直接把程序下载到主FLASH里面，所以需要使用到ST公司内嵌于系统存储区的Bootloader来引导把程序下载到主FLASH里面。JLink能直接把程序下载到内置的FLASH里面，是因为JLink下载器内部有Bootloader来引导把程序下载到FLASH里面。程序下载完成后还需要配置BOOT引脚为BOOT0&#x3D;0，BOOT1&#x3D;X(即从主闪存存储器启动)，复位后才能正常启动程序。如果你不修改BOOT引脚的话也就是B00T0&#x3D;1，B00T1&#x3D;0，那么0x0000 0000 - 0x001FFFFF是不是被重映射到系统存储器上面，而程序代码在主FLASH里面。你复位后程序肯定不能正常运行，只有在使用串口下载程序后配置BOOT引脚为BOOT0&#x3D;0，BOOT1&#x3D;X，复位后才能正常执行代码。你明白了吗？ 总结：使用JLink下载代码，JLink下载器内部的Bootloader将程序引导下载到主FLASH里面。使用串口下载代码，由于串口没有Bootloader，就要使用ST官方内置在芯片系统存储区的Bootloader代码，将程序引导下载止主FLASH。又因为程序是从0开始执行的，所以我们复位后运行程序时一定要让BOOT0&#x3D;0，BOOT1&#x3D;X，将0x00000000-0x001FFFFF是重映射到主FLASH我们代码存在的地方，从0开始执行代码。 下图是使用FlyMcu串口下载程序，这个串口是USB-TTL，下载程序时让BOOT0&#x3D;0，BOOT1&#x3D;X即可。不是说在系统中编程需要将B00T0&#x3D;1，B00T1&#x3D;0吗？这是因为我们使用的是这个软件，这个软件可以通过DTR和RTS改变BOOT的引脚电平，达到不用修改BOOT引脚就可以下载运行代码，实际上是软件替我们做了改变BOOT引脚的操作，具体介绍可以看上面的说明。 关于ISP与IAP关于这两者的区别已经在上面做过详细的解释了，下面是一个总结。 ISP在系统编程，是指直接在目标电路板上对芯片进行编程，一般需要一个自举程序(BootLoader)来执行。ISP也有叫ICP在电路编程、在线编程。 IAP在应用中编程，是指最终产品出厂后，由最终用户在使用中对用户程序部分进行编程，实现在线升级。IAP要求将程序分成两部分：引导程序、用户程序。引导程序总是不变的。IAP也有叫在程序中编程。ISP与IAP的区别在于，ISP一般是对芯片整片重新编程，用的是芯片厂的自举程序。而IAP只是更新程序的一部分，用的是电器厂开发的IAP引导程序。综合来看，ISP受到的限制更多，而IAP由于是自己开发的程序，更换程序的时候更容易操作。 9. 51单片机内存映射思维结构很重要： 由上图可知，51单片机的存储器分为俩大部分：程序存储器ROM和数据存储器RAM，这一点有别与计算机 程序存储器ROM：1、 程序存储器ROM顾名思义，存放程序的地方，程序指令指导单片机完成设定的功能2、 51单片机专门设置一个16位的PC，用于指示下一时刻CPU将要执行的程序指令在ROM中的位置，由于PC指针长度位16位，所以单片机的程序存储器ROM空间大小为2^16 &#x3D; 64Kb，从0000~FFFFH3、 ROM还可以细分为片内ROM和片外ROM 片内ROM：8051片内有4KB ROM，地址范围从0000H~0FFFH 片外ROM：片外可扩展，一般从1000H~FFFFH ，64KB PS:那么问题来了，51单片机是如何区分是片内ROM还是片外ROM呢？ 片内ROM和片外ROM的区分：在单片机既有片内ROM又有片外ROM时，会产生一部分重复的地址范围，为了解决区分片内和片外ROM的问题，51单片机设置了一根控制线EA(低电平有效)，所以EA &#x3D; 0 &#x3D;&gt; 有效 &#x3D;&gt; 访问片内存储器EA &#x3D; 1 &#x3D;&gt; 无效 &#x3D;&gt; 片内存储器被忽略本质的原理：就是当PC的值大于了某个值时将访问外部存储器，PC的值小于了某个值时将访问内部存储器。这个值由存储器容量的大小绝定，在8051单片机中，片内ROM &#x3D; 4KB，所以当PC小于0FFFH时，访问片内ROM。具体的执行过程：当EA &#x3D; 0，毫不犹豫直接从0000H开始访问片外ROM当EA &#x3D; 1，PC从0000H开始访问片内ROM，当PC大于0FFFH时，转向访问 片外ROM，如图： 程序存储器ROM中的7个特殊地址：即7个外部中断的入口地址，每个地址相隔8个地址单元，存放终端服务程序显然不够，所以一般在这7个特殊地址中存放跳转指令，跳转到相应的中断服务程序。 数据存储器RAM：1、 RAM存储器一般存放单片机运行期间所需要的的数据和临时生成的数据，需要能够快速的读写。掉电丢失。2、 同ROM相同，RAM也分为片内RAM和片外RAM 片内RAM： 1、 00H1FH：工作寄存器区，又称通用寄存器，32字节，8字节为一组共4组。在特殊功能寄存器篇说到标志寄存器PSW的RS0、RS1位来选择工作的4组寄存器中的一组，即选择的就是这个位置中的某一组2、 20H2FH：位寻址区，16字节，128位，这个地址空间中的128位可以按位访问，每一位都有一个地址，寻址空间为00H ~ 7FH ,如图： 在20H~2FH空间中，重新为每一位地址分配一个地址00H ~ 7FH，从而实现按位访问。 3、 一般RAM区：又称用户RAM区，80字节，对于52系列，一般从30H~FFH 供用户使用，对于前俩个区中未使用的地址单元也可以作为用户单元使用4、 堆栈区与堆栈指针一般设置在2FH单元以后，避开工作寄存器区和位寻址区，典型应用就是子函数调用： 片外RAM：同ROM相似，通过外部总线扩展RAM从而获得更大的存储空间，由于外部总线宽度为16位，所以片外扩展最多64KB，地址范围0000H~FFFFH 10. cc2530内存映射本文以CC2530的F256为例，即有256kb的flash存储器和8K的sram存储器 一、CC2530里的四种存储空间（结构上划分的存储空间，并不是实际的存储器，是一种理论上的概念） \\1. CODE 程序存储器 用处存放程序代码和一些常量 有16根地址总线，所以CODE的寻址范围是 0000H~FFFFH 共64KB \\2. DATA 数据存储器 用于存放程序运行过程中的数据 有8根地址总线，所以DATA的寻址空间为 00H~FFH 共256 byte.低128位可以直接寻址，高128位只能间接寻址。 ​ \\3. XDATA 外部数据存储器（只能间接寻址，访问速度比较慢） DMA是再XDATA上寻址的，这一点很重要​ 有16根地址总线，所以 XDATA 的寻址空间为 0000H ~ FFFFH 共64K ​ \\4. SFR 特殊功能寄存器 就是那些T1CTL, EA, P0 等配置寄存器存储的地方 共128K。因为CC2530的配置寄存器比较多，所以一些多余的寄存器就放到了XREG 里面。XREG的大小为1K XREG的访问速度比 SFR慢。 以上4中存储空间只是4种不同寻址方式的概念，并不代表物理上具体的存储设备。例如 FLASH 或者 EEPROM都可以作为物理的存储媒介映射到CODE上，DRAM或者SRAM都可以作为存储媒介映射到DATA中。CODE和DATA是存储空间的概念，FLASH、SRAM、EEPROM等是具体的物理存储设备，这两个概念不要混淆。这好比，电脑需要RAM和ROM,这个ROM可以是西部数据的硬盘，也可以使三星的硬盘，也可以是不同材料的固态硬盘。一个是存储空间，另一个是具体的物理存储设备。 二、关于CODE存储器的映射 大家肯定会有疑问：既然CODE的寻址范围只有64KB,那CC2530F256怎么有256KB的flash呢？ 正是为了解决寻址空间不足的问题，CC2530才提出了映射的概念。（当然，映射的另一重要目的是为了DMA）CC2530把FLASH存储器分成了几个bank，每个bank的大小是32KB,即对于F256来讲，它有8个bank分别是bank0bank7(不同芯片，bank数目不同)。通过FMAP.MAP[2:0] 控制，把不同的编号的bank映射到CODE上，解决了寻址空间受限制的问题。上图.. 从图中可以看出，bank0是rootbank，就是程序开始执行的地方，这个common area始终都是对应FLASH存储器的0000H7FFFH, 上面的另一半可以映射bank0~7. 我以前一直疑惑，为什么common area已经有bank0了，上面怎么还可以有bank0，从user guide里看，这样是可以的，就比如CC2530F32，只有一个bank0，它也只能这么映射了吧。 三、关于XDATA存储器的映射关于XDATA的映射，可以这么说：一切都是为了DMA！！ 为了让DMA能访问所有的存储区域，所以把所有的存储器都映射到了XDATA上。上图： 从图中可以看出，XDATA中包含了所有存储器的映射，包括256kb的FLASH存储器，8K 的SRAM存储器，还有 SFR , XREG, INFORMATION FAGE。这里看出来，其实CC2530的DATA,和 XDATA，都是用SRAM作为物理存储媒介的，但是它们的寻址方式不一样，所以访问DATA,比访问XDATA要快。至于SFR,XREG,INFORMATION PAGE,我不知道它们用了什么物理存储媒介，但是它们都被映射到XDATA上，可以被DMA访问。 这里要搞清楚一个概念，映射到XDATA上，不代表就只能用XDATA的寻址方式访问。比如SFR,它虽然被映射到了XDATA上，只能说明，DMA可以通过访问XDATA来操作SFR,但是CPU还是可以通过单周期访问SRF.打个比方，我们平时坐的公交车上都有一把逃生应急锤，在紧急情况下可以敲破窗子逃生。我们平时不会使用锤子敲碎窗子进出车厢，我们平时有车门可以走。但是在特殊情况下（比如DMA要操作某个存储器中的数据时），我们可以用特殊的方法（从XDATA上的映射来得到我们想要的数据）。 四、关于从SRAM启动代码上图 这种情况下，CC2530把SRAM存储器整个都映射到了CODE的bank area，可以从SRAM中执行代码。不要理解错了，这里只是说可以从SRAM中运行代码，不代表程序从SRAM中启动。程序还是会从 CODE的rootbank的0000H开始执行，只不过我们可以通过程序控制，让程序跳到 8000H之后，执行我们SRAM中想要的代码。 11. BCD码（Binary Coded Decimal‎） 用4位二进制数来表示1位十进制数 例：0001 0011表示13，1000 0101表示85，0001 1010不合法 在十六进制中的体现：0x13表示13，0x85表示85，0x1A不合法 BCD码转十进制：DEC&#x3D;BCD&#x2F;16*10+BCD%16; （2位BCD） 十进制转BCD码：BCD&#x3D;DEC&#x2F;10*16+DEC%10; （2位BCD）","categories":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://1nameccc.github.io/tags/%E6%9D%82%E9%A1%B9/"},{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"coucou"},{"title":"单片机——IO","slug":"3-1-单片机-IO/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:57:40.398Z","comments":true,"path":"2023/08/01/3-1-单片机-IO/index/","permalink":"http://1nameccc.github.io/2023/08/01/3-1-%E5%8D%95%E7%89%87%E6%9C%BA-IO/index/","excerpt":"单片机——IO","text":"单片机——IO 输入和输出模式： 在输入模式下，IO口充当接收器，可以读取外部设备发送的信号。这种模式适用于读取开关状态、传感器数据等。 在输出模式下，IO口充当驱动器，可以向外部设备发送信号。这种模式适用于控制LED灯、继电器、电机等外部设备。 输入缓冲： 输入缓冲通常由CMOS（互补金属氧化物半导体）电路构成，用于接收外部设备发送的信号，并提供电平转换和电流放大功能。 输入缓冲可以通过配置寄存器来设置输入电平电压的触发阈值，以适应不同的输入信号电平要求。 输出驱动： 输出驱动是用于向外部设备发送信号的电路，能够提供足够的电流和电压来驱动外部设备。 输出驱动的能力通常由IO口的指定参数（如最大输出电流）来定义，需要根据外部设备的要求选择适当的IO口。 输入状态寄存器： 输入状态寄存器用于存储IO口的输入状态，可以通过读取该寄存器来获取外部设备发送的信号状态。 输入状态寄存器中的位对应于每个IO口，可以判断IO口是处于高电平还是低电平状态。 输出状态寄存器： 输出状态寄存器用于存储IO口的输出状态，可以通过写入该寄存器来控制IO口的输出信号状态。 输出状态寄存器中的位对应于每个IO口，可以设置IO口为高电平或低电平输出。 上拉和下拉电阻： 上拉电阻和下拉电阻用于确保IO口在未连接外部设备时保持稳定的电平状态。 上拉电阻将IO口连接到高电平，而下拉电阻将IO口连接到低电平。 上拉和下拉电阻可以通过配置寄存器来使能或禁用。 中断功能： 中断功能允许IO口在特定事件发生时触发中断请求，以便及时处理相应事件。 中断可以是外部中断，当外部设备信号发生变化时触发；也可以是内部中断，当IO口状态满足特定条件时触发。 中断功能可以通过配置寄存器和中断向量表来实现。 IO口编址和寄存器配置： IO口通常通过特定的寄存器进行配置和控制。寄存器的地址和位定义根据单片机型号和厂商而异，需要查阅相应的单片机手册和参考资料来了解具体的编址和配置方法。 IO口的引脚分配和映射： 单片机的IO口引脚分配和映射关系取决于具体的单片机型号和封装形式。 在设计电路板时，需要根据单片机引脚图和外部设备的连接需求，将相应的IO口引脚与外部设备正确连接。","categories":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"IO","slug":"IO","permalink":"http://1nameccc.github.io/tags/IO/"}],"author":"coucou"},{"title":"单片机——通信协议","slug":"3-2-单片机-通信协议/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:57:55.701Z","comments":true,"path":"2023/08/01/3-2-单片机-通信协议/index/","permalink":"http://1nameccc.github.io/2023/08/01/3-2-%E5%8D%95%E7%89%87%E6%9C%BA-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/index/","excerpt":"单片机——通信协议","text":"单片机——通信协议 同步通信和异步通信 同步通信： 通信时序：同步通信是基于时钟信号的通信方式。发送端和接收端需要共享相同的时钟信号，以确定数据传输的时刻。 等待：在同步通信中，发送端和接收端必须等待时钟信号的到来，然后才能进行数据传输。这意味着通信的步调是由时钟信号控制的，通常更容易实现高速通信。 优点：同步通信通常更可靠，因为发送端和接收端的时钟同步，不容易出现数据丢失或错误。 缺点：同步通信要求严格的时钟同步，因此在长距离通信或异构系统中可能会面临挑战。 异步通信： 通信时序：异步通信是一种不依赖共享时钟信号的通信方式。数据帧中通常包含了起始位、停止位和数据位，以便接收端确定数据的开始和结束。 不等待：在异步通信中，发送端和接收端不需要等待时钟信号的到来。数据可以在任何时间传输，只要遵循数据帧的结构。 优点：异步通信更灵活，适用于各种通信场景，不受时钟同步的限制。 缺点：相对于同步通信，异步通信可能在高速通信时更容易出现数据丢失或错误，因为没有严格的时钟同步。 本质区别：本质区别在于时钟信号的使用和数据传输的等待方式： 同步通信 依赖于共享时钟信号，数据传输的时刻由时钟信号确定，通信步调固定。 异步通信 不依赖共享时钟信号，数据传输的时刻不受时钟控制，通信更加灵活，但可能更容易出现数据传输问题。 选择同步通信还是异步通信取决于特定应用的需求和环境。同步通信通常用于高速、可靠的通信，而异步通信更适用于灵活性较高的通信场景。 i2c 按字节传输 I2C（Inter-Integrated Circuit）是一种常见的半双工串行同步通信协议，用于在数字电路和单片机之间传输数据。它广泛应用于连接各种外部设备，如传感器、显示器、存储器和其他微控制器等。以下是关于I2C通信协议的基本介绍： 工作原理： I2C是一种主从制通信协议，其中有一个主设备（通常是微控制器）和一个或多个从设备。 通信通过两根线实现：SCL（时钟线）和SDA（数据线）。 主设备生成时钟信号并控制通信的起始和停止。 数据传输是双向的，允许主设备发送数据到从设备，也可以接收从设备发送的数据。 基本概念： 主机（Master）：负责控制总线和启动通信。 从机（Slave）：响应主机的指令并与主机通信。 时钟信号（SCL）：主机产生的时钟信号，用于同步数据传输。 数据信号（SDA）：用于传输数据的双向数据线。 起始条件（Start Condition）：主机发出的信号，标志通信的开始。 停止条件（Stop Condition）：主机发出的信号，标志通信的结束。 地址： 每个从设备都有唯一的7位或10位地址，用于选择要与之通信的从设备。 字节（Byte）：I2C通信以字节为单位传输数据。 ACK（Acknowledgment）：从机发送ACK信号来确认接收到的数据，或者发送NACK来拒绝接收。 通信过程： 主机发送起始条件（Start Condition）。 主机发送从机的地址和读&#x2F;写位（R&#x2F;W位）来选择从机。 如果从机存在且地址匹配，从机发送ACK信号。 主机和从机之间可以开始传输数据字节。 每个字节都由主机发送，然后从机发送ACK或NACK信号进行确认。 通信完成后，主机发送停止条件（Stop Condition）。 时钟速率 I2C的时钟速率是通信中使用的时钟频率，通常以赫兹（Hz）为单位表示。I2C支持不同的时钟速率，通常有以下标准速率选项： **标准模式 (Standard Mode)**：时钟速率为100,000赫兹（100 kHz）。 **快速模式 (Fast Mode)**：时钟速率为400,000赫兹（400 kHz）。 **高速模式 (High-Speed Mode)**：时钟速率为3.4兆赫兹（3.4 MHz）。 此外，有些设备还支持更高的速率，如超高速模式（Ultra Fast Mode），其速率可以高达5兆赫兹（5 MHz）。 要选择适当的时钟速率，你需要考虑以下因素： 设备兼容性：确保主设备和从设备都支持所选的时钟速率。 通信距离：更高的时钟速率通常适用于短距离通信，而较低的速率可能更适用于长距离通信，因为高速时钟信号可能会受到电缆长度和电容的影响。 系统要求：根据系统的性能需求选择适当的速率。例如，快速模式通常用于普通应用，而高速模式用于更要求高性能的应用。 注意事项： 了解常见的硬件故障和解决方案。 理解I2C的时序图和通信协议。 熟悉主机和从机的角色，以及它们在通信中的作用。 知道如何处理多个主机和多个从机的冲突。 熟悉I2C的应用领域和用途。 熟悉I2C的标准时钟速率和快速模式。 掌握I2C的错误检测和纠正技术。 应用： I2C通信协议常用于连接各种外部设备，如温度传感器、EEPROM存储器、显示屏、扩展模块等。在单片机编程中，你可以使用相应的库或驱动程序来轻松实现I2C通信，以与这些设备进行交互。 I2C是一种非常有用的通信协议，因为它允许连接多个设备，以简化硬件设计和连接。 spi 按帧传输 SPI（Serial Peripheral Interface）是一种全双工串行同步通信协议，通常用于微控制器、传感器、存储器和其他外围设备之间的数据传输。SPI协议具有以下关键特点： 全双工通信：SPI支持双向数据传输，允许主设备和从设备同时发送和接收数据。这使得SPI非常高效。 主从结构：SPI通信通常由一个主设备（通常是微控制器或微处理器）控制，与一个或多个从设备通信。主设备决定通信的时序和数据传输。 四根信号线：SPI通信需要四根线： SCLK（时钟线）：主设备产生的时钟信号，用于同步数据传输。 MOSI（数据输出线）：主设备发送数据到从设备。 MISO（数据输入线）：从设备发送数据到主设备。 CS&#x2F;CE（片选线&#x2F;片使能线）：用于选择从设备，通常一条线对应一个从设备。 时钟同步：SPI通信是时钟同步的，数据传输在时钟信号的上升沿或下降沿发生，具体取决于通信模式。 多种通信模式：SPI支持多种通信模式，根据时钟极性（CPOL）和相位（CPHA）的不同组合，可以有四种主要通信模式，如0、1、2、3模式。 数据格式：SPI通常采用8位数据帧，但可以根据需要使用不同的数据位宽。数据可以是高位在前或低位在前，具体取决于设备。 时钟频率：SPI的时钟频率可以根据设备的需求进行调整，通常以赫兹（Hz）为单位。通信速率可以从几千赫兹到几兆赫兹不等。 低成本和高效率：SPI协议非常适用于短距离、高速数据传输的应用，因为它需要的硬件资源相对较少，通信速度高。 SPI 速率 ⼏⼗ MHz 甚⾄上百 MHz，速度取决于 CPU的 SPI 控制器和时钟 clock STM32F103 的 SPI 最⾼⽀持 18MHz，imx6ull 的 SPI 最⾼⽀持 52MHz，其他芯片⼀般⽤不到更⾼的。 具体采⽤多⼤速率还和外设有关，比如EEPROM 的 W25Q128 的 SPI 最⾼⽀持80MHz，ICM20608 传感器的 SPI 最⾼⽀持8MHz。 SPI接口时钟配置心得： 在主设备这边配置SPI接口时钟的时候一定要弄清楚从设备的时钟要求，因为主设备这边的时钟极性和相位都是以从设备为基准的。因此在时钟极性的配置上一定要搞清楚从设备是在时钟的上升沿还是下降沿接收数据，是在时钟的下降沿还是上升沿输出数据。 uart 按字符传输 UART通信的关键概念： 异步传输：UART通信是异步的，这意味着发送和接收设备之间没有共享时钟信号。相反，它们使用预定义的波特率（Baud Rate）来同步数据传输。 数据位、停止位和校验位：每个UART数据帧通常包括数据位（通常是8位）、一个或多个停止位（通常是1或2位，用于确定数据帧的结束），以及一个可选的校验位（用于数据完整性检查）。 波特率：波特率定义了每秒传输的比特数。发送和接收设备必须在通信开始之前设置相同的波特率，以确保正确的数据传输。 全双工通信：UART通信通常是全双工的，这意味着设备可以同时发送和接收数据。 常见的串口类型： RS-232：RS-232是一种传统的串口通信标准，通常用于计算机和外部设备之间的通信。 RS-485：RS-485是一种多点通信标准，允许多个设备在同一串口总线上进行通信，适用于工业控制系统等场景。 UART：UART（Universal Asynchronous Receiver&#x2F;Transmitter）是一种通用的串口通信接口，广泛用于嵌入式系统和微控制器。 数据传送速率用波特率来表示，即每秒钟传送的二进制位数。例如数据传送速率为120字符&#x2F;秒，而每一个字符为10位（1个起始位，7个数据位，1个校验位，1个结束位），则其传送的波特率为10×120＝1200字符&#x2F;秒＝1200波特。 one wire 单总线（OneWire）是一种串行通信协议，它允许多个设备通过一个单一的数据线进行通信。这个协议通常用于低速、短距离的数字通信，特别适用于嵌入式系统和传感器网络。以下是关于单总线的一些重要特点和应用： 主要特点： 单一数据线： 单总线仅需要一根数据线，这极大地简化了硬件连接。设备可以在同一总线上连接，并且通过地址来区分彼此。 低成本： 单总线协议不需要复杂的硬件，这降低了成本。这使其成为连接多个设备的经济实惠选择。 数据传输速率： 单总线通常以较低的数据传输速率工作，适用于一些低功耗和简单的应用。 异步通信： 数据在单总线上传输是异步的，不需要共享时钟信号。这使得它适用于各种设备和微控制器。 支持供电： 单总线通常支持从总线上获得电源，这对于一些小型设备非常有用。 通信原理 物理层连接： 单总线通信通常包括一个总线上的主设备和一个或多个从设备。这些设备通过一根物理数据线连接。总线上还可能有一个电源线用于为从设备提供电源。 数据帧： 通信基于数据帧的传输。一个数据帧通常包括起始位（Start Bit）、数据位、可选的校验位，以及停止位（Stop Bit）。 数据传输： 数据传输是异步的，没有共享时钟信号。数据通过时间间隔来表示逻辑 0 和逻辑 1。逻辑 0 和逻辑 1通常是通过时间长短来区分的，即短脉冲表示逻辑 0，长脉冲表示逻辑 1。 设备地址： 每个从设备都有一个唯一的地址，主设备通过发送从设备的地址来选择与之通信的特定设备。 总线控制： 主设备负责控制总线上的通信。它生成起始条件（Start Condition）和停止条件（Stop Condition）来开始和结束通信。 时序要求： 单总线通信非常依赖时序。每个位都必须在特定的时间内传输和采样，以确保数据的正确性。 供电： 一些单总线设备可以从总线上获得电源，这减少了对额外电源线的需求。 错误处理： 单总线通信通常包括错误检测和纠正机制，以确保数据的完整性。 can CAN（Controller Area Network）是一种常用于实时控制系统和嵌入式系统中的串行通信协议。它最初是由Bosch开发的，旨在用于汽车领域，但后来广泛用于其他领域。以下是对CAN协议的介绍： 特点： 串行通信： CAN协议使用串行通信，其中数据位按照一定的时序通过单一的双绞线进行传输。 差分信号： CAN协议使用差分信号，即在两根线上传输相反的信号。这有助于减少电磁干扰，提高通信的抗干扰性。 广播通信： CAN协议采用广播通信方式，即所有节点都能接收总线上的数据，但只有特定节点会对数据进行响应。 实时性： CAN协议具有良好的实时性，适用于需要高速数据传输和精确时序的应用，如汽车控制系统。 冲突处理： CAN协议具备冲突检测和处理机制，可以确保在多个节点同时发送数据时不会发生冲突。 数据帧： 数据在CAN中以数据帧的形式传输，包括标识符、数据域和校验字段。 主动性： CAN通信是主动性的，节点可以随时发送数据，而其他节点则需要主动接收或忽略它。 CAN总线基本原理： 差分信号： CAN总线使用差分信号，即两根线，分别称为CAN_H和CAN_L，传输相反的信号。这种差分信号有助于减少电磁干扰，提高通信的稳定性。 帧结构： CAN通信使用帧（Frame）的结构。每个CAN帧包括标识符（Identifier）、数据域（Data Field）、控制位和校验字段。标识符用于唯一标识帧的用途和优先级。 通信速率： CAN总线支持多种通信速率，从几千位每秒到数兆位每秒不等，具体速率根据应用需求设置。 CAN通信过程： 发送帧： 当一个CAN节点（例如传感器或控制器）要发送数据时，它将准备好的数据装载到CAN帧中，包括标识符、数据域等。 仲裁： 如果多个节点尝试同时发送数据，CAN总线上的仲裁机制确定哪个节点有权发送。这是通过标识符的比较来实现的，具有更低标识符值的节点具有更高的优先级。仲裁后，具有最高优先级的节点获得总线控制权。 数据传输： 一旦获得总线控制权，节点将其CAN帧发送到总线上。CAN帧的数据位按照时序通过CAN_H和CAN_L线传输。 接收和过滤： 所有节点都接收总线上的数据帧，但只有与标识符匹配的节点才会处理数据。这是通过过滤机制实现的。 错误检测： CAN通信具有内建的错误检测机制，用于检测和处理传输中的错误。这包括奇偶校验、CRC（循环冗余校验）和其他机制。 应答： 如果数据被成功接收，节点可以发送应答帧来确认接收。这有助于确保数据的可靠传输。 循环重复： CAN总线上的通信是循环重复的过程，多个节点可以依次发送和接收数据。 wifi bluetooth","categories":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"通信协议","slug":"通信协议","permalink":"http://1nameccc.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"}],"author":"coucou"},{"title":"单片机——配置相关术语","slug":"3-3-单片机-配置相关术语/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:58:01.623Z","comments":true,"path":"2023/08/01/3-3-单片机-配置相关术语/index/","permalink":"http://1nameccc.github.io/2023/08/01/3-3-%E5%8D%95%E7%89%87%E6%9C%BA-%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/index/","excerpt":"单片机配置","text":"单片机配置 指令周期、机器周期、时钟周期的概念及三者之间的关系 指令周期：​ CPU每 *取出* 一条指令并 执行 这条指令，都要完成一系列的操作，这一系列操作所需要的时间通常叫做一个指令周期。换言之****指令周期是取出一条指令并执行这条指令的时间*。由于各条指令的操作功能不同，因此*各种指令的指令周期是不尽相同的****。例如一条加法指令的指令周期同一条乘法指令的指令周期是不相同的 。 机器周期：​ 机器周期也称为****CPU周期*。在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作。*完成一个基本操作所需要的时间称为机器周期*。一般情况下，一个机器周期由若干个时钟周期*组成 。 时钟周期：​ 时钟周期T又称为振荡周期，由单片机片内振荡电路OSC产生，常定义为时钟脉冲频率的倒数，是时序中最小的时间单位。例如，若某单片机时钟频率为1MHz，则它的时钟周期T应为1μs。由于时钟脉冲是计算机的基本工作脉冲，它控制着计算机的工作节奏，使计算机的每一步工作都统一到它的步调上来。显然，****对同一种机型的计算机，时钟频率越高，计算机的工作速度就越快****。但是，由于不同的计算机硬件电路和器件的不完全相同，所以它们需要的时钟周期频率范围也不一定相同 1 &#x2F; 1MHz &#x3D; 1us 输入输出 输入 输入上拉：默认输入高电平 输入下拉：默认输入低电平 浮空输入：不稳定 模拟输入：如AD模拟信号 输出 推挽输出：P-MOS和N-MOS均有效，高低电平均有较强驱动能力 开漏输出：N-MOS有效，低电平有较强的驱动能力 ​ 补充：TTL 是斯密特触发器：防止信号不稳定 串口 波特率 数据格式：如字长8位 停止位 奇偶校验位 定时器 自动重装载值 定时器分频：配置对应的溢出时间 计数模式：向上计数、向下计数 等等 定时器时间计算单片机的定时原理通过每一个机器周期，就加一，通过数1的方式进行计时。 基本概念1.晶振：又称晶体振荡器，是数字电路“心脏”，是电子元件中不可或缺的频率元件，对于数字电路系统，晶振的好还直接影响系统的稳定性。 2.时钟周期：将晶振的频率的倒数定义为时钟周期，在一个时钟周期内，CPU完成一个基础动作，对于更小的时钟周期，意味着CPU有更好的性能，更高的工作效率。 3.机器周期：将时钟周期的6倍或者12倍定义为一个机器周期，具体的设定需要通过人为进行控制 每一次“加1”经过的时间是多少当晶振频率是11.0592MHz的时候，等于11059.2KHz &#x3D; 11059200Hz 机器周期 &#x3D; 12 x 时钟周期 &#x3D;12 x (1&#x2F;时钟频率) 秒 &#x3D; 12 &#x2F; 11059200 秒 &#x3D; 12 000 000 &#x2F; 11059200 微秒 &#x3D; 1.085 微秒 也就是说对于11.0592Mhz的晶振，其机器周期就是1.085微秒 实际案例案例：通过单片机设定一个10ms的定时器有如下的部分 符号 含义TL0(Timer Low0) 定时器0的低8位寄存器TH0(Timer HIgh0) 定时器0的高8位寄存器根据上表，可以知道共16位的寄存器可以数2^16次，就是65536次，而每次计数一下，就会耗费1.085微秒，因此当计数超过65535时，定时器寄存器就会爆表，也就是经过之后就会爆表，通常可以理解为经过71ms之后就会爆表。 对于10ms而要，首先可以计算出10ms定时定时器需要数多少次，设需要数x次，则 设定时器的初始值为y，则 将56320转化成16进制数，通过计算可以知道16#DC00，因此TH &#x3D; DC ;TL &#x3D; 00 也就是说需要计数9612次，就可以认为经过了10ms，这时，我们可以用71ms减去10ms的次数，就可以知道定时开始计数的初始值，这个值就是y值 小结单片机定时器的原理就是通过计算出所定时间需要计数的次数x，通过65536减去x，算出定时器所需的初始值，然后将初始值转化成16进制，填入TH与TL寄存器中，然后通过读取定时器溢出标志位，就可以知道定时器的定时状态。 EXIT中断 中断优先级 触发方式：**上升沿触发、下降沿触发 ** 等等 中断线使能 中断标志位 PWM输出PWM，是脉冲宽度调制，是控制在一个周期内，控制高电平多长时间，低电平多长时间，在数字电路中IO口就只有两种状态，0和1(高低)，对应就是0和5V或者0和3.3V）。也就是说，通过调节高低电平时间的变化来调节信号、能量等的变化 占空比是指 高电平持续 时间 比 一个 周期持续 的时间。所以可以通过控制占空比，来控制输出的等效电压。所以对于方波的话，频率和占空比就确定了一个波 PWM的频率： 是指1秒钟内信号从高电平到低电平再回到高电平的次数(一个周期)；也就是说一秒钟PWM有多少个周期, 单位： Hz 表示方式： 50Hz 100Hz 周期：T&#x3D;(TIMx_ARR+1)*(TIMx_PSC+1)&#x2F;TIMxCLK其中，TIMxCLK是其时钟频率，若是晶振为8MHz的，一般为72MHz 占空比：(TIMx_CRRx&#x2F;TIMx_ARR)*100% 输入捕获输入捕获模式可以用来测量脉冲宽度或者测量频率，下图以测量脉宽为例来说明输入捕获的原理 假定定时器工作在向上计数模式，图中t1-t2的时间就是我们需要测量的低电平时间。测量方法为：首先设置定时器通道x为下降沿捕获，在t1时刻就会捕获到当前的CNT值，然后立即清零CNT，并设置通道x为上升沿捕获，到t2时刻又会发送捕获事件，得到此时的CNT值（记为CCRx2）。在t1-t2之间可能产生N次定时器溢出，因此需要对定时器溢出做处理，防止低电平太长导致数据不准确。 t1-t2之间计数的次数为：N * ARR + CCRx2，再乘以CNT计数周期即可得到低电平持续时间 ADCAnalog-to-Digital Converte是指将连续变量的模拟信号转换为离散的数字信号 ADC主要有三种输入方式，分别为单端、全差分、伪差分 方式 引脚接线 抗干扰能力 单端输入 ADCIN,GND（简单） 弱 全差分输入 ADCIN+,ADCIN-,GND（复杂） 强 伪差分输入 中 分辨率 分辨率，即每个采样数据精度，用多少位数字来表示采集到一个模拟量，分辨率越高就能采集越精确的数据 常用分辨率：8bit、10bit、12bit 分辨率计算：测量电压范围 &#x2F; ( 2^位数 - 1 ) 示例：测量电压范围0~3.3V，分辨率10bit ​ 3.3V &#x2F; (2^10 - 1) &#x3D; 3.3V &#x2F; 1023 &#x3D; 0.00322V 转换速率转换速率是指A&#x2F;D转换一次所需要时间的倒数，即单位时间内完成A&#x2F;D转换的次数 采样速率 采样速率，即每秒对ADC采样的次数 转换方式 单次转换模式下，ADC只执行一次转换； 连续转换模式中，当前面ADC转换一结束马上就启动另一次转换； 扫描模式用来扫描一组模拟通道 ADC通道选择： 规则通道组和注入通道组 在执行规则通道组扫描转换时，如有例外处理则可启用注入通道组的转换。也就是说，注入通道的转换可以打断规则通道的转换，在注入通道被转换完成之后，规则通道才可以继续转换。 ADC中断 规则和注入组转换结束时能产生中断，当模拟看门狗状态位被设置时也能产生中断。它们都有独立的中断使能位。 I2CIIC（I2C）是一个同步半双工串行通信协议，使用3根线即可连接 名称 功能 SCL 时钟线 SDA 数据线 GND 接地 发送起始信号 发送地址 接受校验信号 发送或接受数据8bit 接受校验信号 重复 发送结束信号 在空闲状态时（SCL，SDA为高电平），SDA产生下降沿为起始信号 在SCL为高电平时，SDA产生上升沿信号，之后SCL，SDA全为高，进入空闲状态 SPISPI是一种高速的，全双工，同步的通信总线 （1）MOSI：主器件数据输出，从器件数据输入（2）MISO：主器件数据输入，从器件数据输出（3）SCLK ：时钟信号，由主器件产生（4）CS：从器件使能信号，由主器件控制 采样沿：SPI采用边沿触发采样、移位发送，CPHA&#x2F;CPOL组合形成四种SPI时序模式： 1.CPOL &#x3D; 0低电平为空闲，数据线在时钟为低时可改变，两根数据线在时钟高电平期间须保持稳定，分两种情况： 1.1 CPHA&#x3D;0时，输入侧上升沿采样，输出侧在下降沿移位输出到线上 1.2 CPHA&#x3D;1时，输入侧下降沿采样，输出侧在上升沿移位输出到线上 2.CPOL &#x3D; 1高电平空闲，两根数据线在时钟为高时可改变，两根数据线在低电平期间须保持稳定。分两种情况： 2.1 CPHA&#x3D;0，输入侧在下降沿采样，输出侧在上升沿移位输出到线上 2.2 CPHA&#x3D;1，输入侧在上升沿采样，输出侧在下降沿移位输出到线上 这里输入输出是相对的。CPOL（clock polarity)控制时钟的极性，CPHA(phase relative to clock)控制相对于时钟的时序相位。CPOL&#x2F;CPHA排列组合形成四种SPI工作时序模式。 SPI通讯的优势 全双工串行通信； 高速数据传输速率; 简单的软件配置； 极其灵活的数据传输，不限于8位，它可以是任意大小的字； 非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。 SPI的缺点 没有硬件从机应答信号（主机可能在不知情的情况下无处发送）； 通常仅支持一个主设备； 需要更多的引脚（与I2C不同）； 没有定义硬件级别的错误检查协议； 与RS-232和CAN总线相比，只能支持非常短的距离； DMAdirect memory access是一种避开CPU，可以直接对外设和内存进行访问的技术，可以实现外设与内存、内存之间、外设之间数据的访问和搬移。 12345678910111213141516171819202122232425262728293031323334// DMA结构体, zigbeetypedef struct &#123; unsigned char SRCADDRH; // 源地址高字节 unsigned char SRCADDRL; // 源地址低字节 unsigned char DESTADDRH; // 目标地址高字节 unsigned char DESTADDRL; // 目标地址低字节 unsigned char VLEN : 3; // 可变长度传输模式选择 unsigned char LENH : 5; // 传输长度高字节 unsigned char LENL : 8; // 传输长度低字节 unsigned char WORDSIZE : 1; // 字节/字传输 unsigned char TMODE : 2; // 传输模式选择 unsigned char TRIG : 5; // 触发事件选择 unsigned char SRCINC : 2; // 源地址增量 unsigned char DESTINC : 2; // 目标地址增量 unsigned char IRQMASK : 1; // 中断使能 unsigned char M8 : 1; // 7/8 bits 字节(只用于字节传输模式) unsigned char PRIORITY : 2; // 优先级&#125; DMA_CONFIGURATIONPARAMETERS;// stm32typedef struct&#123; uint32_t DMA_PeripheralBaseAddr; // 设置 DMA 传输的外设基地址 uint32_t DMA_MemoryBaseAddr; // 内存基地址 uint32_t DMA_DIR; // 设置数据传输方向 uint32_t DMA_BufferSize; // 设置一次传输数据量的大小 uint32_t DMA_PeripheralInc; // 设置传输数据的时候外设地址是不变还是递增 uint32_t DMA_MemoryInc; // 设置传输数据时候内存地址是否递增 uint32_t DMA_PeripheralDataSize; //设置外设的的数据长度是为字节传输（8bits），半字传输 (16bits)还是字传输 (32bits) uint32_t DMA_MemoryDataSize; // 设置内存的数据长度 uint32_t DMA_Mode; // 设置 DMA 模式是否循环采集 uint32_t DMA_Priority; // 设置 DMA 通道的优先级 uint32_t DMA_M2M; //设置是否是存储器到存储器模式传输&#125;DMA_InitTypeDef; ​","categories":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"配置相关术语","slug":"配置相关术语","permalink":"http://1nameccc.github.io/tags/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/"}],"author":"coucou"},{"title":"单片机——ARM架构","slug":"3-4-单片机-ARM架构/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:58:10.454Z","comments":true,"path":"2023/08/01/3-4-单片机-ARM架构/index/","permalink":"http://1nameccc.github.io/2023/08/01/3-4-%E5%8D%95%E7%89%87%E6%9C%BA-ARM%E6%9E%B6%E6%9E%84/index/","excerpt":"ARM通识","text":"ARM通识 ARM采用32位架构 ARM约定一个Byte是8 bits，一个Halfword是16 bits (2 byte)，一个Word是32 bits (4 byte)。 大部分ARM core 提供ARM 指令集（32 bit，每条指令都是4个字节），Thumb 指令集（16bit），Thumb2指令集（16 &amp; 32bit）。 ARM的7种基本工作模式 ARM的工作模式分为普通模式、特权模式，其中特权模式又细分为六种模式。诸多模式是为了满足操作系统的安全等级需要，各种模式下可以访问的寄存器不同。 注意: 同一时刻CPU只处于其中一种模式, 程序员可以修改CPSR寄存器，实现各个模式的切换；CPU在某些情况下也会自动切换。 普通模式（Normal）（1）用户模式（User）：非特权模式，大部分任务执行在这种模式。 特权模式（Privilege）（2）快速中断模式（FIQ）：当一个高优先级（fast) 中断产生时将会进入这种模式。 （3）普通中断模式（IRQ）：当一个低优先级（normal) 中断产生时将会进入这种模式。 （4）超级用户模式（SVC）：当复位或软中断指令执行时将会进入这种模式。 （5）中止模式（Abort）：当存取异常时将会进入这种模式。 （6）未定义模式（Undef）：当执行未定义指令时会进入这种模式。 （7）系统模式（System）：使用和User模式相同寄存器集的特权模式。 ARM的37个通用寄存器 （1）通用寄存器通用寄存器是CPU的组成部分，CPU的很多活动都需要通用寄存器的支持和参与。 通用寄存器没有地址，通过寄存器名字来访问。 ARM一共有37个通用寄存器。 （2）特殊功能寄存器特殊功能寄存器，属于外设硬件的组成部分。使用软件编程控制某一硬件，其实就是编程读写这个硬件的特殊功能寄存器。 注意，特殊功能寄存器有地址，通过地址来访问寄存器。 （1）影子式设计注意，上图中除了Abort模式列出所有的寄存器外，其他模式只列出对应位置该模式下特有的寄存器，没有列出的寄存器，则说明和Abort模式共用。比如User模式下有自己的r13和r14寄存器，其他寄存器和Abort模式相同。这样算下来，ARM总共有 37 个寄存器，但最多只能同时存在18个寄存器。有些寄存器虽然名字相同，但是在当前模式是不可见的。比如在ARM中有6个名叫r13的寄存器，但在特定处理器模式下，只有一个r13是当前可见的，其他的r13必须切换到对应的模式才能看到。这种设计叫影子寄存器。 这样设计的好处是，当各种异常发生的时候，每种异常模式都可以保存一些重要的数据，异常处理程序完成之后返回异常前的程序时，不会破坏原有的寄存器或状态。 （2）重要的寄存器这37个寄存器都是32位长度，值得重点理解的寄存器有以下几个。 程序控制寄存器（PC，Program Control Register） 这个寄存器存放着将要执行的指令的地址，它指向哪里，CPU就会执行哪条指令，所以程序跳转时把目标代码的地址放到PC寄存器中。注意，整个CPU只有一个PC寄存器。 程序状态寄存器（CPSR，Current Program Status Register） 这个寄存器用来记录CPU的当前状态。注意，整个CPU只有一个CPSR寄存器。 程序状态保存寄存器（SPSR，Saved Program Status Register） 用来保存CPSR的，子程序返回时将SPSR赋给CPSR。注意，整个CPU有5个SPSR寄存器。 链接寄存器（LR，Link Register） 这个寄存器的主要作用如下。 一是调用子程序时，用来保存子程序返回地址（子程序返回时返回到哪个地址）。当通过bl或blx指令调用子程序时，硬件会自动将子程序返回地址保存在LR寄存器中。在子程序返回时，把LR的值复制到PC即可实现子程序返回。比如可以使用mov pc,lr完成子程序返回。 二是当异常发生时，LR中保存的值等于异常发生时PC的值减4，因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行。 程序状态寄存器（CPSR） 程序状态寄存器（CPSR）在CPU中只有一个，是32bit的，记录着CPU的当前状态。 程序状态寄存器每个bit的含义如下。 （1）bit31~28是条件位 N &#x3D; Negative result from ALUZ &#x3D; Zero result from ALUC &#x3D; ALU operation Carried outV &#x3D; ALU operation oVerflowed（2）bit27是Q位 仅ARM 5TE&#x2F;J架构支持，用来指示饱和状态。 （3）bit24是J位 仅ARM 5TE&#x2F;J架构支持，J &#x3D; 1处理器处于Jazelle状态。 （4）bit7~6是中断禁止位 I &#x3D; 1 表示禁止IRQ。F &#x3D; 1 表示禁止FIQ。（5）bit5是T位 仅ARM xT架构支持。T &#x3D; 0 表示处理器处于 ARM 状态。T &#x3D; 1 表示处理器处于 Thumb 状态。（6）bit0~4是Mode位 这是处理器模式位。 （7）总结 CPSR中各个bit位表明了CPU的某些状态信息，这些信息非常重要，和后面学到的汇编指令息息相关（比如BLE指令中的E就和CPSR中的Z标志位有关）。 CPSR中的I、F位和开中断、关中断有关。 CPSR中的mode位（bit4～bit0共5位）决定了CPU的工作模式，在uboot代码中会使用汇编进行设置。 ARM指令集ARM 存储器访问指令 ARM 处理器是冯诺依曼存储结构，程序空间、RAM 空间及IO 映射空间统一编址，除对对RAM 操作以外，对外围IO、程序数据的访问均要通过加载&#x2F;存储指令进行。 ARM 的加载&#x2F;存储指令是可以实现字、半字、无符&#x2F;有符字节操作；批量加载&#x2F;存储指令可实现一条指令加载&#x2F;存储多个寄存器的内容，大大提高效率。 LDR 和STR 加载&#x2F;存储1234567891011LDR指令用于从内存读取数据放入寄存器中；STR 指令用于将寄存器中的数据保存到内存。指令格式如下： LDR&#123;cond&#125;&#123;T&#125; Rd,&lt;地址&gt;;加载指定地址上的数据(字)，放入Rd中 STR&#123;cond&#125;&#123;T&#125; Rd,&lt;地址&gt;;存储数据(字)到指定地址的存储单元，要存储的数据在Rd中 LDR&#123;cond&#125;B&#123;T&#125; Rd,&lt;地址&gt;;加载字节数据，放入Rd中，即Rd最低字节有效，高24位清零 STR&#123;cond&#125;B&#123;T&#125; Rd,&lt;地址&gt;;存储字节数据，要存储的数据在Rd，最低字节有效其中，T 为可选后缀，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引偏移一起使用T。 LDM和STM 批量加载&#x2F;存储指令123456789101112131415161718192021222324252627282930313233343536用于在一组寄存器和一块连续的内存单元之间传输数据。LDM为加载多个寄存器，STM 为存储多个寄存器。允许一条指令传送16 个寄存器的任何子集或所有寄存器。指令格式如下： LDM&#123;cond&#125;&lt;模式&gt; Rn&#123;!&#125;,reglist&#123;^&#125; STM&#123;cond&#125;&lt;模式&gt; Rn&#123;!&#125;,reglist&#123;^&#125; LDM /STM 的主要用途是现场保护、数据复制、参数传送等。其模式有8种，如下所列：(前面4 种用于数据块的传输，后面4 种是堆栈操作)。 (1) IA：每次传送后地址加4 (2) IB：每次传送前地址加4 (3) DA：每次传送后地址减4 (4) DB：每次传送前地址减4 (5) FD：满递减堆栈 (6) ED：空递减堆栈 (7) FA：满递增堆栈 (8) EA：空递增堆栈 其中，寄存器Rn 为基址寄存器，装有传送数据的初始地址，Rn 不允许为R15;后缀“！”表示最后的地址写回到Rn中;寄存器列表reglist 可包含多于一个寄存器或寄存器范围，使用“,”分开，如&#123;R1,R2,R6-R9&#125;,寄存器排列由小到大排列；“＾”后缀不允许在用户模式呈系统模式下使用，若在LDM 指令用寄存器列表中包含有PC 时使用，那么除了正常的多寄存器传送外，将SPSR 拷贝到CPSR 中，这可用于异常处理返回；使用“＾”后缀进行数据传送且寄存器列表不包含PC时，加载/存储的是用户模式的寄存器，而不是当前模式的寄存器。 地址对准――这些指令忽略地址的位[1：0]。 批量加载/存储指令举例如下： LDMIA R0!,&#123;R3-R9&#125; ;加载R0 指向的地址上的多字数据，保存到R3～R9中，R0 值更新 STMIA R1!,&#123;R3-R9&#125; ;将R3～R9 的数据存储到R1 指向的地址上，R1值更新 STMFD SP!,&#123;R0-R7,LR&#125; ;现场保存，将R0～R7、LR入栈 LDMFD SP!,&#123;R0-R7,PC&#125;^;恢复现场，异常处理返回 SWP 寄存器和存储器交换指令1234567891011SWP指令用于将一个内存单元（该单元地址放在寄存器Rn中）的内容读取到一个寄存器Rd中，同时将另一个寄存器Rm 的内容写入到该内存单元中。使用SWP 可实现信号量操作, 指令格式如下： SWP&#123;cond&#125;&#123;B&#125; Rd,Rm,[Rn] 其中，B 为可选后缀，若有B，则交换字节，否则交换32 位字：Rd 为数据从存储器加载到的寄存器;Rm的数据用于存储到存储器中，若Rm 与Rn 相同，则为寄存器与存储器内容进行交换;Rn 为要进行数据交换的存储器地址，Rn 不能与Rd 和Rm 相同。 SWP 指令举例如下： SWP R1,R1,[R0] ; 将R1 的内容与R0 指向的存储单元的内容进行交换 SWP R1,R2,,[R0] ; 将R0 指向的存储单元内容读取一字节数据到R1中(高24 位清零),并将R2 的内容写入到该内存单元中(最低字节有效) ARM 数据处理指令 数据处理指令大致可分为3 类： （1）数据传送指令（如MOV、MVN） （2）算术逻辑运算指令（如ADD,SUM,AND） （3）比较指令（如CMP、TST）。 数据处理指令只能对寄存器的内容操作。 所有ARM 数据处理指令均可选择使用S 后缀，以影响状态标志。比较指令CMP、CMN、TST和TEQ不需要后缀S，它们会直接影响状态标志。 MOV 数据传送指令123456789101112将立即数或寄存器(operant2)传送到目标寄存器Rd，可用于移位运算等操作。指令格式如下： MOV&#123;cond&#125;&#123;S&#125; Rd,operand2 MOV 指令举例如下： MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2，并影响标志位 MOV PC,LR ;PC=LR ，子程序返回 MVN 数据非传送指令12345678将立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)。指令格式如下： MVN&#123;cond&#125;&#123;S&#125; Rd,operand2 MVN 指令举例如下： MVN R1,#0xFF ;R1=0xFFFFFF00 MVN R1,R2 ;将R2 取反，结果存到R1 加减运算指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651. ADD 加法运算指令将operand2 数据与Rn 的值相加，结果保存到Rd 寄存器。格式如下： ADD&#123;cond&#125;&#123;S&#125; Rd,Rn,operand2 ADD 指令举例如下： ADDS R1,R1,#1 ;R1=R1+1 ADD R1,R1,R2 ;R1=R1+R2 ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2 2. SUB 减法运算指令用寄存器Rn 减去operand2，结果保存到Rd 中，格式如下： SUB&#123;cond&#125;&#123;S&#125; Rd,Rn,operand2 SUB 指令举例如下： SUBS R0,R0,#1 ;R0=R0-1 SUBS R2,R1,R2 ;R2=R1-R2 SUB R6,R7,#0x10 ;R6=R7-0x10 3. RSB 逆向减法指令用寄存器operand2 减法Rn，结果保存到Rd 中，格式如下： RSB&#123;cond&#125;&#123;S&#125; Rd,Rn,operand2 SUB 指令举例如下： RSB R3,R1,#0xFF00 ;R3=0xFF00-R1 RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3 RSB R0,R1,#0 ;R0=-R1 4. ADC 带进位加法指令将operand2 的数据与Rn 的值相加，再加上CPSR中的C 条件标志位。结果保存到Rd 寄存器。指令格式如下： ADC&#123;cond&#125;&#123;S&#125; Rd,Rn,operand2 ADC 指令举例如下： ADDS R0,R0,R2 ADC R1,R1,R3 ;使用ADC 实现64 位加法，(R1、R0)=(R1、R0)+（R3、R2） 5. SBC 带进位减法指令用寄存器Rn 减去operand2，再减去CPSR 中的C条件标志位的非（即若C 标志清零，则结果减去1），结果保存到Rd 中。指令格式如下： SCB&#123;cond&#125;&#123;S&#125;Rd,Rn,operand2 SBC 指令举例如下： SUBS R0，R0，R2 SBC R1，R1，R3 ;使用SBC 实现64 位减法，(R1,R0)-(R3,R2) 6. RSC 带进位逆向减法指令用寄存器operand2 减去Rn，再减去CPSR 中的C条件标志位，结果保存到Rd 中。指令格式如下： RSC&#123;cond&#125;&#123;S&#125; Rd,Rn,operand2 RSC 指令举例如下： RSBS R2,R0,#0 RSC R3,R1,#0 ;使用RSC 指令实现求64 位数值的负数 逻辑操作指令123456789101112131415161718192021222324252627282930313233343536373839404142431. AND 逻辑与指令将operand2 值与寄存器Rn 的值按位作逻辑与操作，结果保存到Rd中。指令格式如下： AND&#123;cond&#125;&#123;S&#125; Rd,Rn,operand2 AND 指令举例如下： ANDS R0,R0,#x01 ;R0=R0&amp;0x01，取出最低位数据 AND R2,R1,R3 ;R2=R1&amp;R3 2. ORR 逻辑或指令将operand2 的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。指令格式如下： ORR&#123;cond&#125;&#123;S&#125; Rd,Rn,operand2 ORR 指令举例如下： ORR R0,R0,#x0F ;将R0 的低4 位置1 MOV R1,R2,LSR #4 ORR R3,R1,R3,LSL #8 ;使用ORR 指令将近R2 的高8位数据移入到R3 低8 位中 3. EOR 逻辑异或操作指令将operand2 的值与寄存器Rn 的值按位作逻辑异或操作，结果保存到Rd中。指令格式如下： EOR&#123;cond&#125;&#123;S&#125;Rd,Rn,operand2 EOR 指令举例如下： EOR R1,R1,#0x0F ;将R1 的低4 位取反 EOR R2,R1,R0 ;R2=R1^R0 EORS R0,R5,#0x01 ;将R5 和0x01 进行逻辑异或，结果保存到R0，并影响标志位 4. BIC 位清除指令将寄存器Rn 的值与operand2 的值的反码按位作逻辑与操作，结果保存到Rd中。指令格式如下： BIC&#123;cond&#125;&#123;S&#125;Rd,Rn,operand2 BIC 指令举例如下： BIC R1,R1,#0x0F ;将R1 的低4 位清零，其它位不变 BIC R1,R2,R3 ;将拭的反码和R2 相逻辑与，结果保存到R1 比较指令123456789101112131415161718191. CMP 比较指令,指令使用寄存器Rn 的值减去operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下： CMP&#123;cond&#125; Rn,operand2 CMP 指令举例如下： CMP R1,#10 ;R1 与10 比较，设置相关标志位 CMP R1,R2 ;R1 与R2 比较，设置相关标志位 CMP 指令与SUBS 指令的区别在于CMP 指令不保存运算结果。在进行两个数据大小判断时，常用CMP指令及相应的条件码来操作。 2. CMN 负数比较指令,指令使用寄存器Rn 与值加上operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行，指令格式如下： CMN&#123;cond&#125; Rn,operand2 CMN R0,#1 ;R0+1,判断R0 是否为1 的补码，若是Z 置位 CMN 指令与ADDS 指令的区别在于CMN 指令不保存运算结果。CMN指令可用于负数比较，比如CMNR0，#1 指令则表示R0 与-1 比较，若R0 为-(即1 的补码)，则Z 置位，否则Z复位。 乘法指令 ARM7TDMI(-S)具有32×32 乘法指令、32×32 乘加指令、32×32结果为64 位的乘法指令。 1234567891011121314151. MUL 32 位乘法指令, 指令将Rm 和Rs 中的值相乘，结果的低32 位保存到Rd中。指令格式如下： MUL&#123;cond&#125;&#123;S&#125; Rd,Rm,Rs MUL 指令举例如下： MUL R1,R2,R3 ;R1=R2×R3 MULS R0,R3,R7 ;R0=R3×R7，同时设置CPSR 中的N位和Z 位 2. MLA 32 位乘加指令, 指令将Rm 和Rs 中的值相乘，再将乘积加上第3 个操作数，结果的低32位保存到Rd 中。指令格式如下： MLA&#123;cond&#125;&#123;S&#125; Rd,Rm,Rs,Rn MLA 指令举例如下： MLA R1,R2,R3,R0 ;R1=R2×R3+10 ARM 跳转指令 两种方式可以实现程序的跳转： （1）使用跳转指令直接跳转，跳转指令有跳转指令B，带链接的跳转指令BL ，带状态切换的跳转指令BX。 （2）直接向PC 寄存器赋值实现跳转。 1234567891011121314151617181920212223242526272829301. B 跳转指令, 跳转到指定的地址执行程序。 B&#123;cond&#125; label 举例如下： B WAITA ;跳转到WAITA 标号处 B 0x1234 ;跳转到绝对地址0x1234 处 跳转到指令B 限制在当前指令的±32Mb 的范围内。 2. BL 带链接的跳转指令, 指令将下一条指令的地址拷贝到R14(即LR)链接寄存器中，然后跳转到指定地址运行程序。 BL&#123;cond&#125; label 举例如下： BL DELAY 跳转指令B 限制在当前指令的±32MB 的范围内。BL 指令用于子程序调用。 3. BX 带状态切换的跳转指令, 跳转到Rm 指定的地址执行程序，若Rm 的位[0]为1，则跳转时自动将CPSR 中的标志T 置位，即把目标地址的代码解释为Thumb代码;若Rm 的位[0]为0，则跳转时自动将CPSR 中的标志T 复位，即把目标地址的代码解释为ARM代码。指令格式如下： BX&#123;cond&#125; Rm 举例如下： ADRL R0,ThumbFun+1 BX R0 ;跳转到R0 指定的地址，并根据R0 的最低位来切换处理器状态 4. BLX, BLX目标地址：跳转，改变状态及保存PC值 ARM 协处理器指令 ARM 支持协处理器操作，协处理器的控制要通过协处理器命令实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011. CDP 协处理器数据操作指令ARM 处理器通过CDP 指令通知ARM 协处理器执行特定的操作。该操作由协处理器完成，即对命令的参数的解释与协处理器有关，指令的使用取决于协处理器。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下： CDP&#123;cond&#125;coproc,opcodel,CRd,CRn,CRm&#123;,opcode2&#125; 其中： coproc 指令操作的协处理器名。标准名为pn,n 为0～15。 opcodel 协处理器的特定操作码。 CRd 作为目标寄存器的协处理器寄存器。 CRN 存放第1 个操作数的协处理器寄存器。 CRm 存放第2 个操作数的协处理器寄存器。 Opcode2 可选的协处理器特定操作码。 CDP 指令举例如下： CDP p7,0,c0,c2,c3,0 ;协处理器7 操作，操作码为0，可选操作码为0 CDP p6,1,c3,c4,c5 ;协处理器操作，操作码为12. LDC 协处理器数据读取指令LDC指令从某一连续的内存单元将数据读取到协处理器的寄存器中。协处理器数据的数据的传送，由协处理器来控传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下： LDC&#123;cond&#125;&#123;L&#125; coproc,CRd,&lt;地址&gt; 其中： L 可选后缀，指明是长整数传送。 coproc 指令操作的协处理器名。标准名为pn，n 为0～15 CRd 作为目标寄存的协处理器寄存器。 &lt;地址&gt; 指定的内存地址 LDC 指令举例如下： LDC p5,c2,[R2,#4];读取R2+4指向的内存单元的数据，传送到协处理器p5的c2寄存器中 LDC p6,c2,[R1] ;读取是指向的内存单元的数据，传送到协处理器p6的c2 寄存器中 3. STC 协处理器数据写入指令STC指令将协处理器的寄存器数据写入到某一连续的内存单元中。进行协处理器数据的数据传送，由协处理器来控制传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下： STC&#123;cond&#125;&#123;L&#125; coproc,CRd,&lt;地址&gt; 其中： L 可选后缀，指明是长整数传送。 coproc 指令操作的协处理器名。标准名为pn，n 为0～15 CRd 作为目标寄存的协处理器寄存器。 &lt;地址&gt; 指定的内存地址 STC 指令举例如下： STC p5,c1,[R0] STC p5,c1,[Ro,#-0x04] 4. MCR ARM寄存器到协处理器寄存器的数据传送指令MCR 指令将ARM 处理器的寄存器中的数据传送到协处理器的寄存器中。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下： MCR&#123;cond&#125;coproc,opcodel,Rd,CRn,CRm&#123;,opcode2&#125; 其中：coproc 指令操作的协处理器名。标准名为pn，n 为0～15。 cpcodel 协处理器的特定操作码。 RD 作为目标寄存器。 CRn 存放第1 个操作数的协处理器寄存器 CRm 存放第2 个操作数的协处理器寄存器。 Opcode2 可选的协处理器特定操作码。 MCR 指令举例如下： MCR p6,2,R7,c1,c2, MCR P7,0,R1,c3,c2,1, 5. MRC 协处理器寄存器到ARM寄存器到的数据传送指令MRC 指令将协处理器寄存器中的数据传送到ARM 处理器的寄存器中。若协处理器不能成功地执行该操作。将产生未定义异常中断。指令格式如下： MRC &#123;cond&#125;coproc,opcodel,Rd,CRn,CRm&#123;,opcode2&#125; 其中：coproc 指令操作的协处理器名。标准名为pn，n为0～15。 opcodel 协处理器的特定操作码。 Rd 作为目标寄存器。 CRn 存放第1 个操作数的协处理器寄存器。 CRm 存放第2 个操作数的协处理器寄存器。 opcode2 可选的协处理器特定操作码。 MRC 指令举例如下： MRC p5,2,R2,c3,c2 MRC p7,0,R0,c1,c2,1 ARM 杂项指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511. SWI 软中断指令, SWI 指令用于产生软中断，从而实现在用户模式变换到管理模式，CPSR保存到管理模式的SPSR中，执行转移到SWI 向量，在其它模式下也可使用SWI 指令，处理同样地切换到管理模式。指令格式如下： SWI&#123;cond&#125; immed_24 其中：immed_24 24 位立即数，值为0～16777215 之间的整数。 SWI 指令举例如下： SWI 0 ;软中断，中断立即数为0 SWI 0x123456 ;软中断，中断立即数为0x123456 2. MRS 读状态寄存器指令, 在ARM 处理器中，只有MRS 指令可以状态寄存器CPSR或SPSR读出到通用寄存器中。指令格式如下： MRS&#123;cond&#125; Rd ,psr 其中： Rd 目标寄存器。Rd 不允许为R15。 psr CPSR 或SPSR MRS指令举例如下： MRS R1,CPSR ;将CPSR状态寄存器读取，保存到R1 中 MRS R2,SPSR ;将SPSR状态寄存器读取，保存到R2 中3. MSR 写状态寄存器指令, 在ARM 处理器中。只有MSR 指令可以直接设置状态寄存器CPSR或SPSR。指令格式如下： MSR&#123;cond&#125; psr_fields,#immed_8r MSR&#123;cond&#125; psr_fields,Rm 其中： psr CPSR 或SPSR fields 指定传送的区域。Fields 可以是以下的一种或多种(字母必须为小写)： c 控制域屏蔽字节(psr[7…0]) x 扩展域屏蔽字节(psr[15…8]) s 状态域屏蔽字节(psr[23。…16]) f 标志域屏蔽字节(psr[31…24]) immed_8r 要传送到状态寄存器指定域的立即数，8 位。 Rm 要传送到状态寄存器指定域的数据的源寄存器。 MSR 指令举例如下： MSR CPSR_c,#0xD3 ;CPSR[7…0]=0xD3，即切换到管理模式。 MSR CPSR_cxsf,R3 ;CPSR=R3 ARM 伪指令 ARM 伪指令不是ARM 指令集中的指令，只是为了编程方便编译器定义了伪指令，使用时可以像其它ARM 指令一样使用，但在编译时这些指令将被等效的ARM 指令代替。 ARM伪指令有四条，分别为ADR 伪指令、ADRL 伪指令、LDR 伪指令和NOP 伪指令。 1234567891011121314151617181920212223242526271. ADR 小范围的地址读取伪指令ADR 指令将基于PC 相对偏移的地址值读取到寄存器中。在汇编编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD 指令或SUB 指令来实现该ADR 伪指令的功能，若不能用一条指令实现，则产生错误，编译失败。 ADR 伪指令格式如下： ADR&#123;cond&#125; register,exper 其中：register 加载的目标寄存器。 exper 地址表达式。当地址值是非字地齐时，取值范围-255～255 字节之间；当地址是字对齐时，取值范围-1020～1020字节之间。 对于基于PC 相对偏移的地址值时，给定范围是相对当前指令地址后两个字处(因为ARM7TDMI为三级流水线)。 ADR 伪指令举例如下： LOOP MOV R1, #0xF0 … ADR R2, LOOP ;将LOOP 的地址放入R2 ADR R3, LOOP+4 2. NOP 空操作伪指令NOP 伪指令在汇编时将会被代替成ARM 中的空操作，比如可能为“MOV R0, R0”指令等，NOP 伪指令格式如下： NOP NOP","categories":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"ARM架构","slug":"ARM架构","permalink":"http://1nameccc.github.io/tags/ARM%E6%9E%B6%E6%9E%84/"}],"author":"coucou"},{"title":"单片机——蓝桥杯51","slug":"3-7-单片机-蓝桥杯51/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:09:42.719Z","comments":true,"path":"2023/08/01/3-7-单片机-蓝桥杯51/index/","permalink":"http://1nameccc.github.io/2023/08/01/3-7-%E5%8D%95%E7%89%87%E6%9C%BA-%E8%93%9D%E6%A1%A5%E6%9D%AF51/index/","excerpt":"速记","text":"速记 初始化12345678910111213141516171819202122232425262728293031323334353637#include &lt;STC15F2K60S2.H&gt;#include &quot;intrins.h&quot;#define u8 unsigned char#define u32 unsigned intsbit S7 = P3^0;sbit S6 = P3^1;sbit S5 = P3^2;sbit S4 = P3^3;unsigned char show_dat[] = &#123; 0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90, 0xff, 0xc1, 0x1e&#125;;void set_port(u8 port, u8 dat)&#123; P2 = (P2 &amp; 0x1f) | port; P0 = dat; P2 = P2 &amp; 0x1f;&#125;void allinit()&#123; set_port(0x80, 0xff); set_port(0xa0, 0x00); set_port(0xc0, 0xff); set_port(0xe0, 0xff);&#125;void key_proc()&#123; &#125;void led_proc()&#123; &#125;void disp_proc()&#123; &#125; 显示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;STC15F2K60S2.H&gt;#include &quot;show.h&quot;u8 data_adc[] = &#123; 0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90, 0xff&#125;;void Delay1ms() //@12.000MHz&#123; unsigned char i, j; i = 12; j = 169; do &#123; while (--j); &#125; while (--i);&#125;void show(u8 yi, u8 er, u8 san, u8 si, u8 wu, u8 liu, u8 qi, u8 ba)&#123; P2 = 0xc0; P0 = 0x01; P2 = 0xe0; P0 = yi; Delay1ms(); P2 = 0xc0; P0 = 0x02; P2 = 0xe0; P0 = er; Delay1ms(); P2 = 0xc0; P0 = 0x04; P2 = 0xe0; P0 = san; Delay1ms(); P2 = 0xc0; P0 = 0x08; P2 = 0xe0; P0 = si; Delay1ms(); P2 = 0xc0; P0 = 0x10; P2 = 0xe0; P0 = wu; Delay1ms(); P2 = 0xc0; P0 = 0x20; P2 = 0xe0; P0 = liu; Delay1ms(); P2 = 0xc0; P0 = 0x40; P2 = 0xe0; P0 = qi; Delay1ms(); P2 = 0xc0; P0 = 0x80; P2 = 0xe0; P0 = ba; Delay1ms(); P2 = 0x00;&#125; AT24c0212345678910111213141516171819202122232425262728293031323334353637/* writecommand 0xa0 readcommand 0xa1*/// 读一个字节unsigned char read24c02(unsigned char addr)&#123; unsigned char dat; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(addr); IIC_WaitAck(); IIC_Start(); IIC_SendByte(0xa1); IIC_WaitAck(); dat = IIC_RecByte(); IIC_SendAck(1); IIC_Stop(); return dat;&#125;// 写一个字节void write24c02(unsigned char addr, unsigned char dat)&#123; IIC_Start(); IIC_SendByte(0xa0); IIC_WaitAck(); IIC_SendByte(addr); IIC_WaitAck(); IIC_SendByte(dat); IIC_WaitAck(); IIC_Stop();&#125; AD&#x2F;DA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* writecommand 0x90 readcommand 0x91 set_pcf(0x03); dac_dat = read_pcf(); dac_dat = dac_dat * (5.0 / 255);*/// 选择通道, 通道1是光敏，通道3是电阻void seletPcf(unsigned char channel)&#123; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(channel); IIC_WaitAck(); IIC_Stop();&#125;// ADC输入unsigned char readChannel()&#123; unsigned int dat; IIC_Start(); IIC_SendByte(0x91); IIC_WaitAck(); dat = IIC_RecByte(); IIC_SendAck(1); IIC_Stop(); return dat;&#125;// DAC输出void out_channel(unsigned char dat)&#123; IIC_Start(); IIC_SendByte(0x90); IIC_WaitAck(); IIC_SendByte(0x40); IIC_WaitAck(); IIC_SendByte(dat); IIC_WaitAck(); IIC_Stop();&#125; DS1302-时间123456789101112131415161718/*显示时间的时候要特别注意，BCD码转10！！！应当为16进制*/void set_time(unsigned char hour, unsigned char min, unsigned char sec)&#123; Write_Ds1302_Byte(0x8e, 0x00); Write_Ds1302_Byte(0x80, sec); Write_Ds1302_Byte(0x82, min); Write_Ds1302_Byte(0x84, hour); Write_Ds1302_Byte(0x8e, 0x80);&#125;void read_time()&#123; time[2] = Read_Ds1302_Byte(0x85); time[1] = Read_Ds1302_Byte(0x83); time[0] = Read_Ds1302_Byte(0x81);&#125; onewire-温度123456789101112131415161718192021222324252627282930/*特别注意！！！驱动里的延时函数！！！void Delay_OneWire(unsigned int t) //STC89C52RC&#123; t = t * 10; while(t--);&#125;*/float read_tmp()&#123; float tmp; unsigned char h_dat, l_dat; unsigned int temp; init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0x44); // 开始转化 init_ds18b20(); Write_DS18B20(0xcc); Write_DS18B20(0xbe); l_dat = Read_DS18B20(); h_dat = Read_DS18B20(); temp = (h_dat &lt;&lt; 8) | l_dat; tmp = temp / 16.0; return tmp;&#125; 超声波测距123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 超声波sbit TX = P1^0;sbit RX = P1^1;u32 distant; void Delay12us() //@12.000MHz&#123; unsigned char i; _nop_(); _nop_(); i = 33; while (--i);&#125;void send_wave()&#123; u8 i = 8; while(i--)&#123; TX = 1; Delay12us(); TX = 0; Delay12us(); &#125;&#125;void Timer1Init(void) //1微秒@12.000MHz&#123; TMOD &amp;= 0x0F; //设置定时器模式 TL1 = 0x00; //设置定时初值 TH1 = 0x00; //设置定时初值 TF1 = 0; //清除TF1标志 //TR1 = 1; //定时器1开始计时&#125;void test_dis()&#123; send_wave(); TR1 = 1; //定时器1开始计时 while(RX == 1 &amp;&amp; TF1 == 0); TR1 = 0; if(TF1 == 0)&#123; //distant = ((TH1 &lt;&lt; 8) | TL1) * 340 / 2 / 10000; distant = ((TH1 &lt;&lt; 8) | TL1) * 0.017; liu = data_pros[distant / 100 % 10]; qi = data_pros[distant / 10 % 10]; ba = data_pros[distant % 10]; show(0xff, 0xff,0xff, 0xff, 0xff, liu, qi, ba); &#125;else&#123; show(0x00, 0xff,0xff, 0xff, 0xff, 0xff, 0xff, 0xff); TF1 = 0; &#125; TL1 = 0; TH1 = 0;&#125; NE555123456789101112131415161718192021222324252627282930313233343536373839404142/*定时器定时1s，计数多少次，即频率特别注意： TL0 = 0xff; //设置定时初始值 TH0 = 0xff; //设置定时初始值*/void Timer0_Init(void) //1毫秒@12.000MHz&#123; AUXR |= 0x80; //定时器时钟1T模式 TMOD = 0x04; //设置定时器模式 TL0 = 0xff; //设置定时初始值 TH0 = 0xff; //设置定时初始值 TF0 = 0; //清除TF0标志 TR0 = 1; //定时器0开始计时 ET0 = 1; EA = 1;&#125;void time0_isr() interrupt 1&#123; timer0_cnt++;&#125;void Timer1_Init(void) //1毫秒@12.000MHz&#123; AUXR |= 0x40; //定时器时钟1T模式 TMOD = 0x04; //设置定时器模式 TL1 = 0x20; //设置定时初始值 TH1 = 0xD1; //设置定时初始值 TF1 = 0; //清除TF1标志 TR1 = 1; //定时器1开始计时 ET1 = 1; EA = 1;&#125;void time1_isr() interrupt 3&#123; timer1_cnt++; if(timer1_cnt == 1000)&#123; f_dat = timer0_cnt; timer1_cnt = 0; timer0_cnt = 0; &#125;&#125; timer123456void time0_isr() interrupt 1&#123; &#125;void time1_isr() interrupt 3&#123; &#125; key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859sbit R0 = P3^2;sbit R1 = P3^3;sbit _R0 = P3^0;sbit _R1 = P3^1;sbit L0 = P3^4;sbit L1 = P3^5;sbit _L0 = P4^2;sbit _L1 = P4^4;void key_proc()&#123; R0 = R1 = _R0 = _R1 = 1; L0 = L1 = _L0 = _L1 = 1; L0 = 0; if(R0 == 0)&#123; // S17， 数据加 Delay10ms();while(R0 == 0);Delay10ms(); if(set_adc_flag) adc_para += 0.5; if(adc_para &gt; 5) adc_para = 0; error_flag = 0; &#125; if(R1 == 0)&#123; // S16 数据减 Delay10ms();while(R1 == 0);Delay10ms(); if(set_adc_flag) adc_para -= 0.5; if(adc_para &lt; 0) adc_para = 5; error_flag = 0; &#125; if(_R0 == 0)&#123;Delay10ms();while(_R0 == 0);Delay10ms();cnt++;&#125; if(_R1 == 0)&#123;Delay10ms();while(_R1 == 0);Delay10ms();cnt++;&#125; R0 = R1 = _R0 = _R1 = 1; L0 = L1 = _L0 = _L1 = 1; L1 = 0; if(R0 == 0)&#123; // S13，清零 Delay10ms();while(R0 == 0);Delay10ms(); if(cnt_flag) adc_cnt = 0; error_flag = 0; &#125; if(R1 == 0)&#123; // S12，界面 Delay10ms();while(R1 == 0);Delay10ms(); &#125; if(_R0 == 0)&#123;Delay10ms();while(_R0 == 0);Delay10ms();cnt++;&#125; if(_R1 == 0)&#123;Delay10ms();while(_R1 == 0);Delay10ms();cnt++;&#125; R0 = R1 = _R0 = _R1 = 1; L0 = L1 = _L0 = _L1 = 1; _L0 = 0; if(R0 == 0)&#123;Delay10ms();while(R0 == 0);Delay10ms();cnt++;&#125; if(R1 == 0)&#123;Delay10ms();while(R1 == 0);Delay10ms();cnt++;&#125; if(_R0 == 0)&#123;Delay10ms();while(_R0 == 0);Delay10ms();cnt++;&#125; if(_R1 == 0)&#123;Delay10ms();while(_R1 == 0);Delay10ms();cnt++;&#125; R0 = R1 = _R0 = _R1 = 1; L0 = L1 = _L0 = _L1 = 1; _L1 = 0; if(R0 == 0)&#123;Delay10ms();while(R0 == 0);Delay10ms();cnt++;&#125; if(R1 == 0)&#123;Delay10ms();while(R1 == 0);Delay10ms();cnt++;&#125; if(_R0 == 0)&#123;Delay10ms();while(_R0 == 0);Delay10ms();cnt++;&#125; if(_R1 == 0)&#123;Delay10ms();while(_R1 == 0);Delay10ms();cnt++;&#125;&#125;","categories":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"蓝桥杯51","slug":"蓝桥杯51","permalink":"http://1nameccc.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF51/"}],"author":"coucou"},{"title":"单片机——汇编","slug":"3-6-单片机-汇编语言/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T01:08:58.714Z","comments":true,"path":"2023/08/01/3-6-单片机-汇编语言/index/","permalink":"http://1nameccc.github.io/2023/08/01/3-6-%E5%8D%95%E7%89%87%E6%9C%BA-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/index/","excerpt":"汇编笔记","text":"汇编笔记","categories":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"汇编","slug":"汇编","permalink":"http://1nameccc.github.io/tags/%E6%B1%87%E7%BC%96/"}],"author":"coucou"},{"title":"网络协议——常见协议","slug":"4-1-网络协议-常见协议/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:09:51.572Z","comments":true,"path":"2023/08/01/4-1-网络协议-常见协议/index/","permalink":"http://1nameccc.github.io/2023/08/01/4-1-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/index/","excerpt":"网络协议","text":"网络协议 TCP&#x2F;UDP 类型 特点 性能 应用过场景 首部字节 TCP 面向连接、可靠、字节流 传输效率慢、所需资源多 文件、邮件传输 20-60 UDP 无连接、不可靠、数据报文段 传输效率快、所需资源少 语音、视频、直播 8个字节 TCP三次握手和四次挥手 原因为了防止建立重复的连接而损耗资源或造成其他问题 第一次握手第一次握手由客户端向服务器 发出：客户端发送一个TCP数据报，其中，TCP分组的源端口为客户端发起通信建立的进程端口，而目的端口为服务器处理请求的进程端口号，比如80端口。在表示建立连接的TCP分组中，SYN标志位为被置1，则告知服务器发送该分组的目的是请求建立连接，并且当SYN置1时，该分组中的seq字段发送的是初始序列号cilent_isn，初始序列号的取值方案有多种，一般取随机值。 第二次握手第二次握手由服务器向客户端发出：服务器在成功接收了客户端第一次握手发送的分组后，首先需要解析收到的TCP分组，发现SYN置1后，得知这个客户端发送分组的目的是为了建立连接，在确认完毕分组信息后，服务器也会向客户端发送一个TCP分组来代表第二次握手。 这个由服务器发送的TCP分组包含以下内容： 首先将代表建立连接目的的SYN标志位同样置1然后随机地产生服务器端的初始序列号 server_isn在seq字段中发送同时将代表累计确认接收字节位数的ACK确认号发送，该确认号ACK的值为客户端发送的TCP分组中的初始序列号+1,即cilent_isn+1。也就是发送服务器期望接收的下一个字节序号。第三次握手第三次握手由客户端向服务器发出：客户端在接收到服务器第二次握手的回复之后，同样会接收来自于服务器的TCP分组并进行解读：由SYN为1解读该TCP分组的目的是继续建立连接，由分组中的ACK确认号了解到服务器已经成功接收了前cilent_isn个字节的内容，并期望接收第cilent_isn+1个字节的字节序号，同时累计确认来自服务器的初始序列号。并发送最后一个TCP分组给服务器来完成第三次握手。 第一次挥手： 客户端因为不再有数据发送给服务器，所以向服务器发送FIN报文表示想要关闭连接，不会再发送数据了。同时包含客户端的报文序号M 第二次挥手： 服务器在接收了来自客户端的FIN报文后，得知客户端不再发送数据，将要关闭连接。但是，此时服务器端获取还有部分数据没有回传给客户端，服务器可能还要向客户端发送一部分数据才能关闭连接。所以服务器不会立马同意关闭连接，而是先发送表示确认信息的ACK报文，该ACK报文中包含了值为M+1的确认号。 第三次挥手： 在服务器端完成向客户端传送最后的数据后，此时不再有数据需要传输了。那么服务器也准备关闭连接，所以向客户端发送表示关闭连接的FIN报文，报文中包含了服务器端的序号N 第四次挥手： 在客户端也收到了服务器端发送的FIN报文之后，得知服务器端也可以关闭连接了，此时再向服务器发送最后一次确认报文ACK，使连接成功关闭，ACK报文中的确认号为N+1 UDP 格式 源端口号：表示数据从哪里发送 目的端口号：表示数据要发送到哪里区 16位UDP长度：表示整个数据报（UDP首部+UDP数据）的最大长度 16位UDP校验和：检测数据是否被破坏，如果UDP报文校验和检测出错，就会直接丢弃 特点 无连接 不可靠 面向数据报 HTTP HTTP (全称为 “超文本传输协议”) 是一种应用非常广泛的应用层协议。 tcp协议与http协议 从应用领域来说，tcp协议主要用以数据传输控制，而http协议主要用于应用层面的数据交互，本质上两者没有可比性。http协议属于应用层协议，是建立在tcp协议的基础上的，http协议以客户端请求和服务端应答为标准，浏览器通常为客户端，而web服务器称之为服务端；客户端打开任意一个端口向服务端的指定端口发起http请求，首先是发起tcp三次握手，tcp三次握手的目的是建立可靠的数据连接通道，tcp三次握手建立完毕，进行http数据交互，如下图： http原理 客户端浏览器向服务器发起请求request，服务器收到request后进行处理，会产生响应的response信息返回给浏览器，客户端浏览器收到服务器返回的response信息，会对信息进行解析处理，最终用户看到浏览器展示web服务器的网页内容，客户端发起请求request，服务器响应response； request消息分为3个部分：request line ，request header、空行、body；response消息分为3个部分： response line ，response header，空行、body； request line，包含三部分：请求方法GET方法、请求 URI、http 协议版本；request header一般包括服务器主机ip，User-Agent表示用户使用的代理软件，一般是指浏览器；空行用来表示请求头结束了；body，报文主体，可以添加任意的其他数据，注意：get方法的body默认为空，post方法的body才有数据； response line ，响应行，包含了协议版本，状态码和状态信息，200就是状态码，ok就是状态消息；response header，响应头，包含响应时间，服务主机类型等附加信息；空行用来表示响应头结束了；响应的报文主体body就是返回给客户端的网页数据； 下面我们来使用curl命令来看一下request消息和response信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950curl -v http://192.168.43.226/index.html #先启动nginx，再写这条命令执行* Trying 192.168.43.226...* tcp_NODELAY set* Connected to 192.168.43.226 (192.168.43.226) port 80 (#0)&gt; GET /index.html http/1.1 #这一行就是请求行request line，包含三部分：请求方法GET方法、请求 URI、http 协议版本&gt; Host: 192.168.43.226 #请求头request header，请求头包括服务器主机IP，User-Agent表示用户使用的代理软件，一般是&gt; User-Agent: curl/7.61.1 # 指浏览器&gt; Accept: */*&gt; #这一行空行通过回车符换行符告诉web服务器请求头结束&gt; #这里是body消息，但因为GET方法的body默认为空，所以这里没有显示&lt; http/1.1 200 OK #response line ，响应行，包含了协议版本，状态码和状态信息，200就是状态码，ok就是状态消息&lt; Server: nginx/1.18.0 #response header，响应头，包含响应时间，服务主机类型等附加信息&lt; Date: Wed, 19 May 2021 02:27:09 GMT&lt; Content-Type: text/html&lt; Content-Length: 724&lt; Last-Modified: Sun, 09 May 2021 08:11:51 GMT&lt; Connection: keep-alive&lt; ETag: &quot;60979947-2d4&quot;&lt; Accept-Ranges: bytes&lt; #空行，表示response header结束&lt;!DOCTYPE html&gt; #下面就是响应的报文主体body&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt; 1.go for it! just do it!&lt;/p&gt;&lt;p&gt; 2.better late than never.&lt;/p&gt;&lt;p&gt; 3.Don&#x27;t give up and don&#x27;t give in. &lt;/p&gt;&lt;p&gt; 4.one today is worth two tomorrows.&lt;/p&gt;&lt;p&gt; 5.a bold attempt is half success.&lt;/p&gt;&lt;p&gt; --from web01_port80 server &lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1、用户在浏览器输入访问地址：https://www.baidu.com2、浏览器请求DNS进行域名解析，从而得到域名对应的IP地址3、浏览器将端口号（默认80）从访问地址中解析出来4、浏览器通过解析出来的IP和端口号与服务器之间进行tcp 3次握手建立一条可靠的tcp连接5、3次握手建立好tcp连接后，浏览器向服务器发送一条http请求报文6、服务器响应并读取浏览器的请求信息，然后返回响应报文7、服务器关闭http连接，关闭tcp连接，浏览器显示访问内容到网页上 统一资源定位符URL URL由三部分组成：资源类型、存放资源的主机域名、资源文件名也可认为由4部分组成：协议、主机、端口、路径URL的一般语法格式为：protocol :&#x2F;&#x2F; hostname[:port] &#x2F; path &#x2F; [;parameters][?query-string]#fragment protocol（协议）：指定使用的传输协议，下表列出 protocol 属性的有效方案名称。 最常用的是http协议，它也是WWW中应用最广的协议，还有ftp协议等，ftp 通过 ftp访问资源，格式 ftp:&#x2F;&#x2F;；hostname（主机名）：是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址，有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）；port（端口号）：整数，可选，省略时使用服务的默认端口，各种传输协议都有默认的端口号，如http的默认端口为80；path（路径）：由零或多个“&#x2F;”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址；parameters（参数）：这是用于指定特殊参数的可选项；query(查询)：可选，用于给动态网页（如使用CGI、ISAPI、PHP&#x2F;JSP&#x2F;ASP&#x2F;ASP.NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“&#x3D;”符号隔开；fragment（信息片断）：字符串，用于指定网络资源中的片断；例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释； http请求方法(最常用) GET : 客户端请求指定资源信息，服务器返回指定资源 注意：get方法是没有请求报文主体的，post方法才有 POST : 将客户端的数据提交到服务器，例如：注册表单 HTTP &amp; SOCKET概述 应用层：HTTP协议，主要解决如何包装数据； 传输层： TCP协议、TPC&#x2F;IP协议； 网络层： IP 协议 socket则是对TCP&#x2F;IP协议的封装和应用，Socket本身并不是协议而是一个调用接口，通过Socket才能使用TCP&#x2F;IP协议。实际上，Socket跟TCP&#x2F;IP协议没有必然的联系。 Socket的出现只是使得程序员更方便地使用TCP&#x2F;IP协议栈而已，从而形成了最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等。 关于TCP &#x2F;IP和HTTP协议的关系，网络有一段比较容易理解的介绍： “我们在传输数据时，可以只使用（传输层）TCP&#x2F;IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装 HTTP 文本信息，然后使用TCP&#x2F;IP做传输层协议将它发到网络上。” TCP连接 建立一个TCP连接需要经过“三次握手”，具体如下：第一次握手：客户端发送请求包到服务器，等待服务器确认第二次握手：服务器响应客户端请求，同时也发送一个回应包给客户端第三次握手：客户端收到服务器的回应包后，向服务器发送确认包 握手过程中传送的包里，不包含数据，三次握手完毕后，客户端与服务端才正式的开始传递数据。TCP一旦连接起来，在客户端和服务端任何一方主动关闭连接之前，TCP连接都将被一直保持下去。断开连接时，服务器和客户端都可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手” 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次挥手”。 HTTP连接 HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。 1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。 SOCKET原理 套接字（socket）概念Socket是通信的基石，是支持TCP&#x2F;IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。建立socket连接建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 连接确认：当服务器端套接字监听到或接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 MQTT概述 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的“轻量级”通讯协议，该协议构建于TCP&#x2F;IP协议上 MQTT最大优点在于，用极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 消息格式 消息格式如下 固定报头|可变报头|负载(消息体) 固定报头 byte2:剩余长度( Remaining Length)表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。共1~4个字节，每个字节的低7位用于编码数据，最高位表示是否有更多字节。最大允许发送256M控制报文(0xff,0xff,0xff,0x7f)&#x3D;256M; 可变报头 负载（有效消息） QoS等级 level 0：最多一次的传输 消息是基于TCP&#x2F;IP网络传输的。没有回应，在协议中也没有定义重传的语义。消息可能到达服务器1次，也可能根本不会到达。 level 1：至少一次的传输 服务器接收到消息会被确认，通过传输一个PUBACK信息。如果有一个可以辨认的传输失败，无论是通讯连接还是发送设备，还是过了一段时间确认信息没有收到，发送方都会将消息头的DUP位置1，然后再次发送消息。消息最少一次到达服务器。SUBSCRIBE和UNSUBSCRIBE都使用level 1 的QoS。 如果客户端没有接收到PUBACK信息（无论是应用定义的超时，还是检测到失败然后通讯session重启），客户端都会再次发送PUBLISH信息，并且将DUP位置1。当它从客户端接收到重复的数据，服务器重新发送消息给订阅者，并且发送另一个PUBACK消息。 level 2： 只有一次的传输 在QoS level 1上附加的协议流保证了重复的消息不会传送到接收的应用。这是最高级别的传输，当重复的消息不被允许的情况下使用。这样增加了网络流量，但是它通常是可以接受的，因为消息内容很重要。 物联网常见无线协议 序号 协议 标准 频率 范围 数据速率 1 蓝牙 蓝牙4.2核心规格 2.4GHz（ISM） 50－150米（智能／ BLE） 1Mbps（智能／ BLE） 2 ZigBee 基于IEEE802.15.4的ZigBee 3.0 2.4GHz 10－100米 250kbps 3 6LowPAN RFC6282 （适用于各种其他网络媒体，包括蓝牙智能（2.4GHz）或ZigBee或低功率射频（亚1GHz） N ／ A N ／ A 4 WIFI 基于802.11n 2.4GHz和5GHz频段 约50m 最大600 Mbps，但根据所使用的通道频率和天线数量（最新的802.11－ac标准应提供500Mbps至1Gbps），150－200Mbps更为典型 5 蜂窝 GSM ／ GPRS ／ EDGE（2G），UMTS ／ HSPA（3G），LTE（4G） 900／1800／1900 ／ 2100MHz GSM最大35km； HSPA最长200公里 35－170kps（GPRS），120－384kbps（EDGE），384Kbps－2Mbps（UMTS），600kbps－10Mbps（HSPA），3－10Mbps 6 NFC NFC 13.56MHz（ISM） 10厘米 100－420kbps 7 LoRaWAN LoRaWAN 各种 2－5公里（城市环境），15公里（郊区环境） 0.3－50 kbps","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"常见协议","slug":"常见协议","permalink":"http://1nameccc.github.io/tags/%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/"}],"author":"coucou"},{"title":"网络协议——TCP&UDP","slug":"4-4-网络协议-TCP&UDP/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:10:12.367Z","comments":true,"path":"2023/08/01/4-4-网络协议-TCP&UDP/index/","permalink":"http://1nameccc.github.io/2023/08/01/4-4-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP&UDP/index/","excerpt":"网络协议——TCP&amp;UDP","text":"网络协议——TCP&amp;UDP TCP头部 socket函数 服务器端函数： （1）socket创建一个套接字 （2）bind绑定ip和port （3）listen使套接字变为可以被动链接 （4）accept等待客户端的链接 （5）write&#x2F;read接收发送数据 （6）close关闭连接 客户端函数： （1）创建一个socket，用函数socket() （2）bind绑定ip和port （3）连接服务器，用函数connect() （4）收发数据，用函数send()和recv()，或read()和write() （5）close关闭连接 UDP 网络七层模型 TCP建立和断开过程 三次握手和四次挥手 TCP如何保证可靠性 检验和： 通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部 序列号&#x2F; 确认应答、超时重传 数据到达接收方之后，接收方会发送一个确认应答，表示已经收到数据段，并且确认序号会说明了它下一次需要接收的数据序列号，如果发送方没收到确认应答，那么发送方方会进行重发，这个等待时间一般是2*RTT（往返时间）+一个偏差值,如果一个包多次重发没有收到接收端的确认包，就会强制关闭连接 窗口控制与重发控制&#x2F;快速重传(重复确认应答) TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值，如果不使用窗口控制，每一个没收到应答的数据都要重发 TCP 滑动窗口以及重传机制 1）滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。滑动可以理解为缓冲区的大小，告诉发送方，自己还能接受多少数据，TCP的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。 2）TCP在发送数据时会设置一个计时器，若到计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为重传超时（RTO） 。另一种方式的重传称为快速重传，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息（SACK）表明出现失序报文时，快速重传会推断出现丢包，需要重传。 TCP 慢启动 慢启动（Slow Start），是传输控制协议（TCP）使用的一种阻塞控制机制。慢启动也叫做指数增长期。慢启动是指每次TCP接收窗口收到确认时都会增长。增加的大小就是已确认段的数目。这种情况一直保持到要么没有收到一些段，要么窗口大小到达预先定义的阈值。如果发生丢失事件，TCP就认为这是网络阻塞，就会采取措施减轻网络拥挤。一旦发生丢失事件或者到达阈值，TCP就会进入线性增长阶段。这时，每经过一个RTT窗口增长一个段 Tcp为什么比UDP可靠 1.确认和重传机制 主要还三次握手和四次挥手 2.数据排序 TCP有专门的序列SN字段，可提供re-order 3.流量控制 窗口和计时器的使用，TCP窗口中指明双方能够接发的最大数据数量 4.拥塞控制 TCP的拥塞控制由4个核心算法组成，“慢启动”，“拥塞避免”，“”快速重传，“快速恢复” IPv4和IPv6的区别 1）协议地址的区别 地址长度：IPv4协议具有32位（4字节）地址长度；IPv6协议具有128位（16字节）地址长度 地址的表示方法：IPv4地址是以小数表示的二进制数。 IPv6地址是以十六进制表示的二进制数。 2）地址解析协议 IPv4协议：地址解析协议（ARP）可用于将IPv4地址映射到MAC地址。 IPv6协议：地址解析协议（ARP）被邻居发现协议（NDP）的功能所取代。 3）身份验证和加密 IPv6****提供身份验证和加密，但IPv4不提供。 4）数据包的区别 包的大小：IPv4协议的数据包最小值为576个字节；IPv6协议的数据包最小值为1280个字节。 包头：IPv4长度为20~40字节；IPv6固定40字节。 IP地址","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"TCP&UDP","slug":"TCP-UDP","permalink":"http://1nameccc.github.io/tags/TCP-UDP/"}],"author":"coucou"},{"title":"单片机——LVGL","slug":"3-5-单片机-LVGL/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T04:58:15.646Z","comments":true,"path":"2023/08/01/3-5-单片机-LVGL/index/","permalink":"http://1nameccc.github.io/2023/08/01/3-5-%E5%8D%95%E7%89%87%E6%9C%BA-LVGL/index/","excerpt":"lvgl文档（http://lvgl.100ask.net/8.2/）","text":"lvgl文档（http://lvgl.100ask.net/8.2/） 注：这里仅列出常用组件，详细API请查阅文档 :happy: 基础对象大小123lv_obj_set_size(obj, new_width, new_height); // 设置大小lv_obj_set_width(obj, new_width);lv_obj_set_height(obj, new_height); 位置123lv_obj_set_pos(obj, new_x, new_y); // 设置位置lv_obj_set_x(obj, new_x);lv_obj_set_y(obj, new_y); 对齐12lv_obj_align(obj, LV_ALIGN_CENTER, 10, 20); // 将对象从其父对象的中心移动 10(x)，20(y) 像素；lv_obj_align_to(obj_to_align, obj_referece, LV_ALIGN_..., x, y); // 参照另一个对象对齐 父母和孩子1234lv_obj_t *lv_obj_create(lv_obj_t *parent) // 创建基本父对象lv_obj_set_parent(obj, new_parent); // 设置父级lv_obj_move_foreground(obj); // 移到前台lv_obj_move_background(obj); // 移到后台 事件1234lv_obj_add_event_cb(obj, event_cb, LV_EVENT_..., user_data); // 设置事件回调lv_obj_add_event_cb(obj, my_event_cb_1, LV_EVENT_CLICKED, NULL); // 例如，这里表示点击事件lv_obj_add_event_cb(obj, my_event_cb_2, LV_EVENT_PRESSED, NULL); // 按下事件lv_obj_add_event_cb(obj, my_event_cb_3, LV_EVENT_ALL, NULL); // 所有事件 样式12void lv_style_init(lv_style_t *style) // 初始化lv_obj_add_style(obj, &amp;new_style, selector) // 设置样式 更多样式:happy: http://lvgl.100ask.net/8.2/overview/style.html#examples 核心组件圆弧example CODE 1234567891011121314151617181920212223242526272829303132333435#include &quot;../../lv_examples.h&quot;#if LV_USE_ARC &amp;&amp; LV_BUILD_EXAMPLESstatic void set_angle(void * obj, int32_t v)&#123; lv_arc_set_value(obj, v);&#125;/** * Create an arc which acts as a loader. */void lv_example_arc_2(void)&#123; /*Create an Arc*/ lv_obj_t * arc = lv_arc_create(lv_scr_act()); lv_arc_set_rotation(arc, 270); lv_arc_set_bg_angles(arc, 0, 360); lv_obj_remove_style(arc, NULL, LV_PART_KNOB); /*Be sure the knob is not displayed*/ lv_obj_clear_flag(arc, LV_OBJ_FLAG_CLICKABLE); /*To not allow adjusting by click*/ lv_obj_center(arc); lv_anim_t a; lv_anim_init(&amp;a); lv_anim_set_var(&amp;a, arc); lv_anim_set_exec_cb(&amp;a, set_angle); lv_anim_set_time(&amp;a, 1000); lv_anim_set_repeat_count(&amp;a, LV_ANIM_REPEAT_INFINITE); /*Just for the demo*/ lv_anim_set_repeat_delay(&amp;a, 500); lv_anim_set_values(&amp;a, 0, 100); lv_anim_start(&amp;a);&#125;#endif API 1lv_obj_t *lv_arc_create(lv_obj_t *parent) // 创建圆弧 进度条example CODE 123456789101112#include &quot;../../lv_examples.h&quot;#if LV_USE_BAR &amp;&amp; LV_BUILD_EXAMPLESvoid lv_example_bar_1(void)&#123; lv_obj_t * bar1 = lv_bar_create(lv_scr_act()); lv_obj_set_size(bar1, 200, 20); lv_obj_center(bar1); lv_bar_set_value(bar1, 70, LV_ANIM_OFF);&#125;#endif API 1lv_obj_t *lv_bar_create(lv_obj_t *parent) // 创建进度条 按键example CODE 1234567891011121314151617181920212223242526272829303132333435363738#include &quot;../../lv_examples.h&quot;#if LV_USE_BTN &amp;&amp; LV_BUILD_EXAMPLESstatic void event_handler(lv_event_t * e)&#123; lv_event_code_t code = lv_event_get_code(e); if(code == LV_EVENT_CLICKED) &#123; LV_LOG_USER(&quot;Clicked&quot;); &#125; else if(code == LV_EVENT_VALUE_CHANGED) &#123; LV_LOG_USER(&quot;Toggled&quot;); &#125;&#125;void lv_example_btn_1(void)&#123; lv_obj_t * label; lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); lv_obj_add_event_cb(btn1, event_handler, LV_EVENT_ALL, NULL); lv_obj_align(btn1, LV_ALIGN_CENTER, 0, -40); label = lv_label_create(btn1); lv_label_set_text(label, &quot;Button&quot;); lv_obj_center(label); lv_obj_t * btn2 = lv_btn_create(lv_scr_act()); lv_obj_add_event_cb(btn2, event_handler, LV_EVENT_ALL, NULL); lv_obj_align(btn2, LV_ALIGN_CENTER, 0, 40); lv_obj_add_flag(btn2, LV_OBJ_FLAG_CHECKABLE); lv_obj_set_height(btn2, LV_SIZE_CONTENT); label = lv_label_create(btn2); lv_label_set_text(label, &quot;Toggle&quot;); lv_obj_center(label);&#125;#endif API 1lv_obj_t *lv_btn_create(lv_obj_t *parent) // 创建按键 按键矩阵example CODE 1234567891011121314151617181920212223242526272829303132#include &quot;../../lv_examples.h&quot;#if LV_USE_BTNMATRIX &amp;&amp; LV_BUILD_EXAMPLESstatic void event_handler(lv_event_t * e)&#123; lv_event_code_t code = lv_event_get_code(e); lv_obj_t * obj = lv_event_get_target(e); if(code == LV_EVENT_VALUE_CHANGED) &#123; uint32_t id = lv_btnmatrix_get_selected_btn(obj); const char * txt = lv_btnmatrix_get_btn_text(obj, id); LV_LOG_USER(&quot;%s was pressed\\n&quot;, txt); &#125;&#125;static const char * btnm_map[] = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;\\n&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;, &quot;\\n&quot;, &quot;Action1&quot;, &quot;Action2&quot;, &quot;&quot;&#125;;void lv_example_btnmatrix_1(void)&#123; lv_obj_t * btnm1 = lv_btnmatrix_create(lv_scr_act()); lv_btnmatrix_set_map(btnm1, btnm_map); lv_btnmatrix_set_btn_width(btnm1, 10, 2); /*Make &quot;Action1&quot; twice as wide as &quot;Action2&quot;*/ lv_btnmatrix_set_btn_ctrl(btnm1, 10, LV_BTNMATRIX_CTRL_CHECKABLE); lv_btnmatrix_set_btn_ctrl(btnm1, 11, LV_BTNMATRIX_CTRL_CHECKED); lv_obj_align(btnm1, LV_ALIGN_CENTER, 0, 0); lv_obj_add_event_cb(btnm1, event_handler, LV_EVENT_ALL, NULL);&#125;#endif API 1234lv_obj_t *lv_btnmatrix_create(lv_obj_t *parent) // 创建按键矩阵void lv_btnmatrix_set_map(lv_obj_t *obj, const char *map[]) // 自定义矩阵内容uint16_t lv_btnmatrix_get_selected_btn(const lv_obj_t *obj) // 获取按下事件IDconst char *lv_btnmatrix_get_btn_text(const lv_obj_t *obj, uint16_t btn_id) // 获取对应ID文本值 画布example CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;../../lv_examples.h&quot;#if LV_USE_CANVAS &amp;&amp; LV_BUILD_EXAMPLES#define CANVAS_WIDTH 200#define CANVAS_HEIGHT 150void lv_example_canvas_1(void)&#123; lv_draw_rect_dsc_t rect_dsc; lv_draw_rect_dsc_init(&amp;rect_dsc); rect_dsc.radius = 10; rect_dsc.bg_opa = LV_OPA_COVER; rect_dsc.bg_grad.dir = LV_GRAD_DIR_HOR; rect_dsc.bg_grad.stops[0].color = lv_palette_main(LV_PALETTE_RED); rect_dsc.bg_grad.stops[1].color = lv_palette_main(LV_PALETTE_BLUE); rect_dsc.border_width = 2; rect_dsc.border_opa = LV_OPA_90; rect_dsc.border_color = lv_color_white(); rect_dsc.shadow_width = 5; rect_dsc.shadow_ofs_x = 5; rect_dsc.shadow_ofs_y = 5; lv_draw_label_dsc_t label_dsc; lv_draw_label_dsc_init(&amp;label_dsc); label_dsc.color = lv_palette_main(LV_PALETTE_ORANGE); static lv_color_t cbuf[LV_CANVAS_BUF_SIZE_TRUE_COLOR(CANVAS_WIDTH, CANVAS_HEIGHT)]; lv_obj_t * canvas = lv_canvas_create(lv_scr_act()); lv_canvas_set_buffer(canvas, cbuf, CANVAS_WIDTH, CANVAS_HEIGHT, LV_IMG_CF_TRUE_COLOR); lv_obj_center(canvas); lv_canvas_fill_bg(canvas, lv_palette_lighten(LV_PALETTE_GREY, 3), LV_OPA_COVER); lv_canvas_draw_rect(canvas, 70, 60, 100, 70, &amp;rect_dsc); lv_canvas_draw_text(canvas, 40, 20, 100, &amp;label_dsc, &quot;Some text on text canvas&quot;); /*Test the rotation. It requires another buffer where the original image is stored. *So copy the current image to buffer and rotate it to the canvas*/ static lv_color_t cbuf_tmp[CANVAS_WIDTH * CANVAS_HEIGHT]; memcpy(cbuf_tmp, cbuf, sizeof(cbuf_tmp)); lv_img_dsc_t img; img.data = (void *)cbuf_tmp; img.header.cf = LV_IMG_CF_TRUE_COLOR; img.header.w = CANVAS_WIDTH; img.header.h = CANVAS_HEIGHT; lv_canvas_fill_bg(canvas, lv_palette_lighten(LV_PALETTE_GREY, 3), LV_OPA_COVER); lv_canvas_transform(canvas, &amp;img, 120, LV_IMG_ZOOM_NONE, 0, 0, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, true);&#125;#endif API 1lv_obj_t *lv_canvas_create(lv_obj_t *parent) // 创建画布 复选框example CODE API 1lv_obj_t *lv_checkbox_create(lv_obj_t *parent) // 创建复选框 下拉列表example CODE 1234567891011121314151617181920212223242526272829303132333435#include &quot;../../lv_examples.h&quot;#if LV_USE_DROPDOWN &amp;&amp; LV_BUILD_EXAMPLESstatic void event_handler(lv_event_t * e)&#123; lv_event_code_t code = lv_event_get_code(e); lv_obj_t * obj = lv_event_get_target(e); if(code == LV_EVENT_VALUE_CHANGED) &#123; char buf[32]; lv_dropdown_get_selected_str(obj, buf, sizeof(buf)); LV_LOG_USER(&quot;Option: %s&quot;, buf); &#125;&#125;void lv_example_dropdown_1(void)&#123; /*Create a normal drop down list*/ lv_obj_t * dd = lv_dropdown_create(lv_scr_act()); lv_dropdown_set_options(dd, &quot;Apple\\n&quot; &quot;Banana\\n&quot; &quot;Orange\\n&quot; &quot;Cherry\\n&quot; &quot;Grape\\n&quot; &quot;Raspberry\\n&quot; &quot;Melon\\n&quot; &quot;Orange\\n&quot; &quot;Lemon\\n&quot; &quot;Nuts&quot;); lv_obj_align(dd, LV_ALIGN_TOP_MID, 0, 20); lv_obj_add_event_cb(dd, event_handler, LV_EVENT_ALL, NULL);&#125;#endif API 1lv_obj_t *lv_dropdown_create(lv_obj_t *parent) // 创建下拉列表 图像example CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;../../lv_examples.h&quot;#if LV_USE_IMG &amp;&amp; LV_USE_SLIDER &amp;&amp; LV_BUILD_EXAMPLESstatic lv_obj_t * create_slider(lv_color_t color);static void slider_event_cb(lv_event_t * e);static lv_obj_t * red_slider, * green_slider, * blue_slider, * intense_slider;static lv_obj_t * img1;/** * Demonstrate runtime image re-coloring */void lv_example_img_2(void)&#123; /*Create 4 sliders to adjust RGB color and re-color intensity*/ red_slider = create_slider(lv_palette_main(LV_PALETTE_RED)); green_slider = create_slider(lv_palette_main(LV_PALETTE_GREEN)); blue_slider = create_slider(lv_palette_main(LV_PALETTE_BLUE)); intense_slider = create_slider(lv_palette_main(LV_PALETTE_GREY)); lv_slider_set_value(red_slider, LV_OPA_20, LV_ANIM_OFF); lv_slider_set_value(green_slider, LV_OPA_90, LV_ANIM_OFF); lv_slider_set_value(blue_slider, LV_OPA_60, LV_ANIM_OFF); lv_slider_set_value(intense_slider, LV_OPA_50, LV_ANIM_OFF); lv_obj_align(red_slider, LV_ALIGN_LEFT_MID, 25, 0); lv_obj_align_to(green_slider, red_slider, LV_ALIGN_OUT_RIGHT_MID, 25, 0); lv_obj_align_to(blue_slider, green_slider, LV_ALIGN_OUT_RIGHT_MID, 25, 0); lv_obj_align_to(intense_slider, blue_slider, LV_ALIGN_OUT_RIGHT_MID, 25, 0); /*Now create the actual image*/ LV_IMG_DECLARE(img_cogwheel_argb) img1 = lv_img_create(lv_scr_act()); lv_img_set_src(img1, &amp;img_cogwheel_argb); lv_obj_align(img1, LV_ALIGN_RIGHT_MID, -20, 0); lv_event_send(intense_slider, LV_EVENT_VALUE_CHANGED, NULL);&#125;static void slider_event_cb(lv_event_t * e)&#123; LV_UNUSED(e); /*Recolor the image based on the sliders&#x27; values*/ lv_color_t color = lv_color_make(lv_slider_get_value(red_slider), lv_slider_get_value(green_slider), lv_slider_get_value(blue_slider)); lv_opa_t intense = lv_slider_get_value(intense_slider); lv_obj_set_style_img_recolor_opa(img1, intense, 0); lv_obj_set_style_img_recolor(img1, color, 0);&#125;static lv_obj_t * create_slider(lv_color_t color)&#123; lv_obj_t * slider = lv_slider_create(lv_scr_act()); lv_slider_set_range(slider, 0, 255); lv_obj_set_size(slider, 10, 200); lv_obj_set_style_bg_color(slider, color, LV_PART_KNOB); lv_obj_set_style_bg_color(slider, lv_color_darken(color, LV_OPA_40), LV_PART_INDICATOR); lv_obj_add_event_cb(slider, slider_event_cb, LV_EVENT_VALUE_CHANGED, NULL); return slider;&#125;#endif API 1lv_obj_t *lv_img_create(lv_obj_t *parent) // 创建图像 标签example CODE 12345678910111213141516171819202122232425#include &quot;../../lv_examples.h&quot;#if LV_USE_LABEL &amp;&amp; LV_BUILD_EXAMPLES/** * Show line wrap, re-color, line align and text scrolling. */void lv_example_label_1(void)&#123; lv_obj_t * label1 = lv_label_create(lv_scr_act()); lv_label_set_long_mode(label1, LV_LABEL_LONG_WRAP); /*Break the long lines*/ lv_label_set_recolor(label1, true); /*Enable re-coloring by commands in the text*/ lv_label_set_text(label1, &quot;#0000ff Re-color# #ff00ff words# #ff0000 of a# label, align the lines to the center &quot; &quot;and wrap long text automatically.&quot;); lv_obj_set_width(label1, 150); /*Set smaller width to make the lines wrap*/ lv_obj_set_style_text_align(label1, LV_TEXT_ALIGN_CENTER, 0); lv_obj_align(label1, LV_ALIGN_CENTER, 0, -40); lv_obj_t * label2 = lv_label_create(lv_scr_act()); lv_label_set_long_mode(label2, LV_LABEL_LONG_SCROLL_CIRCULAR); /*Circular scroll*/ lv_obj_set_width(label2, 150); lv_label_set_text(label2, &quot;It is a circularly scrolling text. &quot;); lv_obj_align(label2, LV_ALIGN_CENTER, 0, 40);&#125;#endif API 12lv_obj_t *lv_label_create(lv_obj_t *parent) // 创建标签void lv_label_set_text(lv_obj_t *obj, const char *text) // 设置文本 线条example CODE 123456789101112131415161718192021222324#include &quot;../../lv_examples.h&quot;#if LV_USE_LINE &amp;&amp; LV_BUILD_EXAMPLESvoid lv_example_line_1(void)&#123; /*Create an array for the points of the line*/ static lv_point_t line_points[] = &#123; &#123;5, 5&#125;, &#123;70, 70&#125;, &#123;120, 10&#125;, &#123;180, 60&#125;, &#123;240, 10&#125; &#125;; /*Create style*/ static lv_style_t style_line; lv_style_init(&amp;style_line); lv_style_set_line_width(&amp;style_line, 8); lv_style_set_line_color(&amp;style_line, lv_palette_main(LV_PALETTE_BLUE)); lv_style_set_line_rounded(&amp;style_line, true); /*Create a line and apply the new style*/ lv_obj_t * line1; line1 = lv_line_create(lv_scr_act()); lv_line_set_points(line1, line_points, 5); /*Set the points*/ lv_obj_add_style(line1, &amp;style_line, 0); lv_obj_center(line1);&#125;#endif API 12lv_obj_t *lv_line_create(lv_obj_t *parent) // 创建线条void lv_line_set_points(lv_obj_t *obj, const lv_point_t points[], uint16_t point_num) // 设置起点终点，数量 滚轮example CODE 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;../../lv_examples.h&quot;#if LV_USE_ROLLER &amp;&amp; LV_BUILD_EXAMPLESstatic void event_handler(lv_event_t * e)&#123; lv_event_code_t code = lv_event_get_code(e); lv_obj_t * obj = lv_event_get_target(e); if(code == LV_EVENT_VALUE_CHANGED) &#123; char buf[32]; lv_roller_get_selected_str(obj, buf, sizeof(buf)); LV_LOG_USER(&quot;Selected month: %s\\n&quot;, buf); &#125;&#125;/** * An infinite roller with the name of the months */void lv_example_roller_1(void)&#123; lv_obj_t *roller1 = lv_roller_create(lv_scr_act()); lv_roller_set_options(roller1, &quot;January\\n&quot; &quot;February\\n&quot; &quot;March\\n&quot; &quot;April\\n&quot; &quot;May\\n&quot; &quot;June\\n&quot; &quot;July\\n&quot; &quot;August\\n&quot; &quot;September\\n&quot; &quot;October\\n&quot; &quot;November\\n&quot; &quot;December&quot;, LV_ROLLER_MODE_INFINITE); lv_roller_set_visible_row_count(roller1, 4); lv_obj_center(roller1); lv_obj_add_event_cb(roller1, event_handler, LV_EVENT_ALL, NULL);&#125;#endif API 123lv_obj_t *lv_roller_create(lv_obj_t *parent) // 创建滚轮void lv_roller_set_options(lv_obj_t *obj, const char *options, lv_roller_mode_t mode) // 设置滚轮选项void lv_roller_set_options(lv_obj_t *obj, const char *options, lv_roller_mode_t mode) // 获取滚轮内容 滚动条example CODE 123456789101112131415161718192021222324252627282930313233#include &quot;../../lv_examples.h&quot;#if LV_USE_SLIDER &amp;&amp; LV_BUILD_EXAMPLESstatic void slider_event_cb(lv_event_t * e);static lv_obj_t * slider_label;/** * A default slider with a label displaying the current value */void lv_example_slider_1(void)&#123; /*Create a slider in the center of the display*/ lv_obj_t * slider = lv_slider_create(lv_scr_act()); lv_obj_center(slider); lv_obj_add_event_cb(slider, slider_event_cb, LV_EVENT_VALUE_CHANGED, NULL); /*Create a label below the slider*/ slider_label = lv_label_create(lv_scr_act()); lv_label_set_text(slider_label, &quot;0%&quot;); lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);&#125;static void slider_event_cb(lv_event_t * e)&#123; lv_obj_t * slider = lv_event_get_target(e); char buf[8]; lv_snprintf(buf, sizeof(buf), &quot;%d%%&quot;, (int)lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);&#125;#endif API 1lv_obj_t *lv_slider_create(lv_obj_t *parent) // 创建滚动条 开关example CODE 123456789101112131415161718192021222324252627282930313233343536#include &quot;../../lv_examples.h&quot;#if LV_USE_SWITCH &amp;&amp; LV_BUILD_EXAMPLESstatic void event_handler(lv_event_t * e)&#123; lv_event_code_t code = lv_event_get_code(e); lv_obj_t * obj = lv_event_get_target(e); if(code == LV_EVENT_VALUE_CHANGED) &#123; LV_LOG_USER(&quot;State: %s\\n&quot;, lv_obj_has_state(obj, LV_STATE_CHECKED) ? &quot;On&quot; : &quot;Off&quot;); &#125;&#125;void lv_example_switch_1(void)&#123; lv_obj_set_flex_flow(lv_scr_act(), LV_FLEX_FLOW_COLUMN); lv_obj_set_flex_align(lv_scr_act(), LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER); lv_obj_t * sw; sw = lv_switch_create(lv_scr_act()); lv_obj_add_event_cb(sw, event_handler, LV_EVENT_ALL, NULL); sw = lv_switch_create(lv_scr_act()); lv_obj_add_state(sw, LV_STATE_CHECKED); lv_obj_add_event_cb(sw, event_handler, LV_EVENT_ALL, NULL); sw = lv_switch_create(lv_scr_act()); lv_obj_add_state(sw, LV_STATE_DISABLED); lv_obj_add_event_cb(sw, event_handler, LV_EVENT_ALL, NULL); sw = lv_switch_create(lv_scr_act()); lv_obj_add_state(sw, LV_STATE_CHECKED | LV_STATE_DISABLED); lv_obj_add_event_cb(sw, event_handler, LV_EVENT_ALL, NULL);&#125;#endif API 1lv_obj_t *lv_switch_create(lv_obj_t *parent) // 创建开关 表example CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &quot;../../lv_examples.h&quot;#if LV_USE_TABLE &amp;&amp; LV_BUILD_EXAMPLESstatic void draw_part_event_cb(lv_event_t * e)&#123; lv_obj_t * obj = lv_event_get_target(e); lv_obj_draw_part_dsc_t * dsc = lv_event_get_param(e); /*If the cells are drawn...*/ if(dsc-&gt;part == LV_PART_ITEMS) &#123; uint32_t row = dsc-&gt;id / lv_table_get_col_cnt(obj); uint32_t col = dsc-&gt;id - row * lv_table_get_col_cnt(obj); /*Make the texts in the first cell center aligned*/ if(row == 0) &#123; dsc-&gt;label_dsc-&gt;align = LV_TEXT_ALIGN_CENTER; dsc-&gt;rect_dsc-&gt;bg_color = lv_color_mix(lv_palette_main(LV_PALETTE_BLUE), dsc-&gt;rect_dsc-&gt;bg_color, LV_OPA_20); dsc-&gt;rect_dsc-&gt;bg_opa = LV_OPA_COVER; &#125; /*In the first column align the texts to the right*/ else if(col == 0) &#123; dsc-&gt;label_dsc-&gt;align = LV_TEXT_ALIGN_RIGHT; &#125; /*MAke every 2nd row grayish*/ if((row != 0 &amp;&amp; row % 2) == 0) &#123; dsc-&gt;rect_dsc-&gt;bg_color = lv_color_mix(lv_palette_main(LV_PALETTE_GREY), dsc-&gt;rect_dsc-&gt;bg_color, LV_OPA_10); dsc-&gt;rect_dsc-&gt;bg_opa = LV_OPA_COVER; &#125; &#125;&#125;void lv_example_table_1(void)&#123; lv_obj_t * table = lv_table_create(lv_scr_act()); /*Fill the first column*/ lv_table_set_cell_value(table, 0, 0, &quot;Name&quot;); lv_table_set_cell_value(table, 1, 0, &quot;Apple&quot;); lv_table_set_cell_value(table, 2, 0, &quot;Banana&quot;); lv_table_set_cell_value(table, 3, 0, &quot;Lemon&quot;); lv_table_set_cell_value(table, 4, 0, &quot;Grape&quot;); lv_table_set_cell_value(table, 5, 0, &quot;Melon&quot;); lv_table_set_cell_value(table, 6, 0, &quot;Peach&quot;); lv_table_set_cell_value(table, 7, 0, &quot;Nuts&quot;); /*Fill the second column*/ lv_table_set_cell_value(table, 0, 1, &quot;Price&quot;); lv_table_set_cell_value(table, 1, 1, &quot;$7&quot;); lv_table_set_cell_value(table, 2, 1, &quot;$4&quot;); lv_table_set_cell_value(table, 3, 1, &quot;$6&quot;); lv_table_set_cell_value(table, 4, 1, &quot;$2&quot;); lv_table_set_cell_value(table, 5, 1, &quot;$5&quot;); lv_table_set_cell_value(table, 6, 1, &quot;$1&quot;); lv_table_set_cell_value(table, 7, 1, &quot;$9&quot;); /*Set a smaller height to the table. It&#x27;ll make it scrollable*/ lv_obj_set_height(table, 200); lv_obj_center(table); /*Add an event callback to to apply some custom drawing*/ lv_obj_add_event_cb(table, draw_part_event_cb, LV_EVENT_DRAW_PART_BEGIN, NULL);&#125;#endif API 1lv_obj_t *lv_table_create(lv_obj_t *parent) // 创建表 文本框example CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;../../lv_examples.h&quot;#if LV_USE_TEXTAREA &amp;&amp; LV_BUILD_EXAMPLESstatic void textarea_event_handler(lv_event_t * e)&#123; lv_obj_t * ta = lv_event_get_target(e); LV_LOG_USER(&quot;Enter was pressed. The current text is: %s&quot;, lv_textarea_get_text(ta));&#125;static void btnm_event_handler(lv_event_t * e)&#123; lv_obj_t * obj = lv_event_get_target(e); lv_obj_t * ta = lv_event_get_user_data(e); const char * txt = lv_btnmatrix_get_btn_text(obj, lv_btnmatrix_get_selected_btn(obj)); if(strcmp(txt, LV_SYMBOL_BACKSPACE) == 0) lv_textarea_del_char(ta); else if(strcmp(txt, LV_SYMBOL_NEW_LINE) == 0) lv_event_send(ta, LV_EVENT_READY, NULL); else lv_textarea_add_text(ta, txt);&#125;void lv_example_textarea_1(void)&#123; lv_obj_t * ta = lv_textarea_create(lv_scr_act()); lv_textarea_set_one_line(ta, true); lv_obj_align(ta, LV_ALIGN_TOP_MID, 0, 10); lv_obj_add_event_cb(ta, textarea_event_handler, LV_EVENT_READY, ta); lv_obj_add_state(ta, LV_STATE_FOCUSED); /*To be sure the cursor is visible*/ static const char * btnm_map[] = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;\\n&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;\\n&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;\\n&quot;, LV_SYMBOL_BACKSPACE, &quot;0&quot;, LV_SYMBOL_NEW_LINE, &quot;&quot;&#125;; lv_obj_t * btnm = lv_btnmatrix_create(lv_scr_act()); lv_obj_set_size(btnm, 200, 150); lv_obj_align(btnm, LV_ALIGN_BOTTOM_MID, 0, -10); lv_obj_add_event_cb(btnm, btnm_event_handler, LV_EVENT_VALUE_CHANGED, ta); lv_obj_clear_flag(btnm, LV_OBJ_FLAG_CLICK_FOCUSABLE); /*To keep the text area focused on button clicks*/ lv_btnmatrix_set_map(btnm, btnm_map);&#125;#endif API 1lv_obj_t *lv_textarea_create(lv_obj_t *parent) // 创建文本框 Extra widgets(常用)键盘example CODE 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;../../lv_examples.h&quot;#if LV_USE_KEYBOARD &amp;&amp; LV_BUILD_EXAMPLESstatic void ta_event_cb(lv_event_t * e)&#123; lv_event_code_t code = lv_event_get_code(e); lv_obj_t * ta = lv_event_get_target(e); lv_obj_t * kb = lv_event_get_user_data(e); if(code == LV_EVENT_FOCUSED) &#123; lv_keyboard_set_textarea(kb, ta); lv_obj_clear_flag(kb, LV_OBJ_FLAG_HIDDEN); &#125; if(code == LV_EVENT_DEFOCUSED) &#123; lv_keyboard_set_textarea(kb, NULL); lv_obj_add_flag(kb, LV_OBJ_FLAG_HIDDEN); &#125;&#125;void lv_example_keyboard_1(void)&#123; /*Create a keyboard to use it with an of the text areas*/ lv_obj_t *kb = lv_keyboard_create(lv_scr_act()); /*Create a text area. The keyboard will write here*/ lv_obj_t * ta; ta = lv_textarea_create(lv_scr_act()); lv_obj_align(ta, LV_ALIGN_TOP_LEFT, 10, 10); lv_obj_add_event_cb(ta, ta_event_cb, LV_EVENT_ALL, kb); lv_textarea_set_placeholder_text(ta, &quot;Hello&quot;); lv_obj_set_size(ta, 140, 80); ta = lv_textarea_create(lv_scr_act()); lv_obj_align(ta, LV_ALIGN_TOP_RIGHT, -10, 10); lv_obj_add_event_cb(ta, ta_event_cb, LV_EVENT_ALL, kb); lv_obj_set_size(ta, 140, 80); lv_keyboard_set_textarea(kb, ta);&#125;#endif API 1234lv_obj_t *lv_keyboard_create(lv_obj_t *parent) // 创建键盘void lv_keyboard_set_textarea(lv_obj_t *kb, lv_obj_t *ta) // 设置输入对象void lv_keyboard_set_mode(lv_obj_t *kb, lv_keyboard_mode_t mode) // 设置键盘模式void lv_textarea_set_placeholder_text(lv_obj_t *ta, &quot;Hello&quot;); // 设置预文本 消息对话框example CODE 12345678910111213141516171819#include &quot;../../lv_examples.h&quot;#if LV_USE_MSGBOX &amp;&amp; LV_BUILD_EXAMPLESstatic void event_cb(lv_event_t * e)&#123; lv_obj_t * obj = lv_event_get_current_target(e); LV_LOG_USER(&quot;Button %s clicked&quot;, lv_msgbox_get_active_btn_text(obj));&#125;void lv_example_msgbox_1(void)&#123; static const char * btns[] =&#123;&quot;Apply&quot;, &quot;Close&quot;, &quot;&quot;&#125;; lv_obj_t * mbox1 = lv_msgbox_create(NULL, &quot;Hello&quot;, &quot;This is a message box with two buttons.&quot;, btns, true); lv_obj_add_event_cb(mbox1, event_cb, LV_EVENT_VALUE_CHANGED, NULL); lv_obj_center(mbox1);&#125;#endif API 123lv_obj_t *lv_msgbox_create(lv_obj_t *parent, const char *title, const char *txt, const char *btn_txts[], bool add_close_btn) // 创建对话框uint16_t lv_msgbox_get_active_btn(lv_obj_t *mbox) // 获得点击事件IDvoid lv_msgbox_close(lv_obj_t *mbox) // 关闭对话框 字体样式example CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;../../lv_examples.h&quot;#if LV_USE_SPAN &amp;&amp; LV_BUILD_EXAMPLES/** * Create span. */void lv_example_span_1(void)&#123; static lv_style_t style; lv_style_init(&amp;style); lv_style_set_border_width(&amp;style, 1); lv_style_set_border_color(&amp;style, lv_palette_main(LV_PALETTE_ORANGE)); lv_style_set_pad_all(&amp;style, 2); lv_obj_t * spans = lv_spangroup_create(lv_scr_act()); lv_obj_set_width(spans, 300); lv_obj_set_height(spans,300); lv_obj_center(spans); lv_obj_add_style(spans, &amp;style, 0); lv_spangroup_set_align(spans, LV_TEXT_ALIGN_LEFT); lv_spangroup_set_overflow(spans, LV_SPAN_OVERFLOW_CLIP); lv_spangroup_set_indent(spans, 20); lv_spangroup_set_mode(spans, LV_SPAN_MODE_BREAK); lv_span_t * span = lv_spangroup_new_span(spans); lv_span_set_text(span, &quot;China is a beautiful country.&quot;); lv_style_set_text_color(&amp;span-&gt;style, lv_palette_main(LV_PALETTE_RED)); lv_style_set_text_decor(&amp;span-&gt;style, LV_TEXT_DECOR_STRIKETHROUGH | LV_TEXT_DECOR_UNDERLINE); lv_style_set_text_opa(&amp;span-&gt;style, LV_OPA_50); span = lv_spangroup_new_span(spans); lv_span_set_text_static(span, &quot;good good study, day day up.&quot;);#if LV_FONT_MONTSERRAT_24 lv_style_set_text_font(&amp;span-&gt;style, &amp;lv_font_montserrat_24);#endif lv_style_set_text_color(&amp;span-&gt;style, lv_palette_main(LV_PALETTE_GREEN)); span = lv_spangroup_new_span(spans); lv_span_set_text_static(span, &quot;LVGL is an open-source graphics library.&quot;); lv_style_set_text_color(&amp;span-&gt;style, lv_palette_main(LV_PALETTE_BLUE)); span = lv_spangroup_new_span(spans); lv_span_set_text_static(span, &quot;the boy no name.&quot;); lv_style_set_text_color(&amp;span-&gt;style, lv_palette_main(LV_PALETTE_GREEN));#if LV_FONT_MONTSERRAT_20 lv_style_set_text_font(&amp;span-&gt;style, &amp;lv_font_montserrat_20);#endif lv_style_set_text_decor(&amp;span-&gt;style, LV_TEXT_DECOR_UNDERLINE); span = lv_spangroup_new_span(spans); lv_span_set_text(span, &quot;I have a dream that hope to come true.&quot;); lv_spangroup_refr_mode(spans);&#125;#endif API 1lv_obj_t *lv_spangroup_create(lv_obj_t *par) // 创建文本对象 预加载example CODE 123456789101112#include &quot;../../lv_examples.h&quot;#if LV_USE_SPINNER &amp;&amp; LV_BUILD_EXAMPLESvoid lv_example_spinner_1(void)&#123; /*Create a spinner*/ lv_obj_t * spinner = lv_spinner_create(lv_scr_act(), 1000, 60); lv_obj_set_size(spinner, 100, 100); lv_obj_center(spinner);&#125;#endif API 1lv_obj_t *lv_spinner_create(lv_obj_t *parent, uint32_t time, uint32_t arc_length) // 创建预加载对象 Tab栏example CODE 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;../../lv_examples.h&quot;#if LV_USE_TABVIEW &amp;&amp; LV_BUILD_EXAMPLESvoid lv_example_tabview_1(void)&#123; /*Create a Tab view object*/ lv_obj_t *tabview; tabview = lv_tabview_create(lv_scr_act(), LV_DIR_TOP, 50); /*Add 3 tabs (the tabs are page (lv_page) and can be scrolled*/ lv_obj_t *tab1 = lv_tabview_add_tab(tabview, &quot;Tab 1&quot;); lv_obj_t *tab2 = lv_tabview_add_tab(tabview, &quot;Tab 2&quot;); lv_obj_t *tab3 = lv_tabview_add_tab(tabview, &quot;Tab 3&quot;); /*Add content to the tabs*/ lv_obj_t * label = lv_label_create(tab1); lv_label_set_text(label, &quot;This the first tab\\n\\n&quot; &quot;If the content\\n&quot; &quot;of a tab\\n&quot; &quot;becomes too\\n&quot; &quot;longer\\n&quot; &quot;than the\\n&quot; &quot;container\\n&quot; &quot;then it\\n&quot; &quot;automatically\\n&quot; &quot;becomes\\n&quot; &quot;scrollable.\\n&quot; &quot;\\n&quot; &quot;\\n&quot; &quot;\\n&quot; &quot;Can you see it?&quot;); label = lv_label_create(tab2); lv_label_set_text(label, &quot;Second tab&quot;); label = lv_label_create(tab3); lv_label_set_text(label, &quot;Third tab&quot;); lv_obj_scroll_to_view_recursive(label, LV_ANIM_ON);&#125;#endif API 12lv_obj_t *lv_tabview_create(lv_obj_t *parent, lv_dir_t tab_pos, lv_coord_t tab_size) // 创建Tab栏lv_obj_t *lv_tabview_add_tab(lv_obj_t *tv, const char *name) // 添加栏","categories":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"LVGL","slug":"LVGL","permalink":"http://1nameccc.github.io/tags/LVGL/"}],"author":"coucou"},{"title":"网络协议——MQTT","slug":"4-2-网络协议-MQTT/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:09:56.240Z","comments":true,"path":"2023/08/01/4-2-网络协议-MQTT/index/","permalink":"http://1nameccc.github.io/2023/08/01/4-2-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-MQTT/index/","excerpt":"一，MQTT协议","text":"一，MQTT协议 1、MQTT协议可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。 2、使用发布&#x2F;订阅消息模式，提供一对多的消息发布，解除应用程序耦合。对负载内容屏蔽的消息传输。使用 TCP&#x2F;IP 提供网络连接。 3、实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 4、MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）。（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 一、MQTT是什么？MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布&#x2F;订阅（Publish&#x2F;Subscribe）模式的轻量级通讯协议，该协议构建于TCP&#x2F;IP协议上，由IBM在1999年发布，目前最新版本为v3.1.1。MQTT最大的优点在于可以以极少的代码和有限的带宽，为远程设备提供实时可靠的消息服务。做为一种低开销、低带宽占用的即时通讯协议，MQTT在物联网、小型设备、移动应用等方面有广泛的应用。 当然，在物联网开发中，MQTT不是唯一的选择，与MQTT互相竞争的协议有XMPP和CoAP协议等， 应用消息 Application Message MQTT协议通过网络传输应用数据。应用消息通过MQTT传输时，它们有关联的服务质量（QoS）和主题（Topic）。 客户端Client使用MQTT的程序或设备。客户端总是通过网络连接到服务端。它可以发布应用消息给其它相关的客户端。订阅以请求接受相关的应用消息。取消订阅以移除接受应用消息的请求。从服务端断开连接。一般情况，云下设备&#x3D;&#x3D;客户端 服务端 Server一个程序或设备，作为发送消息的客户端和请求订阅的客户端之间的中介。服务端接受来自客户端的网络连接。接受客户端发布的应用消息。处理客户端的订阅和取消订阅请求。转发应用消息给符合条件的已订阅客户端。（服务端不是数据的终点，它只是数据的中转站）（一般情况下，云平台&#x3D;&#x3D;服务端） 订阅 Subscription订阅包含一个主题过滤器（Topic Filter）和一个最大的服务质量（QoS）等级。订阅与单个会话（Session）关联。会话可以包含多于一个的订阅。会话的每个订阅都有一个不同的主题过滤器。 主题名 TopicName附加在应用消息上的一个标签，服务端已知且与订阅匹配。服务端发送应用消息的一个副本给每一个匹配的客户端订阅。 主题过滤器 Topic Filter订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。 会话 Session客户端和服务端之间的状态交互。一些会话持续时长与网络连接一样，另一些可以在客户端和服务端的多个连续网络连接间扩展。 控制报文 MQTT Control Packet通过网络连接发送的信息数据包。MQTT规范定义了十四种不同类型的控制报文，其中一个（PUBLISH报文）用于传输应用消息。 1234567891011121314ASCII：0~31及127（共33个）是控制字符或通信专用字符（其余为可显示字符32~126（共95个）是字符（32是空格），其中48~57为0到9十个阿拉伯数字。65~90为26个大写英文字母，97~122号为26个小写英文字母，其余为一些标点符号、运算符号等。GBK：汉字内码扩展规范（国标）。采用单/双字节变长编码，完全兼容AsCH字符编码英文使用单字节编码，中文部分采用双字节编码。UTF-8：是一种针对 Un i code的可变长度字符编码，又称万国码。UTF-8用1到6个字节编码 Uni code字符。可以表示中文简体繁体及其它语言（如英文，日文，韩文）。注意：即使是同一个汉字，在不同的编码中所对应的数值/长度是不同的（如：GBK/UTF-8安信可IDE默认是GBK编码，MTT规定为UTF-8编码。如果使用安信可编译器编程发送汉字，需将安信可IDE的编码方式设为UTF-8。 清理会话 Clean Session当MTT客户端接入MTT服务端时，选择是否继续之前的会话。如果不清理会话，MTT服务端会在之前交互的基础上，继续交互如果清理会话，MTT服务端必须新建一个全新的会话。 二、MQTT的特点消息质量（QoS）MQTT消息质量有三个等级，QoS 0，QoS 1和 QoS 2。 QoS 0：最多分发一次。消息的传递完全依赖底层的TCP&#x2F;IP网络，协议里没有定义应答和重试，消息要么只会到达服务端一次，要么根本没有到达。QoS 1：至少分发一次。服务器的消息接收由PUBACK消息进行确认，如果通信链路或发送设备异常，或者指定时间内没有收到确认消息，发送端会重发这条在消息头中设置了DUP位的消息。QoS 2：只分发一次。这是最高级别的消息传递，消息丢失和重复都是不可接受的，使用这个服务质量等级会有额外的开销。 eg.目前流行的共享单车智能锁，智能锁可以定时使用QoS level 0质量消息请求服务器，发送单车的当前位置，如果服务器没收到也没关系，反正过一段时间又会再发送一次。之后用户可以通过App查询周围单车位置，找到单车后需要进行解锁，这时候可以使用QoS level 1质量消息，手机App不断的发送解锁消息给单车锁，确保有一次消息能达到以解锁单车。最后用户用完单车后，需要提交付款表单，可以使用QoS level 2质量消息，这样确保只传递一次数据，否则用户就会多付钱了。 MQTT的消息类型（Message Type）固定报文头中的第一个字节包含连接标志（Connect Flags），连接标志用来区分MQTT的消息类型。MQTT协议拥有14种不同的消息类型（如表2），可简单分为连接及终止、发布和订阅、QoS 2消息的机制以及各种确认ACK。至于每一个消息类型会携带什么内容。 异步发布&#x2F;订阅实现发布&#x2F;订阅模式解耦了发布消息的客户（发布者）与订阅消息的客户（订阅者）之间的关系，这意味着发布者和订阅者之间并不需要直接建立联系。这个模式有以下好处： 发布者与订阅者只需要知道同一个消息代理即可发布者和订阅者不需要直接交互发布者和订阅者不需要同时在线 JSONJSON中文全称是JavaScript对象标记语言，在这门语言中，一切都是对象。因此，任何支持的类型都可以通过JSON来表示，例如字符串、数字、对象、数组等。其语法规则是： 1234对象表示为键值对；数据由逗号分隔；花括号保存对象；方括号保存数组。 JSON层次结构简洁清晰，易于阅读和编写，同时也易于机器解析和生成，有效提升网络传输效率。 对于单片机开发者，主流的微控制器软件开发工具Keil有提供JSON库，可以用于STC、STM32等微控制器开发，所以在微控制器上解析JSON不需要自己写一个JSON解析器或者移植了。 如果实在懒得使用JSON库生成或解析，也可以直接使用C语言中的sprintf生成JSON字符串，比如： 1sprintf(buf, &quot;&#123;\\&quot;String\\&quot;:\\&quot;%s\\&quot;, \\&quot;Value\\&quot;:%d&#125;&quot;, &quot;Hello World!&quot;, 12345);","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"MQTT","slug":"MQTT","permalink":"http://1nameccc.github.io/tags/MQTT/"}],"author":"coucou"},{"title":"网络协议——Zigbee","slug":"4-3-网络协议-Zigbee/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:10:29.330Z","comments":true,"path":"2023/08/01/4-3-网络协议-Zigbee/index/","permalink":"http://1nameccc.github.io/2023/08/01/4-3-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-Zigbee/index/","excerpt":"Zigbee通信","text":"Zigbee通信 1. 说明1.1 按网络功能划分， 协调器 (协调器模块在网络里的地址永远是0x0000) 路由器 终端 1.2 数据通信方式 单播 广播 组播 绑定 1.3 组网要求 任何一个Zigbee模块要加入到某个网络，一定要一个处于该网络里的节点作为介绍人，并且这个介绍人不能是终端节点。在加入网络以后，介绍人节点和被介绍加入的节点互为父子关系，介绍人节点是被介绍加入节点的父节点，被介绍加入节点是介绍节点的子节点。 当被加入节点有多个介绍人可以选择加入的时候，根据相对于被加入节点的信号强度等一些其他的参数，选择最佳的介绍人节点加入。 2. 组网过程（每一帧）2.1 入网前 路由器 ​ 路由器在入网之前，一直发送信标请求帧，它的作用是，让在它附近的所有具备介绍人资格的节点，都回复信标帧，这些返回的信标帧被这个想要加入的无线模块拿到，通过这些信标帧，选出最佳介绍人节点，请求加入。 终端 ​ 它在入网前的行为和下载了路由器代码模块在入网前行为是一样的。 协调器 ​ 发送了一帧信标请求帧，发送这一帧也会得到周围具备介绍人资格的节点回复信标帧，但是协调器拿到这些信标帧，用来判断周围的环境情况，为创建网络做准备。 ​ 当协调器创建成功以后，就会发送一个数据帧，这个帧里面可以看到协调器的地址0x0000,PANID,可以把这个帧叫做网络连接状态帧。 2.2入网到稳定工作 路由器 协调器发出的网络连接状态帧，表明协调器稳定工作，与路由器入网无关 路由器模块发出的信标请求帧，用于发现周围的网络，请求加入 协调器模块发出的信标请求帧，路由器模块在拿到这个帧之后，可以得到协调器模块相对于它自己的信号强度，判断是不是最佳介绍人。 4-5. 6-7. 重复2-3的过程 补充： 在Zigbee网络里，如果一个模块发出的射频帧，非常明确的指定接收目标节点的地址，那么目标节点在接收到这个帧以后，硬件会自动回复一个ACK，表明已经收到了。 是路由器模块发给协调模块，这个帧的作用是，在前面路由器模块收到了协调器模块的信标帧，通过信标帧判断协调器是当前路由器模块的最佳介绍人，路由器模块发送这一帧是告诉协调器，你是我当前的最佳介绍人，请你从当我入网的介绍人，介绍我入网，并且在这个帧携带了自己MAC,这个MAC地址是介绍人模块（协调器模块）给被介绍人模块（路由器模块）分配网络的地址的依据。 是协调器模块硬件回复给路由器模块的ACK，表明我已经收到了你发过来的帧 是路由器模块发给协调器模块的帧，请求协调器，把你根据我前面发给你的MAC地址给我分配的网络地址现在发给我。是一个数据请求帧。 协调器回复给路由器的ACK表明收到了路由器发过来的帧 协调器把为路由器分配好的网络地址发给路由器。而这个帧需要非常明确的发给路由器模块，但是路由器模块还不知道自己的网络地址是多少，所有在指定目标地址的时候用MAC地址 在路由器模块根据自己的MAC地址收到了协调器发过来分配给自己的网络地址，硬件自己回复ACK，表明已经收到了， 入网宣告，告诉当前网络里所有的节点，我入网了，我的网络地址是0xE9EB。 是协调器模块在收到了路由器模块发的入网宣告帧以后，转发的帧。 16 17. 是协调器模块和路由器模块在工作稳定时，发出的网络连接状态帧。 协调器和路由器在入网后，稳定工作时的行为是，每隔一段时间发一次网络连接状态帧，默认是15S 终端 入网过程，终端的入网过程和路由器入网的过程，所有的行为都是一样的 终端.psd 终端节点发送给它的父节点协调器的数据请求帧，为了告诉它的父节点，我还在线。 协调器在收到终端发来的帧，硬件自动回复的ACK 3. PANID网段值 非0xFFFF 路由器和终端: 我必须要加入到PANID为参数值这样一个Zigbee无线局域网 协调器: 我要创建一个网络，并且把这个参数值作为这个网络的PANED 为0xFFFF 路由器和终端: 在加入网络的时候没有PANID的限制 协调器: 我可以随机生成一个值，把这个随机值作为这个网络的PANED 4. 事件和消息4.1 事件​ 在ZSTACK里按照代码按照功能来划分，分成不同的层，比如，硬件操作相关硬件层 网络相关的代码脚网络层 自己写应用程序部分叫应用层，几乎每一个层都是一个任务，系统为每一个任务分配一个一个字节的唯一数值编号，每一个任务都能处理一些他们能够处理的事，我们把这个数值编号叫做任务ID，它他们能够处理的事物叫做__事件__。 123uint8 osal_set_event( uint8 task_id, uint16 event_flag )uint8 osal_start_timerEx( uint8 taskID, uint16 event_id, uint16 timeout_value ) ​ 在ZSTACK里，任务事件定义的特点决定了，每一个任务最多只能处理__16种__不同的事件，而系统在运行时候有许多事务需要处理，如果每一个实物处理都定义成1个事件，那么16种事件肯定是不够用，所有引入消息。 4.2 事件原理 系统在运行的时候会不断的去读应用层__任务事件变量__，当它发现这个变量为0就认为，应用层任务当前没有事件需要去处理; 如果发现这个变量不为0，它就认为应用层任务有事件将要去处理，它就会去调用应用层任务事件处理函数UINT16 SDApp_ProcessEvent( byte task_id, UINT16 events )，并且把任务事件变量的值传给events;在这个事件处理函数里，events;会分别和应用层定义的所有事件宏值进行与操作，如果发现那个为0，那么就去执行这个事件处理的相应代码。osal_set_event(SDApp_TaskID,SDApp_SEND_MSG_EVT); 几乎每一个层都是一个任务，那么每一个层都有1个任务ID 任务事件处理函数 任务事件变量 FUN函数数组&#x3D;{任务事件处理A,任务事件处理B,任务事件处理C..} Arr变量数组&#x3D;{任务事件变量a,任务事件变量b,任务事件变量c..} 关注2个函数osal_init_system，在这个函数里的osalInitTasks，在这个函数里发现系统给所有任务分配任务ID. 表示当前系统有tasksCnt个任务。 osal_start_system(); 所有ZSTACK协议栈在稳定工作时，它行为是，__在for(;;){}死循环里，不断去读所有任务的任务事件变量__，如果发现所有任务的任务事件变量都为0，没问题，说明所有任务都没有事件将要去处理，再次重逢这个过程，直到发现某个任务事件变量不为0，就会通过不为0的这个任务ID找到这个任务事件处理函数，去处理相应的事件。 4.2 消息消息的处理事务的__原理__： 定义了一个事件#define SYS_EVENT_MSG 0x8000 当需要应用层任务来处理某个事务的时候，首先给应用层任务发送一个消息 1void osal_set_event(SDApp_TaskID, SYS_EVENT_MSG); 那么这样一来，应用层就会进入SYS_EVENT_MSG处理，在这个事件处理里判断到底刚刚引发我们产生SYS_EVENT_MSG事件是哪一种类型的消息，然后根据消息的类型做相应的处理。 而消息的类型可以自己定义，这样一来消息的类可以很多，那么应用层任务处理的事物种类就很多了。 5. 单播5.1 概述​ 发射模块非常明确知道接收模块的网络地址，以这个地址发送数据给接收模块，叫单播。 5.2 数据接收处理函数1void SDApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )； 5.3 端点 (Endpoint) 他是一个字节编号的，数据收和发送的基本单元，在模块通信的时候，__发送模块必须指定收发双方模块的网络地址和端点__。 端点要使用必须要和模块里的某个任务挂钩定义； 一个端点只能挂钩在一个任务上，而一个任务可以挂钩多个端点，且端点对所有的任务是公用的，定义一个少一个。 端点下还需要定义__簇__ 123456789101112131415void SDApp_Init( byte task_id ) //定义了10号端点并且和这个模块的应用层任务挂钩&#123; // Fill out the endpoint description. SDApp_epDesc.endPoint = 10; //SDApp_ENDPOINT; 此端点编号为10 SDApp_epDesc.task_id = &amp;SDApp_TaskID; 和我们应用层任务挂钩 SDApp_epDesc.simpleDesc = (SimpleDescriptionFormat_t *)&amp;SDApp_SimpleDesc;//更加详细的描述这个端点一些情况就像我们定义一个编号房间，描述房间里大概有多少人之类的信息。 SDApp_epDesc.latencyReq = noLatencyReqs;//差不多 afRegister( &amp;SDApp_epDesc );//这个函数必须要调用才能完成整个挂钩操作&#125; 5.4 簇 (ClusterID) 簇就是相当于端点房间里面的人，是接收最终的目标。这东西是2个字节编号，在射频发送的时候，必须要指定接收模块的镞，发送模块不需要指定。 12345678910111213141516171819202122232425262728byte SDApp_TransID; // This is the unique message ID (counter) SDApp.c全局变量，记录我们引用层任务发送的数据包的个数。void SDApp_Init( byte task_id )&#123; SDApp_TransID = 0;&#125;if(P0_1 == 0)&#123; char theMessageData[] =&quot;Hello\\r\\n&quot;; SDApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit; // 模式 SDApp_DstAddr.addr.shortAddr = 0x0000; //接收模块的网络地址 SDApp_DstAddr.endPoint =SDApp_ENDPOINT ;//接收模块的端点房间号 //SDApp_epDesc 结构体 端点描述符有源端点的信息 AF_DataRequest( &amp;SDApp_DstAddr, &amp;SDApp_epDesc, SDApp_CLUSTERID,//目标端点镞，房间里的接收人数据宏是1，2个字节，所以在射频0x0001 (byte)osal_strlen( theMessageData ) + 1,//发送字符串的长度 (byte *)&amp;theMessageData,//字符串内容数组的首地址 &amp;SDApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS );&#125; 6. 广播6.1概述 协调器创建网络之后，就和网络里的路由器节点在通信过程中、功能上没有任何区别，只不过网络地址有点特殊永远是0x0000，终端入网之后，他和网络里的其他节点数据收和发都要经过他的父节点转发。 路由器在入网时候，虽然网络里也有他的父节点，有父子关系，但是他们发数据时候，不需要父节点转发，入网后，协调器和所有的路由器他们的通信地位是平等。 目标地址为0XFFFF表示，这个数据包的目标模块是网络里的所有节点 无线数据包的解析，网络源地址 网络目标地址，表示这个无线数据包的目的是从源地址 发送到目标地址；而在一个无线数据包里，前面的源地址 和目标地址代码 当前的这个无线数据包，是从哪个一个模块发出来，当前这个无线数据包要去哪一个节点。 6.2 实例化12345678910111213141516171819char theMessageData[] =&quot;Hello\\r\\n&quot;; SDApp_DstAddr.addrMode = (afAddrMode_t)AddBroadcast; // 广播模式SDApp_DstAddr.addr.shortAddr = 0xffff; // 表示目标接收模块是所有节点SDApp_DstAddr.endPoint =SDApp_ENDPOINT ;//接收模块的端点房间号 //SDApp_epDesc 结构体 端点描述符有源端点的信息AF_DataRequest( &amp;SDApp_DstAddr, &amp;SDApp_epDesc, SDApp_CLUSTERID,//目标端点镞，房间里的接收人数据宏是1，2个字节，所以在射频0x0001 (byte)osal_strlen( theMessageData ) + 1,//发送字符串的长度 (byte *)&amp;theMessageData,//字符串内容数组的首地址 &amp;SDApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ); 7. 组播7.1 概述 组播通信，在Zigbee网络，模块可以分组来标记，发送的模块如果发送的__组号__和网络里标记模块的组号相对应，那么这些模块就可以拿到这些无线数据包。 分组中组编号是2个字节， 组都是和模块里已经定义了的端点相关联，如果我们说一个模块标记为组1，那么这个模块里至少有1个定义了的可用的端点和组0x0001相关联。 发送的模块按照组的方式发送，需要指定的内容 目标模块的__组编号，端点，簇__，原则上只有当接收模块的这3个参数匹配上了，才能拿到和处理这样一个无线数据包 组标记中，同一个模块定义的一个组个可以关联多个可用的端点，同一个端点下也可以关联多个组。 7.2 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 发送模块char theMessageData[] =&quot;Hello\\r\\n&quot;;SDApp_DstAddr.addrMode = (afAddrMode_t)AddrGroup; //发送模式是组播的方式SDApp_DstAddr.addr.shortAddr = 0x0001; //接收模块的组编号SDApp_DstAddr.endPoint =10 ;AF_DataRequest( &amp;SDApp_DstAddr, &amp;SDApp_epDesc, 0x0001,//接收模块的簇编号 (byte)osal_strlen( theMessageData ) + 1, (byte *)&amp;theMessageData, &amp;SDApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ); // 协调器接收模块#include&quot;aps_groups.h&quot; //用到了组相关的结构体，所有添加组头文件aps_Group_t SampleApp_Group1;aps_Group_t SampleApp_Group2; // 按下按钮标记组if(P0_1 == 0)&#123;//按钮3按下 aps_RemoveGroup(10,0x0002); // 如果10号端点上关联了0x0002，那么就去掉组2个这个关联，如果根本没有关联，不做处理 SampleApp_Group1.ID=0X0001; // 关联组 aps_AddGroup( 10, &amp;SampleApp_Group1 ); // 添加关联&#125;if(0==P2_0)&#123; aps_RemoveGroup(10,0x0001);//如果10号端点上关联了0x0001，那么就去掉组1个这个关联，如果根本没有关联，不做处理 SampleApp_Group2.ID=0X0002; aps_AddGroup( 10, &amp;SampleApp_Group2 ); &#125;if(0==P0_5)&#123; aps_RemoveAllGroup(10); // 移除所有关联 SampleApp_Group1.ID=0X0001; aps_AddGroup( 10, &amp;SampleApp_Group1 ); SampleApp_Group2.ID=0X0002; aps_AddGroup( 10, &amp;SampleApp_Group2 ); &#125;// 数据处理if(0x0001==pkt-&gt;groupId) // 找组&#123; if(10==pkt-&gt;endPoint) // 找端点 &#123; switch ( pkt-&gt;clusterId ) // 找簇 &#123; case 0x0001: // 数据处理 break; &#125; &#125;&#125; if(0x0002==pkt-&gt;groupId)&#123; if(10==pkt-&gt;endPoint) &#123; switch ( pkt-&gt;clusterId ) &#123; case 0x0001: // 数据处理 break; &#125; &#125;&#125;","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"Zigbee","slug":"Zigbee","permalink":"http://1nameccc.github.io/tags/Zigbee/"}],"author":"coucou"},{"title":"硬件——模拟电路","slug":"5-1-硬件-模拟电路/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:10:43.350Z","comments":true,"path":"2023/08/01/5-1-硬件-模拟电路/index/","permalink":"http://1nameccc.github.io/2023/08/01/5-1-%E7%A1%AC%E4%BB%B6-%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/index/","excerpt":"模拟电路","text":"模拟电路 第一章 半导体器件本征半导体 1、本征半导体：纯净的，具有完整晶体结构的半导体。在一定温度下，本征半导体内最重要的物理现象是本征激发（又称热激发），产生两种带电性质向相反的载流子（空穴和自由电子对），温度越高，本征激发越强。2、空穴是半导体中的一种等效+q的载流子。空穴导电的本质是价电子依次填补本征晶体中空位，使局部显示+q的空位宏观定向运动。3、在一定温度下，自由电子和空穴在热运动中相遇，使一对自由电子和空穴消失的现象称为复合。当热激发和复合相等时，称为载流子处于动态平衡状态。4、单质半导体材料是具有四价共价键晶体结构的硅Si和锗Ge。 杂质半导体 1、P(positive)型半导体：在本征半导体中掺入微量的3价元素如硼B（多子是空穴，少子是电子） 2、N(negative)型半导体：在本征半导体中掺入微凉的5价元素如磷P（多子是电子，少子是空穴）。 PN结 1、PN结中存在由N区指向P区的内建电场（因为多子的扩散使得不可移动的离子显性，P区是负离子，N区是正离子，所以内建电场由N区指向P区），阻止结外两区的多子的扩散，有利于少子的漂移。2、PN结具有单向导电性：正偏导通，反偏截止，是构成半导体器件的核心器件。 半导体二极管 1、稳压二极管，是利用二极管在反向电压作用下的齐纳击穿（崩溃）效应，制造而成的一种具有稳定电压功能的电子技术组件，因此又称为“稳压管”。 2、发光二极管（英语：Light-emitting diode，缩写为LED）是一种能发光的半导体电子元件，透过三价与五价元素所组成的复合光源。 3、光电二极管（英语：photodiode ）是一种能够将光根据使用方式，转换成电流或者电压信号的光探测器。 4、肖特基二极管（又译萧特基二极管）是一种导通电压降较低、允许高速切换的二极管，是利用肖特基势垒特性而产生的电子元件 晶体三极管 1、放大原理 NPN型双极性晶体管可以视为共用阳极的两个二极管接合在一起。在双极性晶体管的正常工作状态下，发射结（基极与发射极之间的PN结）处于正向偏置状态，而集电结（基极与集电极之间的PN结）则处于反向偏置状态。在没有外加电压时，发射结N区的电子（该区域的多数载流子）浓度大于P区的电子浓度，部分电子将扩散到P区。 pnp其实和npn完全相反，体现在发射极比基极电压要高，基极比集电极电压要高，也就是发射极接高电压，集电极接低电压，有的地方，集电极接负电压 MOS场效应管 1、MOS工作在导通区或者截止区的时候可以当开关使用。外加PWM信号可以用于调压，电机调速等方面。 2、几个MOS管搭配可以起到单向导通的作用(类似二极管单向导通)，比二极管有优势的地方是压降小、功耗低，导通电流大。低电压大电流的情况下优势更明显; 3、工作在可变电阻区的时候可以当一个电阻使用，一般集成芯片中的电阻就是使用这种方式的电阻，优势是生产方便，体积小巧。 4、工作在可变电阻区还可以起到放大的作用，与三极管放大电路类似。 第二章 基本放大电路 放大的概念 放大电路放大的本质是能量的控制和转换 电子电路的基本特征是功率放大 能够控制能量的元件称为有源元件 放大的前提是不失真，只有在不失真的情况下放大才有意义 任何稳态信号都可以分解为若干频率正弦信号（谐波）的叠加，所以放大电路常以正弦波作为测试信号 放大电路的主要性能指标 放大倍数 输入电阻 输出电阻 通频带，衡量放大电路对不同频率信号的放大能力 非线性失真系数 最大不失真输出电压 最大输出功率和效率 第三章 多级放大电路第四章 集成运算放大电路 集成运放的电路结构特点 因为硅片上无法制作大电容，所以集成运放采用直接耦合方式 因为相邻元件具有良好的对称性，所以电路采用各种差分放大电路（作输入级）和恒流源电路（做偏置电路或有源负载） 允许复杂的电路形式 硅片上不宜制作高阻值电阻，所以用有源元件（晶体管或场效应管）取代电阻 常采用复合形式","categories":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"模拟电路","slug":"模拟电路","permalink":"http://1nameccc.github.io/tags/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/"}],"author":"coucou"},{"title":"网络协议——计算机网络","slug":"4-5-网络协议-计算机网络/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:10:36.425Z","comments":true,"path":"2023/08/01/4-5-网络协议-计算机网络/index/","permalink":"http://1nameccc.github.io/2023/08/01/4-5-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index/","excerpt":"计算机网络","text":"计算机网络 1.计算机网络体系结构1. 计算机网络概述 计算机网络最基本的功能是数据通信 局域网和广域网的主要差异不仅在于范围，还有所使用的协议 局域网和广域网的互联是通过路由器实现的 计算机网络拓扑结构主要取决于它的通信子网 2.计算机网络体系结构与参考模型 提供标准语言，定义标准界面，增强功能之间的独立性是对网络模型进行分层的目标，定义功能执行的方法则不是 协议是控制两个（或多个）对等实体进行通信的规则的集合，是水平的。 协议是指不同节点对等实体之间进行通信的规则或约定。 服务，接口，协议是OSI参考模型的三个主要概念 传输单位 功能 协议 应用层 表示层 格式转换及压缩 会话层 校验点，进程之间的对话 传输层 数据报&#x2F;报文段 分组排序，差错控制，流量控制，端到端连接，可靠传输 TCP，UDP 网络层 分组 路由选择，流量控制，差错控制，拥塞控制 IP，ICMP，ARP，RARP 数据链路层 帧 差错控制，流量控制 ，访问控制，帧定界功能 PPP，HDLC，SLIP 物理层 比特 （常考点）ISO&#x2F;OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅支持面向连接的通信；TCP&#x2F;IP模型在网络层仅有无连接的通信，在传输层支持无连接和面向连接的通信。 （易错点）在传输层将数据分割为报文后送入会话层。 只有传输层及以上各层的通信才能称为端到端。 因特网采用的核心技术是TCP&#x2F;IP 应用层的服务访问点也称用户界面 （重要）考研中层数一般是从下往上数的。物理层为第一层，应用层为第七层。 路由器：网络层，交换机：数据链路层，集线器：物理层 协议与服务有何区别，有何联系？ 协议是控制两个对等实体之间通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，而要实现本层协议，还需要使用下一层提供的服务。 协议和服务概念上的区分： （1）协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见本层的服务而无法看见下边的协议，即下边的协议对上层的服务用户是透明的。 （2）协议是“水平”的，即协议是控制两个对等实体之间的通信的规则。但服务是“垂直”的，即服务是由下层通过层间接口向上层提供的。 2.物理层1. 通信基础 曼彻斯特编码最适合传输*二进制数字信号***。位中间的跳变作为时钟信号，每个码元的电平作为数据信号。因此，时钟和数据取值都包含在信号中。 QAM是一种用模拟信号传输数字数据的编码方式。 把语音信号数字化的技术是脉冲编码调制 波特率表示信号每秒变化的次数。 以太网采用曼彻斯特编码，分组交换技术 由于报文交换 数据经过网络的传输延迟长而且不固定，因此不能用于 语音数据传输。 （重要）传输时延最小，电路交换；为保证数据无差错的传送，不应该用电路交换；分组交换对报文交换的主要改进是传输单位更小且有固定的最大长度；在出错率很高的传输系统中，选用数据报方式更合适。 虚电路是面向连接的，它提供的是一种可靠的服务，分组中携带虚电路标识，保证分组有序到达。有建立连接，数据传输和连接拆除三个阶段。由网络负责差错控制和流量控制。不需要为每条虚电路预分配带宽。 数据报服务中，网络为每个分组独立地选择路由，传输不保证可靠性，不保证分组的按序到达。每个分组在传输过程中都必须携带源地址和目标地址。 NRZ一般指不归零码。 比较分组交换和报文交换，并说明分组交换的原因？（P45） 2. 传输介质 双绞线绞合的目的是减少两根导线相互的电磁干扰。 同轴电缆比双绞线的传输速率更快，得益于同轴电缆具有更高的屏蔽性，同时有更好的抗噪声性。 如果单模光纤的直径减少到只有光的一个波长大小，那么光沿直线传播。 电气特性规定了信号的电压高低，传输距离等。功能特性指明某条线上出现的某一电平的电压表示何种含义。 出现的传输介质有 双绞线，同轴电缆，光纤 3. 物理层设备 中继器的主要作用是将信号整形并放大再转发出去，其原理是信号再生（不是放大）。端口只作用于信号的电气部分。 放大器和中继器的区别：放大器放大的是模拟信号，原理是将衰减的信号放大。中继器放大的是数字信号，原理是再生。 “5-4-3规则”：在采用粗同轴电缆的10BASE5以太网规范中，互相串联的中继器的个数不超过4个，而且4个中继器串联的5段通信介质中只有3段可以挂接计算机。 集线器实质上是一个多端口的中继器。连接的网络在拓扑结构上属于星形。 转发器的作用是放大信号。 两个网段在物理层进行互联时要求数据传输速率要相同，但数据链路层协议可以不相同。 用集线器连接的工作站集合同属一个冲突域，也同属一个广播域。 3.数据链路层1. 数据链路层的功能 数据链路层的功能包括组帧（定义数据格式），提供结点之间的可靠传输，控制对物理传输介质的访问。不包括为终端结点隐藏物理传输的细节。 为了避免传输过程中帧的丢失，数据链路层采用计时器超时重发 数据链路层提供无确认无连接，有确认无连接，有确认面向连接的服务。 3. 差错控制 提高信噪比可以减弱其影响的差错是随机差错 奇偶校验码只能检测出奇数个比特错误，且不能纠错。 CRC校验码能检测出所有单比特错误，不能纠错。 海明码纠错d位，需要码距为2d+1的编码方案，检错d位，需要码距 d+1。 CRC检验码的位数等于生成多项式G（x）的最高次数。 4. 流量控制与可靠传输机制 后退N帧协议（GBN）一般采用累积确认方式。 在连续ARQ（自动重传请求）协议中，发送窗口的大小&lt;&#x3D; 窗口总数-1. 停止等待协议：发送窗口&#x3D;接收窗口&#x3D;1 ； 后退N帧协议：发送窗口&gt;1,接收窗口&#x3D;1 ；选择重传协议：发送窗口&gt;1, 接收窗口 &gt; 1 信道利用率 &#x3D; 帧发送时间&#x2F;发送周期 5. 介质访问控制 位速率又叫比特率，是指在单位时间内可以传输多少数据。 TDM（时分多路复用）所用传输介质的性质是介质的位速率大于单个信号的位速率。 TDM可用于数字传输而FDM（频分多路复用）不行。 统计时分多路复用具有动态分配时隙的功能。 在CSMA&#x2F;CD协议的定义中，‘’争议期‘’指的是信号在最远两个端点之间往返传输的时间 介质访问冲突，使用二进制回退法的理由是这种算法考虑了网络负载对冲突的影响 与CSMA&#x2F;CD网络相比，令牌环网更适合的环境是负载重 多路复用器的主要功能是结合来自两条或多条线路的传输，以充分利用信道 对正确接收到的数据帧进行确认的MAC协议是 CSMA&#x2F;CA CSMA&#x2F;CD适用于有线网络，CSMA&#x2F;CA适用于无线局域网 CSMA&#x2F;CA进行信道预约的方法是交换RTS与CTS帧。 6. 局域网 以太网是局域网的一种 以太网参考模型一般只包括物理层和数据链路层 网卡实现的主要功能在物理层和数据链路层 同一局域网中两个设备具有相同的静态MAC地址，会发生在网络上这两个设备都不能正确通信 同轴电缆作为传输机制，无中继情况下，传输介质的最大长度不超过500m 10吉比特以太网只能工作在全双工模式下 实现”给帧加序号”功能的层次是逻辑链路控制子层（LLC） 无线局域网不需要在发送过程中进行冲突检测 在一个以太网中，有A,B,C,D四台主机，若A向B发送数据，则四台主机都能接收到数据。 吉比特以太网同时支持全双工模式和半双工模式 虚拟局域网中的计算机可以处于不同的局域网中 提高网络安全性是虚拟局域网（VLAN）的优点，链路聚合则不是 以太网的MAC协议提供的是无连接不可靠的服务 10BaseT使用的传输介质是双绞线 7.广域网 广域网所采用的传输方式是存储转发式 为实现透明传输，PPP使用的填充方法是字符填充 PPP协议具有差错控制能力，支持动态分配IP地址，支持身份验证等功能 PPP协议提供的功能有一种成帧方式，链路控制协议，网络控制协议 PPP协议中LCP帧的作用是在建立状态阶段协商数据链路协议的选项 PPP是面向字节的协议，HDLC是面向比特的协议 8. 数据链路层设备 网桥和以太网交换机工作在数据链路层 VLAN不仅可以隔离冲突域，也可以隔离广播域 减少冲突域的范围是网桥分割网络所带来的好处，缩小了广域网的范围则不是 路由器的传播延时相较于集线器，网桥，交换机最大。 交换机比集线器提供更好的网络性能的原因是交换机支持多用户同时通信 通过交换机连接的一组工作站组成一个广播域，但不是一个冲突域 交换机的多个端口可以并行传输，根据MAC地址进行转发 4. 网络层1. 网络层的功能 网络层的主要目的是在任意节点间进行数据报传输 路由器连接的异构网络是指数据链路层和物理层均不同 网络中发生了拥塞，其根据是随着通信子网负载的增加，吞吐量反而降低 在路由器互联的多个局域网的结构中，要求每个局域网物理层，数据链路层，网络层的协议可以不同，而网络层以上的高层协议必须相同 在因特网中，一个路由器中的路由表，通常包含目的网络和到达该目的网络路径上的下一个路由器的IP地址 路由器转发分组的根据是报文的IP地址 属于网络层协议的是IP和ICMP协议 软件定义网络（SDN）由远程控制器计算出最佳路由，路由器之间不再相互交换路由信息 2. 路由算法 在链路状态路由算法中，发送的链路状态信息，包括该路由器的相邻路由器及所有相邻链路的状态。 在距离向量路由协议中，好消息传的快，而坏消息传的慢。就导致了当路由信息发生变化时，该变化未能及时的被所有路由器知道。而仍然可能在路由器之间进行传递，这就是慢收敛现象。慢收敛是导致发生路由回路的根本原因。 3. IPV4 协议字段表示使用IP的上层协议，如值为六，表示tcp，值为17表示udp。版本字段表示IP的版本，值为4表示ipv4，值为6表示ipv6。 IP分组中的检验字段检查范围是仅检查分组首部。 当数据报到达目的网络后，传送到目的主机需要知道IP地址对应的物理地址。 在IP首部的字段中，与分片和重组无关的字段是总长度。 IP分组头中与分片与组装相关的字段是标识标志与片偏移 片偏移的单位是8B 组播的地址是保留的D类地址从224.0.0.0—239.255.255.255 主机号不全为0或者1就是单播地址 IP数据报从源结点到目的节点可能需要经过多个网络和路由器，在整个传输过程中，IP数据报头部中原地址和目的目的地址都不会发生变化，MAC地址会随着信息被发往不同的网络而改变 把IP网络划分成子网，这样做的好处是减少广播域的大小。 如果一台主机有两个或两个以上的IP地址，那么说明这台主机属于两个或两个以上的逻辑网络。 CIDR网络的作用是把小的网络汇聚成大的超网。 IP分组可以被路径中的路由器分片，并在目的主机进行重组。 路由器在转发IP数据报时重新封装源硬件地址和目的硬件地址。 可以动态为主机配置IP地址的协议是DHCP。 PING使用了ICMP的询问报文中的回送请求和回答报文。 ICMP差错报告报文有五种：终点不可达，原点抑制，时间超过，参数问题，改变路由（重定向）。其中原点抑制是指在路由器或主机由于拥塞而丢弃数据报时，让源点发送原点抑制报文，使源点知道应当把数据报的发送速率放慢。 ARP的功能是根据IP地址查询mac地址。 4. IPV6 与IPV4相比，IPV6减少头部字段，没有提供检验和字段。 IPV6不允许分片。 如果一个路由器收到的IPV6数据报因太大而不能转发到链路上，那么路由器将把该数据报丢弃。 5. 路由协议 采用分层次划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做却能使每个区域内部交换路由信息的通信量大大减少。 在计算机网络中，路由选择协议的功能不包括发现线下一跳的物理地址。发现下一跳的物理地址一般是通过其他方式（如ARP）实现的。 所谓收敛是指当路由环境发生变化后，各路由器调整自己的路由表以适应网络拓扑结构的变化，最终达到稳定状态（路由表与网络拓扑结构保持一致）。收敛越快，路由器就能越快适应网络拓扑结构的变化。 RIP是应用层协议，它使用UDP发送数据。OSPF是网络层协议。 OSPF协议使用hello分组来保持与其邻居的连接。 BGP交换的网络可达性信息是到达某个网络所经过的路径。 直接封装RIP，OSPF，BGP报文的协议分别是UDP， IP，TCP 每经过一个路由器，IP分组的TTL值减1。 6.IP组播 用多个单播仿真一个组播时，路由器的时延将很大，而处理一个组播分组的时延很小。 在设计组播路由时，为了避免路由环路，构造组播转发树 因特网的组播是靠路由器来实现的，这些路由器必须增加一些能够识别组播的软件。 7. 移动IP 移动IP的基本工作过程可以分为代理发现，注册，分组路由与注销四个阶段。 节点在使用移动IP进行通信时，归属代理和外部代理之间需要建立一条隧道。 移动IP为移动主机设置了两个IP地址，主地址和辅地址，主地址固定，辅地址动态改变。 一台主机移动到另一个不属于它的子网的网络中，它将既不可以直接接收分组，也不可以直接发送分组。 8. 网络层设备 要控制网络上的广播风暴，可以采用的方法是用路由器将网络分段 路由器主要实现物理层，数据链路层与网络层的功能。 路由表中的分组转发部分由交换结构，输入端口，输出端口组成。 路由器中计算路由信息的是路由选择处理机。 IP路由器检测到拥塞时，合理丢弃IP分组。 5. 传输层1. 传输层提供的服务 物理层，数据链路层，网络层属于通信子网 传输层为进程之间提供逻辑通信 传输层的面向连接服务的特性是保证可靠和顺序交付 可靠传输协议中的可靠指的是使用确认机制来保证传输的数据不丢失 TCP和UDP分别拥有自己的端口号，他们互不干扰，可以共存于同一台主机 TCP报文的首部长度和IP数据报的首部长度都为20B 若用户程序使用udp进行数据传输，则应用层协议必须承担可靠性方面的全部工作 2. UDP协议 UDP数据报中的长度字段包括首部和数据部分的长度 UDP数据报比IP数据报多提供了端口功能服务 Udp的校验和功能不是必须的，可以不使用 如果udp校验和计算结果为0，那么在校验和字段填充1 UDP数据报的伪首部包含了IP地址信息，目的是通过数据校验，保证udp数据报正确的到达目的主机。该伪首部由源原和目的主机仅在校验和计算期间建立，并不发送 UDP协议实现分用时，所依据的头部字段是目的端口号 3. TCP协议 TCP报头长度为20~60B，其中固定部分为20B TCP检验和伪首部中IP分组头的协议字段为6 TCP的确认号是指明接收方下一次希望收到的报文段的数据部分第1个字节的编号 报文段的序号是其数据部分第1个字节的编号 为保证数据传输的可靠性，TCP采用了对报文段确认的机制 TCP的滑动窗口协议中规定重传分组的数量最多可以等于滑动窗口的大小 （重要）在B发给A的报文中，seq值应该和A发向B的报文中的ack值相同 当客户机收到服务器发送的FIN段，并向服务器发送ack段时，客户机的TCP状态变为time_wait，此时TCP连接还未释放，必须经过时间等待计数器设置的时间2MSL后，客户机才进入closed的状态。 7.应用层1. 网络应用模型 客户端是请求方，一旦连接建立，服务器就能响应客户端请求的内容，服务器也能主动发送数据给客户端，用于一些消息的通知，如一些错误的通知 客户机是面向用户的，服务器是面向任务的 P2P网络是指在互联网中由对等节点组成的一种覆盖网络，是一种动态的逻辑网络 P2P通信模式是指P2P网络中对等节点之间的直接通信能力 2. 域名系统（DNS） （重要）域名与IP地址不具有一一对应的关系 DNS是基于C&#x2F;S模型的分布式系统 授权域名服务器可以将其管辖的主机名转换为主机的IP地址 可以使用传输层无连接服务的是DNS 3. 文件传输协议FTP 文件传输协议（FTP）的一个主要特征是允许客户指明文件的类型和格式 在服务器端，控制连接使用TCP的21号端口，数据连接使用TCP的20号端口，而在客户端，控制连接和数据连接的TCP端口号都是由客户端系统自动分配的 控制信息是带外传送的协议是FTP 匿名FTP访问通常使用anonymous作为用户名 4. 电子邮件 SMTP，POP3都是基于传输层的TCP协议 用户代理使用POP3协议接收邮件 POP3协议在传输层是使用明文来传送密码的，并不对密码进行加密 SMTP是一种”推”协议，用于发送方用户代理与发送方服务器之间以及发送方服务器与接收方服务器之间，不能用于接收方用户从服务器上读取邮件 SMAP只支持传输7比特ASCII码内容 5. 万维网 HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的(通信双方在交换HTTP报文之前不需要先建立HTTP连接)。 DNS采用UDP来传送数据，UDP是一种面向无连接的协议 HTTP1.0只支持非持久连接，所以每选求一个对象需要建立一次TCP连接 HTTP1.1 默认为持续连接 HTTP请求报文中， Connection：连接方式，close表示为非持续连接方式，keep-alive表示持续连接方式","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1nameccc.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"coucou"},{"title":"硬件——数字逻辑","slug":"5-2-硬件-数字逻辑/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:10:52.098Z","comments":true,"path":"2023/08/01/5-2-硬件-数字逻辑/index/","permalink":"http://1nameccc.github.io/2023/08/01/5-2-%E7%A1%AC%E4%BB%B6-%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/index/","excerpt":"数字逻辑","text":"数字逻辑 绪论 1.信号是传载信息的函数，信号常分为模拟信号、连续时间信号、离散时间信号和数字信号。 2.电子电路中的信号一般分为两类：模拟信号和数字信号。处理模拟信号的电路，称为模拟电路。处理数字信号的电路，称为数字电路。 3.模拟信号经过抽样、量化、编码后得到数字信号。 第一章 数字逻辑基础 二进制、八进制、十进制和十六进制之间的转换 8421BCD码与十进制之间的转换 十进制与原码、反码、补码之间的转换 第二章 逻辑门电路 逻辑门电路，与或非，异或，同或 第三章 逻辑代数 卡诺图化简 第四章 组合逻辑电路 1）电路任意时刻的输出状态，只取决于该时刻的输入状态，而与该时刻之前的电路输入和输出状态无关2）不具备存储功能的电路3）从输出到输入无反馈连接 第五章 触发器 RS触发器 D触发器 JK触发器 T触发器 第六章 时序逻辑电路 1）电路任意时刻的输出状态，与该时刻的输入状态有关，与该时刻之前的电路输入和输出状态也有关2）具备存储功能的电路3）从输出到输入存在反馈连接 同步时序电路分析与设计 第七章 脉冲波形的产生与变换 555定时器 施密特触发器 其他 1、二极管 共阴极半导体数码管公共端为低电平，共阳极数码管公共端为高电平；因为共阴极数码管公共端为低电平，所以输入信号为1有效，对应的二极管亮 2、触发器 D触发器：特性方程：Q* &#x3D; DRS触发器：特性方程：Q* &#x3D;S+R’ Q , RS&#x3D;0为约束条件JK触发器：特性方程：Q* &#x3D; JQ’ + K’ QT触发器: 特性方程：Q* &#x3D; TQ’ + T’ Q 3、三态门 三态门的输出有三种状态：高电平、低电平、高阻状态","categories":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"数字逻辑","slug":"数字逻辑","permalink":"http://1nameccc.github.io/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"}],"author":"coucou"},{"title":"硬件——处理器&架构","slug":"5-3-硬件-处理器&架构/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:00.207Z","comments":true,"path":"2023/08/01/5-3-硬件-处理器&架构/index/","permalink":"http://1nameccc.github.io/2023/08/01/5-3-%E7%A1%AC%E4%BB%B6-%E5%A4%84%E7%90%86%E5%99%A8&%E6%9E%B6%E6%9E%84/index/","excerpt":"硬件——CPU","text":"硬件——CPU CPU内部结构 控制单元、存储单元、运算单元、时钟 CPU、内存、虚拟内存、硬盘的关系 1.cpu: cpu是从内存或者缓存中拿到指令，放入寄存器，并对指令译码分解成一系列微操作，，然后发出控制命令，执行微操作 2.问题1：CPU并不能直接调用存储在硬盘上的系统、程序和数据，所以必须先将硬盘上的数据、内容存储在内存中，这样才能被CPU读取，所以内存是硬盘和CPU的中转站 3.问题2：内存一般是比较小的，当内存超出额度之后，就会把硬盘上的部分空间模拟成内存—–&gt;虚拟内存，将暂时不用的数据或程序保存到虚拟内存，等到需要的时候再调用 总结：CPU是工厂，内存是中转站，硬盘是仓库，虚拟内存是临时中转站 ARM结构处理器分类 Cortex-M3和Cortex-M4可以同时支持小端模式和大端模式 1.嵌入式微处理器 ——&gt;具有32位以上的处理器 2.嵌入式微控制器 ——–&gt;单片机，以某种微处理器内核为核心，芯片内部集成ROM，RAM等功能 3.嵌入式DSP处理器——&gt;擅长数字信号处理 嵌入式微处理器和嵌入式DSP区别 偏重的方向不一样，微处理器偏向于界面的操作，他的速度和，计算能力一般，一般使用在消费电子方面 DSP的计算能力较强，对于数据的处理能力极好，所以一般用作计算，比如军用，伺服电机 CPU指令集 CISC（Complex Instruction Set Computer）复杂指令集 特点：指令系统的指令不等长，指令的数目非常多 RISC（Reduced Instruction Set Computing）是“精简指令集 特点：采用RISC指令集的微处理器处理能力强，并且采用超标量和超流水线结构，大大增强了并行处理能力 CPU的流水线工作原理 CPU执行一条指令时，也分为几个步骤，如 指令取指（InstrucTIon Fetch）—–&gt; 指令译码（InstrucTIon Decode）—–&gt; 指令执行（Execute）——- &gt; 访存（Memory Access）—–&gt; 写回（Write-Back）， 重点：CPU****并不会等一条指令完全执行完才执行下一条指令，而是像流水一样 嵌入式流水线工作 嵌入式CPU为了提高效率，采用超流水线结构，我们知道，CPU执行一条指令被分成5个步骤，每个步骤可能都需要1ns，但是有个长指令，被分成5个步骤时，指令执行这个步骤却需要2ns,那么整个时间就被限制了 为了提高效率，我们可以把指令执行（Execute）这个步骤再拆分成两组（寄存器+组合逻辑），每组执行时间为1ns，这样我们的普通流水线成了六级流水线了，这就是超流水线","categories":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"处理器&架构","slug":"处理器-架构","permalink":"http://1nameccc.github.io/tags/%E5%A4%84%E7%90%86%E5%99%A8-%E6%9E%B6%E6%9E%84/"}],"author":"coucou"},{"title":"硬件——存储","slug":"5-4-硬件-存储/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:05.050Z","comments":true,"path":"2023/08/01/5-4-硬件-存储/index/","permalink":"http://1nameccc.github.io/2023/08/01/5-4-%E7%A1%AC%E4%BB%B6-%E5%AD%98%E5%82%A8/index/","excerpt":"硬件——存储","text":"硬件——存储 嵌入式系统存储体系 通用计算机采用了Cache（高级缓冲存储器）、主存储器（RAM，内存）、外部存储器组成的三级存储体系 速度：寄存器&gt;Cache &gt; 内存 （RAM &gt; ROM）&gt; 硬盘 嵌入式存储器类型 RAM RAM叫做随机存储器，是直接和CPU进行交互的内存（主存），通常作为正在运行程序和临时数据的存储煤质 RAM分类： 静态SRAM： SRAM，速度比DRAM快，不需要时钟同步 动态DRAM：同步动态RAM ，需要周期性刷新，密度比SRAM高，需要时钟同步 片内ram集成在CPU芯片内部，它是在CPU设计时就加上的，它使用和CPU几乎一样的制作工艺和材料，而且增加了芯片的大小，所以成本比较高，一般也就只有几十K字节，好钢当然要用在刀刃上，片内ram用来存放中断处理handler、RTOS调度器、任务上下文切换、内存分配释放等使用频率最高的代码和中断堆栈这种读写频率极高的内存区，如果有多余的部分也可以放一些经常被引用到的全局变量 片外RAM一般就是采购的市面上的成品，如Samsung，Hynix，Apmemory等，价格相对便宜，其容量的可选范围也较为宽松，从几M到几G的都有，它可以用来存储全局变量，bss，以及我们常用到的malloc所分配的堆空间等。 ROM 只读存储器，AM和ROM相比，两者的最大区别是RAM在断电以后保存在上面的数据会自动消失，而ROM不会自动消失，可以长时间断电保存 ROM一般是有两种 一种是指集成在CPU芯片内部的一块只读存储区域，一般是几K到几十K字节大小，用来存储系统刚上电时对cpu和一些核心外设（如时钟，串口，MMU、DRAM、Flash等）进行初始化的代码，它在程序运行中也是不可写的，要对它执行写操作只能使用硬件烧写器进行，也就是一般所说的下载程序，这部分的代码在芯片测试阶段可以进行编程器下载更新，量产后一般就会固化，不能做任何修改的； ROM另一种指的就是flash，它和硬盘有一个显著的区别：flash里存放的代码是可以由CPU直接取指并执行的，而PC上硬盘里的程序都需要加载到内存里才能运行， falsh和RAM对比 flash的写操作要比RAM麻烦的多了，flash在写之前需要发送多个命令字来握手，还要先对即将要写的地址所在的扇区进行整体擦除，就是把该扇区里的内容全设为1，所谓写flash就是把其中的一些bit设为0；更要命的是，flash的每个独立bit位的写次数是有上限的，市面上大部分的产品都只能写10~100万次。多说一句，每个bit位的寿命是独立的，如果一个bit位在擦除和写的动作中，它的值始终为1，则不会有影响；例如反复对一个地址写0xF0，则不会影响高4bit的寿命，而低4bit每次都要先擦成1，再写入0，这样就会降低其寿命 NOR闪存与NAND型闪存相比，写入速度较慢，但一般不需要纠错码 在 NAND 类型的闪存中，存储器可以按字、页甚至按位寻址 常见的Nand Flash，内部只有一个chip，每个chip只有一个plane Block：一个Nand Flash由很多个块做成，块是Nand Flash的擦除操作的基本&#x2F;最小单位。 Page：每个块里面有很多页page，页是读写操作的基本单位 思考： 引导程序（系统的初始化代码）就必须放到ROM里。在CPU刚上电时，只能去一个默认的地址去取第一条指令，开始干活，这个地址都是映射到片内的ROM里，原因很简单，此时，作为外设的flash和DDR等都还没有初始化，CPU根本无法从它们那里读写数据，片内ROM里的这些代码就需要完成这些模块的初始化。另外，一个项目的处理器和主要外设确定了以后，这部分初始化代码在很长的时间里，都不需要做任何修改的 DDR 是SDRAM的一种，DDR 全称是 Double Data Rate SDRAM，也就是双倍速率 SDRAM，SDRAM 在一个 CLK 周期传输一次数据， DDR 在一个 CLK 周期传输两次数据，也就是在上升沿和下降沿各传输一次数据，这个概念叫做预取(prefetch)，相当于 DDR 的预取为 2bit， DDR2 在 DDR 基础上进一步增加预取，增加到了 4bit，也就是在一个 CLK 周期传输4次数据，DDR3 在 DDR2 的基础上将预取提高到 8bit，也就是在一个 CLK 周期传输8次数据 Cache 只读数据（代码段、程序里的const、字符串等）一般来说，这些数据应该放在Flash里，可能有人会有疑问，放在flash里，会不会读取的速度很慢？读ROM的速度是比读RAM的数据要慢一点，但是不要忘了，现代CPU都有强大的cache，而且数据Dcache和指令Icache都是分开的，在系统运行中，cache的命中率可以高达80~90%，所以大部分时候CPU都可以在第一时间就拿到想要的指令和数据。 Cache写操作有两种，写回和写直达 写回的优点为： 处理器可以以cache而不是存储器接收的速度写单个的字 同一块内的多次写只需要对存储器层次结构的较低层写一次 当块被写回时，由于是写一整块，系统可以有效利用高传输带宽 写直达的优点为： 缺失较简单，代价较小，因此不需要把整个块写回到较低的存储器层次中 写直达比写回更易于实现，但是写直达cache仍需要一个写缓冲区 Cache的映射方法： cache的映射技术，通常有三种：直接映射、关联映射、组关联映射","categories":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"存储","slug":"存储","permalink":"http://1nameccc.github.io/tags/%E5%AD%98%E5%82%A8/"}],"author":"coucou"},{"title":"数据结构——实践","slug":"6-2-数据结构-实践/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:24.623Z","comments":true,"path":"2023/08/01/6-2-数据结构-实践/index/","permalink":"http://1nameccc.github.io/2023/08/01/6-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AE%9E%E8%B7%B5/index/","excerpt":"数据结构——程序","text":"数据结构——程序 说明： 以下的程序为数据结构基础测试，比如排序、栈、队列、链表的简单操作程序，还有其他一下简单算法，面试可能会考的简单题目，一般都是简单算法题目，相信难不倒大家，哈哈哈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAXDATA 10void sort_test01();void sort_test02();void stack_test();void queue_test();void list_test();void string_test();/* 冒泡排序-------------------------------------------- */void sort_test01()&#123; int temp = 0; int arr[] = &#123;3, 5, 6, 1, 2, MAXDATA, 14, 9, 0, 7&#125;; for(int i=0; i&lt;MAXDATA-1; i++) &#123; for(int j=i+1; j&lt;MAXDATA; j++) &#123; if(arr[i] &gt; arr[j]) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; printf(&quot;sort_test01: &quot;); for(int i=0; i&lt;MAXDATA; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;/* 插入排序-------------------------------------------- */void sort_test02()&#123; int arr[] = &#123;3, 5, 6, 1, 2, 10, 14, 9, 0, 7&#125;; for(int i=1; i&lt;MAXDATA; i++) &#123; int temp = arr[i]; int j; for(j=i-1; j&gt;=0, arr[j]&gt;temp; j--) &#123; arr[j+1] = arr[j]; &#125; arr[j+1] = temp; &#125; printf(&quot;sort_test02: &quot;); for(int i=0; i&lt;MAXDATA; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;/* 队列-------------------------------------------- */typedef struct QUEUE&#123; int data[MAXDATA]; int head; int rear;&#125;MyQueue;void queue_push(MyQueue *queue, int data)&#123; if((queue-&gt;rear + 1) % MAXDATA == queue-&gt;head) &#123; printf(&quot;queue is full&quot;); &#125; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear = (queue-&gt;rear + 1) % MAXDATA;&#125;int queue_pop(MyQueue *queue)&#123; int data = 0; if(queue-&gt;head == queue-&gt;rear) &#123; return 0; &#125; data = queue-&gt;data[queue-&gt;head]; queue-&gt;head = (queue-&gt;head - 1) % MAXDATA; return data;&#125;void queue_test()&#123; int data = 0; MyQueue queue; queue.head = 0; queue.rear = 0; queue_push(&amp;queue, 1); queue_push(&amp;queue, 8); data = queue_pop(&amp;queue); printf(&quot;queue_test: %d\\n&quot;, data);&#125;/* 栈-------------------------------------------- */typedef struct STACK&#123; int data[MAXDATA]; int top;&#125;MyStack;void stack_push(MyStack *st, int data)&#123; if(st-&gt;top == MAXDATA-1) &#123; printf(&quot;stack is full&quot;); &#125; st-&gt;top++; st-&gt;data[st-&gt;top] = data;&#125;int stack_pop(MyStack *st)&#123; int ret = 0; if(st-&gt;top == -1) &#123; return 0; &#125; ret = st-&gt;data[st-&gt;top]; st-&gt;top--; return ret;&#125;void stack_test()&#123; int data = 0; MyStack stack; stack.top = -1; stack_push(&amp;stack, 3); stack_push(&amp;stack, 4); data = stack_pop(&amp;stack); printf(&quot;stack_test: %d\\n&quot;, data);&#125;/* 链表-------------------------------------------- */typedef struct NODE&#123; int data; struct NODE *next;&#125;MyList;MyList *list_insert(MyList *head, int data)&#123; MyList *currentNode = head; MyList *newnode = (MyList *)malloc(sizeof(MyList)); if(newnode == NULL) &#123; exit(1); &#125; newnode-&gt;data = data; newnode-&gt;next = NULL; if(head == NULL) &#123; return newnode; &#125; while(currentNode-&gt;next != NULL) &#123; currentNode = currentNode-&gt;next; &#125; currentNode-&gt;next = newnode; return head;&#125;void print_list(MyList *list)&#123; MyList *temp_list = list; while(temp_list != NULL) &#123; printf(&quot;%d &quot;, temp_list-&gt;data); temp_list = temp_list-&gt;next; &#125;&#125;void list_test()&#123; MyList *list = NULL; list = list_insert(list, 2); list = list_insert(list, 4); printf(&quot;list_test:&quot;); print_list(list); printf(&quot;\\n&quot;);&#125;/* 大小端-------------------------------------------- */union BYTE&#123; short data; char ch[2];&#125;byte;void byte_test()&#123; byte.data = 0x1234; if(byte.ch[0] == 0x12 &amp;&amp; byte.ch[1] == 0x34) &#123; printf(&quot;byte_test1: This is big type\\n&quot;); &#125; else if(byte.ch[0] == 0x34 &amp;&amp; byte.ch[1] == 0x12) &#123; printf(&quot;byte_test1: This is litlle type\\n&quot;); &#125; short data = 0x1234; char *ch = (char *)&amp;data; if(*ch == 0x12) &#123; printf(&quot;byte_test2: This is big type\\n&quot;); &#125; else if(*ch == 0x34) &#123; printf(&quot;byte_test2: This is litlle type\\n&quot;); &#125; // ch = ch + 1; // if(*ch == 0x12) // &#123; // printf(&quot;really\\n&quot;); // &#125;&#125;/* 字符串内存占用-------------------------------------------- */void StrSize_test()&#123; char ch[] = &#123;&#x27;1&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;; char ch2[] = &quot;abcd1&quot;; char ch3[5] = &quot;abcd1&quot;; char *str = &quot;1&quot;; printf(&quot;StrSize_test: ch&gt;&gt; %d ch2&gt;&gt; %d ch3&gt;&gt; %d str&gt;&gt; %d\\n&quot;, \\ sizeof(ch), sizeof(ch2), sizeof(ch3), sizeof(str));&#125;/* 字符串查找 -------------------------------------------- */void StrFind_test()&#123; char *str = &quot;aabsafdcaadd&quot;; char *str1 = strchr(str, &#x27;f&#x27;); char *str2 = strstr(str, &quot;saf&quot;); int index = str2 - str; printf(&quot;StrFind_test: str1&gt;&gt; %s str2&gt;&gt; %s idx: %d \\n&quot;, str1, str2, index);&#125;/* 指针 -------------------------------------------- */void point_test()&#123; int *p = NULL; int a[4]=&#123;1,2,3,4&#125;; p=a; printf(&quot;point_test: *p++&gt;&gt;%d &quot;,*p++); p=a; printf(&quot;*(p++)&gt;&gt;%d &quot;,*(p++)); p=a; printf(&quot;(*p)++&gt;&gt;%d &quot;,(*p)++); p=a; printf(&quot;*++p&gt;&gt;%d &quot;,*++p); p=a; printf(&quot;++*p&gt;&gt;%d &quot;, ++*p); &#125;void memery_copy(char *dest, char *src)&#123; if(src == NULL) &#123; dest = NULL; &#125; while (*src != &#x27;\\0&#x27;) &#123; *dest++ = *src++; &#125; *dest = &#x27;\\0&#x27;;&#125;/* 链表简单操作bool linkring(link *head)&#123; link *p = head; link *p2 = head; while(p-&gt;next &amp;&amp; p2-&gt;next) &#123; p = p-&gt;next; p2 = p2-&gt;next-&gt;next; if(p == p2) &#123; return true; &#125; &#125; return false;&#125;void deletelink(link **head, link *p)&#123; p-&gt;pre-&gt;next = p-&gt;next; p-&gt;next-&gt;pre = p-&gt;pre; if(p == *head) &#123; *head = p-&gt;next; &#125; free(p);&#125;void insertlink(link *p, int data)&#123; link *next = NULL; next = (link *)malloc(sizeof(link)); next-&gt;data = data; next-&gt;pre = p; next-&gt;next = p-&gt;next; p-&gt;next-&gt;pre = next; p-&gt;next = next;&#125;void reservelink(link *head)&#123; link *pre = head; link *next = head-&gt;next; while(next) &#123; pre-&gt;next = next-&gt;next; next = hand; head = next; next = pre-&gt;next; &#125;&#125;*/int main()&#123; sort_test01(); sort_test02(); stack_test(); queue_test(); list_test(); byte_test(); // 大小端判断 StrSize_test(); StrFind_test(); point_test(); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"实践","slug":"实践","permalink":"http://1nameccc.github.io/tags/%E5%AE%9E%E8%B7%B5/"}],"author":"coucou"},{"title":"数据结构——理论","slug":"6-1-数据结构-理论/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:17.209Z","comments":true,"path":"2023/08/01/6-1-数据结构-理论/index/","permalink":"http://1nameccc.github.io/2023/08/01/6-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%90%86%E8%AE%BA/index/","excerpt":"数据结构——理论","text":"数据结构——理论 排序算法 数组和链表的区别 数组不允许 动态定义数组大小，使用前必须定义其大小；链表采用动态分配内存的方式，需要时分配内存空间，不需要时释放空间，不会造成内存的浪费。 从逻辑结构上来看：数组的大小一旦定义就不能改变，不能适应数据动态增减的情况；链表进行动态存储分配，可以适应数据动态的增减情况，可以方便插入删除数据 从存储角度来看：数组从栈中分配空间，对程序员方便快速，单自由度小；链表是从堆中分配空间，自由度大，但申请管理比较麻烦。 访问：数组在内存中是连续的，可用下标索引进行访问，链表是链式存储结构，访问元素时只能通过线性顺序由前向后顺序访问 栈和队列的区别 a，规则：栈 后进先出，队列： 先进先出（fifo）； b，插入删除操作限定不同：栈：只能在一端插入删除；队列：在一端插入，在另一端删除。 c，遍历数据的速度不同：栈：只能从栈顶取数据，最先进入栈底的需要遍历整个栈才能取出来，而且在遍历数据的同时，需要为数据开辟临时空间，保持数据在遍历前的一致性。队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，遍历速度快。 二叉树 树的遍历 中序遍历、先序遍历、后序遍历、层次遍历 搜索二叉树（二叉排序树） 根结点的左孩子小于根结点，并却右孩子大于根节点，所以，搜索二叉树的中序遍历就是一个有序的 平衡二叉树 若二叉树的所有节点的左右子子树的高度差最多相差1，这样的二叉树就是平衡二叉树 最小二叉平衡树的节点总数的公式如下 F(n)&#x3D;F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci(斐波那契)数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量 红黑树 查找 线性查找（Linear Search）：逐个遍历待查找的元素，直到找到目标元素或遍历完整个数据集。 二分查找（Binary Search）：对于已排序的数据集，通过比较目标元素与中间元素的大小关系，将查找范围逐渐缩小一半，直到找到目标元素或确定目标元素不存在。 插值查找（Interpolation Search）：针对有序数据集，根据目标元素在数据集中的大致位置，使用插值公式计算出一个估计的位置，并根据估计位置进行查找。 哈希查找（Hashing Search）：通过哈希函数将元素映射到一个特定的索引位置，从而实现快速查找。需要在数据集中构建哈希表来支持查找操作。 二叉搜索树查找（Binary Search Tree Search）：基于二叉搜索树数据结构，根据目标元素与当前节点的大小关系，递归地在左子树或右子树中进行查找。 B树查找（B-Tree Search）：基于B树数据结构，通过多次比较和分裂操作，将待查找的元素定位到B树中的叶子节点。 跳表查找（Skip List Search）：基于跳表数据结构，通过层级索引的方式，快速定位目标元素所在的位置。 Trie（前缀树）查找：用于字符串查找，通过构建Trie树（前缀树），根据待查找的字符串逐层匹配Trie树的节点，最终确定是否存在目标字符串。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"理论","slug":"理论","permalink":"http://1nameccc.github.io/tags/%E7%90%86%E8%AE%BA/"}],"author":"coucou"},{"title":"硬件——计算机组成原理","slug":"5-5-硬件-计算机组成原理/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:12.549Z","comments":true,"path":"2023/08/01/5-5-硬件-计算机组成原理/index/","permalink":"http://1nameccc.github.io/2023/08/01/5-5-%E7%A1%AC%E4%BB%B6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/index/","excerpt":"","text":"计算机组成原理1. 计算机系统概述1. 计算机系统层次结构 冯诺依曼机的基本工作方式：控制流驱动方式 在运算器中，不包含地址寄存器 把汇编语言源程序转变为机器语言程序的过程是 汇编 数据库系统不是 系统软件 相联存储器既可以按地址寻址也可按内容寻址 指令和数据都以二进制形式存储在存储器中，CPU区分它们的依据是：指令周期的不同阶段 解析：在取值阶段取的是指令，执行阶段取的是数据。容易选成 指令操作码的译码结果，需要注意的是，CPU只有在确定取出的是指令时，才会将其操作码送去译码。 计算机硬件能够直接执行的是 机器语言 2. 计算机的性能指标 在CPU的寄存器中，指令寄存器 对用户是完全透明的。 CPU 的 CPI 与时钟频率无关，与系统结构，计算机组织，指令集有关 ALU和通用寄存器的位数一定与机器字长相同 各种关系的转换 MIPS &#x3D; 时钟频率&#x2F;CPI 程序执行时间 &#x3D; CPI * 时钟周期 * 指令数 指令周期 &#x3D; 1 &#x2F; 指令执行速度 微机逻辑电路相同，指的是 CPI 相同， 时钟周期不一定相同 2. 数据的表示和运算1. 数制和编码 如果没有特殊说明，BCD码指的是 8421码 真值0 表示惟一的机器数是 补码和移码 若定点整数为64位，含一位符号位，则用补码表示的绝对值最大的负数为 -2^63 一般用移码表示浮点数的阶，而补码表示定点整数 补码符号位取反获得移码 补码进行运算时带上符号位 二进制转八进制，十六进制时，小数部分也是从右往左算 2. 运算方法和运算电路 ALU属于组合逻辑电路 在串行进位的并行加法器中，影响加法器运算速度的关键因素是 进位传递延迟 加法器中每位的 进位信号为 XY，进位传递信号 X⊕Y 模4补码（即双符号位）存储时只需要一个符号位 ，因为一个正确的数值，符号位是相同的 实现 N位（不包含符号位） 补码一位乘时，乘积为2N+1位 在算术移位的情况下，补码左移的前提条件是 其原最高有效位和原符号位要相同 C语言中变量都以补码形式存储，int 四字节，short 两字节，char 一字节 加法器的 低位进位输入信息 ：如果是减法为1，加法为 0 3. 浮点数的表示和运算 基数（小数点前边的那个数）越大，表示的范围越大，精度越低 关于规格化 123原码正数： 0.1…… 原码负数：1.1……补码正数： 0.1…… 补码负数：1.0…… 在对阶操作中，不存在阶码减小，位数左移的情况。因为阶码小的要向阶码大的对齐。 采用规格化浮点数主要是为了增加数据的表示精度 8421码是十进制数的编码 原码表示的规格化小数是小数点后两位（基数为4，用两位表示）不全为0的小数 定点数没有舍入的概念，只有浮点数才有 浮点数舍入的情况有两种：1. 对阶 2. 右规格化 舍入不一定产生误差 float类型（IEEE754 单精度浮点数格式）能表示的最大正整数是 2^128 - 2^104 尾数溢出时，可能只产生误差，结果不一定溢出 对阶操作不会引起阶码上溢或下溢 3.存储器系统1. 存储器概述 磁盘属于直接存取存储器（DAM） 存储器的存取周期是指 存储器进行连续存或写操作所允许的最短时间间隔 相联存储器是按 内容指定方式和地址指定方式相结合进行寻址的存储器 多级存储系统是为了降低存储成本 易错 虚拟存储器中主存和辅存之间的数据调动对 应用级程序员 是透明的 cache &#x2F; 主存系统的效率 e &#x3D; 访问Cache的时间 &#x2F; 平均访存时间 公式 &#x3D; 1&#x2F; [H + （1-H）*r] H为命中率，r 为主存访问时间除以 Cache访问时间 2. 主存储器 芯片的引脚数除了数据线和地址线，还有 一根片选线和读写控制线（一根和两根都有可能） DRAM的刷新是以行为单位的 DRAM在分散刷新时，不存在死时间 DRAM和SRAM 对比 DRAM采用地址复用技术，因此地址线只有一半 采用地址复用技术时，数据线减半，但会多增加行通选线和列通选线（片选线用行通选代替） Cache是易失性存储器，falsh存储器不是易失性存储器 U盘属于只读存储器 RAM和ROM都是采用随机存取方式进行信息访问 闪存：读速度比写快；是一种半导体存储器；非易失性存储器；随机访问方式 3. 外部存储器 RAID技术不可以提高磁盘的磁记录密度 固态硬盘（SSD）容易磨损 磁盘平均存取时间：访道时间 + 访问扇区时间 + 扫描扇区时间 6. 虚拟存储器 虚拟存储管理系统应该具有较好的局部性，此理论的基本含义是在程序的执行过程中，程序对主存的访问是不均匀的 段页式和页式交换的单位都是页 虚拟存储器对应用程序员透明，对系统程序员不透明 快表（TLB）存放在寄存器中，慢表存放在 主存中 TLB 存放 Page（页表）的一部分，Cache 存放 主存的一部分。 Cache使用直写方式 需要把数据同时写入 cache 和 主存 缺页处理完成后回到发生缺页的指令继续执行 4. 指令系统1. 指令格式 指令系统是计算机软&#x2F;硬件的界面 指令系统和机器语言是相关的 程序控制类指令的功能是改变程序执行的顺序 堆栈计算机中，零地址指令的操作数来自 堆栈的栈顶和次栈顶单元 单字长指令可加快取指令的速度 计算机按字节编制，指令的位数必须是8的倍数 2. 指令的寻址方式 指令系统中采用不同的寻址方式的目的是缩短指令字长，扩大寻址空间，提高编程的灵活性 无条件转移指令（是指程序转移到新的地址后继续执行）的功能是将指令中的地址码送入程序计数器（PC） 为了缩短指令中某个地址段的位数，最有效的方法是采取寄存器寻址 因为寄存器的数量较小，使用较少的位数即可全部表示 基址寻址有利于多道程序设计和编制浮动程序，变址寻址有利于处理数组问题和编制循环程序 堆栈寻址方式中，进栈时：先放入数据，SP（指向栈顶单元的指针）再减一 出栈时：SP先加一，在弹出数据 相对寻址中，相对地址实际上是以下条指令在内存中的首地址为基准位置的偏移量 因为在执行本条指令时，PC已完成加一操作 采用跳跃寻址时，可以实现程序的无条件浮动和条件浮动 指令寄存器寻址和指令寄存器间接寻址所需的指令码长度最短，立即寻址，直接寻址，间接寻址方式的指令码长度最长 寄存器寻址方式执行速度最快，间接寻址方式的执行速度最慢 若指令系统采用定长指令码格式，则立即寻址方式执行速度最快。若采用变长指令码格式时，寄存器寻址方式执行速度最快 3.程序的机器级代码表示两数相加寄存器变化： OF（溢出标志位，over flag）： 没有溢出为0 SF（符号标志位，symbol flag）：看符号位 CF（进位标志位，carry flag）：sub⊕C （做减法时sub为1，C作为进位输出） ZF（零标志位，zero flag）相关指令执行后结果为0那么 ZF&#x3D;1,结果不为0则 ZF&#x3D;0； 5. 中央处理器1. CPU的功能和基本结构 CPU分为运算器和控制器，控制器包括IR（指令寄存器），MAR，MDR，PC，指令译码器，时序电路，微操作信号发生器 条件转移指令执行时所依据的条件来自标志寄存器 需要对标志寄存器的内容进行测试，看是否满足转移条件 在CPU的寄存器中，指令寄存器对用户是透明的。汇编语言程序员可见的是PC 在一条无条件跳转指令的指令周期内，PC的值被修改 2 次。 指令寄存器的位数取决于 指令字长 CPU中通用寄存器的位数取决于机器字长（计算机能直接处理的二进制位数，决定了计算机的运算精度），可以存放数据和地址，但不能存放指令。 指令译码是对 指令的操作码字段 进行译码 间址周期（取操作数的有效地址）结束时，MDR的内容为 操作数地址 CPU中的专用寄存器：IR，PC，MAR，MDR，PSW（程序状态字寄存器） 2. 指令执行过程 指令总是根据程序计数器从主存中取出，即使有转移指令，也是从PC中取出 取指令操作是控制器自动运行的 不同指令周期所包含的机器周期数可能不同 只有出现中断请求时才会进入中断周期，每个指令周期不一定都包含一个中断周期 不同长度的指令，取值操作不同。如果指令长度相同，取址操作相同。 指令字长和机器字长的长度没有任何关系 3. 数据通路的功能和基本结构 采用CPU内部总线方式的数据通路的特点：结构简单，容易实现，性能较低，存在较多的冲突现象 4.控制器的功能和工作原理 在微程序控制器中，形成微程序入口地址的是机器指令的操作码地段 微程序控制器的速度比硬布线控制器慢，主要是因为增加了从控制存储器读取微指令的时间 与硬布线控制器相比，微程序控制器的时序系统比较简单 水平型微指令位数较多，较复杂；垂直型微指令位数较少，较简单，一次只能完成一次基本操作 水平型微指令能充分利用数据通路的并行结构 若指令系统中具有n种机器指令，则控制存储器中的微程序数至少是 n+2个，一个是公共的取指令，另一个对应中断的微程序 微机的CPU都是微处理器，和采用哪种控制器没有关系 控制存储器采用ROM实现，按地址访问，容量是2的幂次方 除控制部件（控制器）之外的部件都是执行部件 水平型微指令由操作控制字段，判别测试字段和下地址字段组成。例题是大题的第四，第五题。（判别测试字段还不知道怎么求） 5.异常和中断机制 主存故障引起的中断是硬件中断 异常事件在当前指令执行过程中进行检测，中断请求在当前指令执行后进行检测 自陷是通过陷阱指令预先设定的一类内部中断事件 中断是指来自CPU执行指令以外事件，异常也称内中断 访存时缺页属于异常（易错） 6. 指令流水线 流水线的冒险 结构冒险：资源冲突 数据冒险：数据冲突（RAW，WAR，WAW） 控制冒险：改变指令执行顺序 流水线的吞吐率：n&#x2F;(k+n-1)*时钟周期 流水线的加速比：kn&#x2F;(k+n-1) 超标量流水线的实质是以空间换时间，不是指运算操作并行 采用旁路技术可解决数据相关问题 流水线数据通路由控制部件控制，但不包含控制部件 理想情况下，单周期CPU，基本流水线CPU的CPI为1，多周期CPU的CPI&gt;1,超标量流水线CPU的CPI&lt;1. 流水线采用“按序发射，按序完成”方式，下一条指令的IF（取指操作）必须和上一条指令的ID（译码）并行，以免因上一条指令发生冲突而导致下一条指令先执行完。 7. 多处理器的基本概念 单指令单数据流结构（SISD）；多指令多数据流结构（MIMD） 多处理机属于MIMD 双核是指在CPU上集成两个运算核心 NUMA构架比UMA架构的运算扩展性要强 UMA架构需要解决的重要问题是Cache的一致性 6.总线6.1 总线概述 总线上的部件，可以分时向总线发送数据，但可同时从总线接受数据 在总线上，同一时刻只能有一个主设备控制总线传输操作 使用总线结构便于增减外设，同时减少信息传输线的条数 系统总线中地址线的功能是 指定主存和 I&#x2F;O设备接口电路的地址 不同信号在同一条信号线上分时传输的方式称作 总线复用方式 采用局部总线技术的作用是 节省系统的总带宽 突发式（猝发式）发送可以连续传送地址连续的数据 USB是串行传输，不能同时传输2位数据； 可通过级联方式连接多台外设 用于设备和设备控制器（I&#x2F;O接口）之间互联的接口标准是 USB 多总线结构中，总线之间通过桥接器连接 PCI—Express采用串行数据报方式传送数据 2. 总线事务和定时 同步通信比异步通信的传输效率高 在异步总线中，传送操作按需分配时间、 同步总线由统一的时序信号控制，异步总线由握手信号定时 7. 输入输出系统1. I&#x2F;O系统基本概念 I&#x2F;O指令是CPU系统指令的一部分，格式和其他通用指令相比有所不同 通道程序放在主存中，由通道执行 键盘，鼠标等输入设备一般都采用中断方式来实现 打印机从打字原理的角度来分析，可分为击打式和非击打式；按能打出汉字来分，可分为点阵式打印机和活字式打印机 计算机中一个汉字内码在主存中占用 2B， 输出的字型码 16*16点阵在缓冲存储区中占用 32B 2. I&#x2F;O接口 在统一编制方式下，区分存储单元和I&#x2F;O设备是靠不同的地址码，进行输入&#x2F;输出的操作指令是访存指令 I&#x2F;O接口的功能也包括I&#x2F;O过程中的错误和状态检测 磁盘驱动器向盘片磁道记录数据时采用串行方式写入 I&#x2F;O指令实现的数据传送通常发生在通用寄存器和I&#x2F;O端口之间 3. I&#x2F;O方式 在总线仲裁方式中，独立请求方式响应时间最快，是以增加控制线数为代价的 中断向量是中断服务程序入口地址，中断向量地址是中断服务程序入口地址的地址（重要） 可以提出中断的有 外部事件，虚拟存储器失效，浮点数运算上溢， 浮点数运算下溢不能引起中断 DMA的优先级比程序中断的优先级高 能产生DMA请求的总线部件是具有DMA接口的设备 中断优先级从高到低：访管-&gt;程序性-&gt; 重新启动 检测有无DMA请求，一般在存取周期结束后，而不是在指令周期结束后（易错） 设置中断屏蔽标志可以改变多个中断服务程序执行完的次序 中断方式的特点是 CPU与外设并行工作，传送与主程序串行工作 CPU响应DMA请求的条件是当前机器周期执行完 中断发生时，程序计数器内容的保护和更新是由硬件自动完成的 在DMA方式下，数据从内存传送到外设经过的路径是内存-&gt;数据总线-&gt;DMAC（DMA的数据缓冲寄存器）-&gt;外设 DMA传送前由设备驱动程序设置传送参数，传送结束后的处理由中断服务程序完成","categories":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://1nameccc.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"author":"coucou"},{"title":"数据结构——c++容器","slug":"6-3-数据结构-c++容器/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:33.743Z","comments":true,"path":"2023/08/01/6-3-数据结构-c++容器/index/","permalink":"http://1nameccc.github.io/2023/08/01/6-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-c++%E5%AE%B9%E5%99%A8/index/","excerpt":"数据结构——c++容器","text":"数据结构——c++容器 deque的基本使用123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;deque&gt; // 双向数组 /*vector对于头部的插入删除效率低，数据量越大，效率越低deque相对而言，对头部的插入删除速度回比vector快vector访问元素时的速度会比deque快,这和两者内部实现有关*/ using namespace std;int main()&#123; deque&lt;int&gt; d; for(int i=0; i&lt;10; i++)&#123; d.push_back(i); &#125; for(deque&lt;int&gt;::iterator it = d.begin(); it != d.end(); it++)&#123; cout&lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; return 0;&#125; list的基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;list&gt;/*lis.push_back() //尾插元素 lis.push_front(elem);//在容器开头插入一个元素lis.front(); //返回第一个元素.lis.back(); //返回最后一个元素.lis.pop_back();//删除容器中最后一个元素lis.pop_front();//从容器开头移除第一个元素lis.insert(pos,elem); //在pos位置插elem元素的拷贝，返回新数据的位置。lis.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。lis.erase(pos); //删除pos位置的数据，返回下一个数据的位置。lis.remove(elem); //删除容器中所有与elem值匹配的元素。lis.clear(); //移除容器的所有数据lis.assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。lis.assign(n, elem); //将n个elem拷贝赋值给本身。lis.swap(lis1); //将lis与本身的元素互换。lis.size(); //返回容器中元素的个数lis.empty(); //判断容器是否为空lis.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置lis.reverse(); //反转链表lis.sort(); //链表排序*/using namespace std;// 迭代器遍历 void print_list(list&lt;int&gt; &amp;lis)&#123; for(list&lt;int&gt;::iterator it = lis.begin(); it != lis.end(); it++)&#123; cout&lt;&lt; *it &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;int main()&#123; list&lt;int&gt; lis; for(int i=0; i&lt;10; i++)&#123; lis.push_back(i); &#125; // 插入 list&lt;int&gt;::iterator it = lis.begin(); //list容器的迭代器是双向迭代器，不支持随机访问 ++it; lis.insert(++it, 100); //it = it + 1;//错误，不可以跳跃访问，即使是+1 print_list(lis); // 删除 lis.erase(++it); lis.remove(9); // 赋值 list&lt;int&gt; lis2(lis); list&lt;int&gt; lis3(lis.begin(), lis.end()); list&lt;int&gt; lis4; lis4.assign(10, 100); // 交换 lis2.swap(lis4); // 反转 lis.reverse(); print_list(lis); // 排序 lis.sort(); // 这里可以自定义规则 mycompare &gt;&gt; lis.sort(mycompare) print_list(lis); lis.clear(); return 0;&#125; map的基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt; //map和multimap为关联式容器,底层结构是用二叉树实现。/* map中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 map和multimap区别： map不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 *//*m.size(); //返回容器中元素的数目m.empty(); //判断容器是否为空m.swap(st); //交换两个集合容器m.insert( pair&lt;T, T&gt;(element) ); //在容器中插入元素。m.clear(); //清除所有元素m.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。m.erase(begin, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。m.erase(key); //删除容器中值为key的元素。m.find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();m.count(key); //统计key的元素个数*//*成对出现的数据，利用对组可以返回两个数据 pair&lt;type, type&gt; p ( value1, value2 );*/using namespace std;void print_map(map&lt;int, string&gt; &amp;m)&#123; for(map&lt;int, string&gt;:: iterator it = m.begin(); it != m.end(); it++)&#123; cout&lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; &#125;// map容器自动按key排序 int main()&#123; map&lt;int, string&gt; m; int id = 0; string name; for(int i=0; i&lt;5; i++)&#123; cin&gt;&gt; id &gt;&gt; name; m.insert(pair&lt;int, string&gt;(id, name)); &#125; map&lt;int, string&gt;:: iterator position = m.find(2); if(position != m.end())&#123; cout&lt;&lt; position-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; position-&gt;second &lt;&lt; endl; &#125; return 0;&#125; queue的基本使用1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;queue&gt;/*入队 --- q.push()出队 --- q.pop()返回队头元素 --- q.front()返回队尾元素 --- q.back()判断队是否为空 --- q.empty()返回队列大小 --- q.size()*/using namespace std;int main()&#123; queue&lt;int&gt; qu; for(int i=0; i&lt;10; i++)&#123; qu.push(i); &#125; cout&lt;&lt;qu.size()&lt;&lt;endl; while(!qu.empty())&#123; cout&lt;&lt;qu.front()&lt;&lt;&quot; &quot;; cout&lt;&lt;qu.back()&lt;&lt;&quot; &quot;; qu.pop(); &#125; return 0;&#125; set的基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;set&gt; // set/multiset属于关联式容器，底层结构是用二叉树实现。 /*set 所有元素都会在插入时自动被排序set和multiset区别： set不允许容器中有重复的元素 multiset允许容器中有重复的元素*/ /*s.size(); //返回容器中元素的数目s.empty(); //判断容器是否为空s.swap(st); //交换两个集合容器s.insert(elem); //在容器中插入元素。s.clear(); //清除所有元素s.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。s.erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。s.erase(elem); //删除容器中值为elem的元素。s.find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();s.count(key); //统计key的元素个数*/using namespace std;void print_set(set&lt;int&gt; &amp;s)&#123; for(set&lt;int&gt;:: iterator it = s.begin(); it != s.end(); it++)&#123; cout&lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;int main()&#123; set&lt;int&gt; s; for(int i=10; i&gt;0; i--)&#123; s.insert(i); &#125; print_set(s); return 0;&#125; stack的基本使用123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;stack&gt;/*入栈 --- s.push()出栈 --- s.pop()返回栈顶 --- s.top()判断栈是否为空 --- s.empty()返回栈大小 --- s.size()*/using namespace std;int main()&#123; stack&lt;int&gt; st; // 创建栈 for(int i=0; i&lt;10; i++)&#123; st.push(i); // 入栈 &#125; cout&lt;&lt;st.size()&lt;&lt;endl; while( !st.empty() )&#123; cout&lt;&lt;st.top()&lt;&lt;&quot; &quot;; // 输出栈顶元素 st.pop(); // 出栈 &#125; return 0;&#125; vector的基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;vector&gt;/*v.empty(); //判断容器是否为空v.capacity(); //容器的容量v.size(); //返回容器中元素的个数v.resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。 v.push_back(ele); //尾部插入元素elev.pop_back(); //删除最后一个元素v.insert(const_iterator pos, ele); //迭代器指向位置pos插入元素elev.insert(const_iterator pos, int count,ele); //迭代器指向位置pos插入count个元素elev.erase(const_iterator pos); //删除迭代器指向的元素v.erase(const_iterator start, const_iterator end); //删除迭代器从start到end之间的元素v.clear(); //删除容器中所有元素v.at(int idx); //返回索引idx所指的数据v.operator[]; //返回索引idx所指的数据v.front(); //返回容器中第一个数据元素v.back(); //返回容器中最后一个数据元素v.swap(vec); // 互换容器 */using namespace std;void print_vector(vector&lt;int&gt; &amp;v)&#123; for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123; cout&lt;&lt; *it &lt;&lt; &quot; &quot;; &#125;&#125;int main()&#123; vector&lt;int&gt; v; for(int i=0; i&lt;10; i++)&#123; v.push_back(i); &#125; for(int i=0; i&lt;v.size(); i++)&#123; cout&lt;&lt; v[i] &lt;&lt; &quot; &quot;; &#125; v.push_back(100); cout&lt;&lt;endl&lt;&lt; v.at(10) &lt;&lt; endl; cout&lt;&lt; endl &lt;&lt; v.capacity()&lt;&lt; endl; print_vector(v); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++容器","slug":"c-容器","permalink":"http://1nameccc.github.io/tags/c-%E5%AE%B9%E5%99%A8/"}],"author":"coucou"},{"title":"数据结构——基础","slug":"6-4-数据结构-基础/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:40.165Z","comments":true,"path":"2023/08/01/6-4-数据结构-基础/index/","permalink":"http://1nameccc.github.io/2023/08/01/6-4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80/index/","excerpt":"数据结构","text":"数据结构 1.绪论1. 数据结构的基本概念 可以用抽象数据类型定义一个完整的数据结构 与数据存储结构无关的术语是栈， 循环队列是用顺序表表示的队列，是一种数据结构 数据的逻辑结构独立于其存储结构 在存储数据时，不仅要存储数据元素的值，还要存储数据元素之间的关系 链式存储设计时，节点内的存储单元地址一定连续 不同节点的存储单元地址可以不连续，节点内的存储单元地址必须连续 2. 算法和算法评价 一个算法应该是问题求解的步骤 算法原地工作是指算法所需的辅助空间是常量 2. 线性表1. 线性表的顺序表示 存储密度大是顺序存储结构的优点 线性表的顺序存储结构是一种随机存取的存储结构 线性表的序号是从一开始 2. 线性表的链式表示 链式存储结构比顺序存储结构能更方便的表示各种逻辑结构 静态链表需要分配较大的连续空间，插入和删除不需要移动元素 单链表中，增加一个头结点的目的是方便运算的实现 单链表中，删除最后一个元素与链表长度有关，其他操作均无关 在尾结点插入和删除数据，带头结点的双循环链表最节省时间 3. 栈，队列和数组1. 栈 栈和队列具有相同的逻辑结构 向一个栈顶指针为top的链栈（不带头结点）中插入一个X节点，则执行x-&gt;next&#x3D;top;top&#x3D;x 采用共享栈的好处是节省存储空间，降低发生上溢的可能 2. 栈和队列的应用 栈在括号应用，表达式求值，递归，进制转换，迷宫求解等中有应用 队列在层序遍历，bfs，缓冲区，页面替换算法等中有应用 4. 串 简单的模式匹配算法时间复杂度为O(mn)，KMP算法的时间复杂度为O(m+n) KMP算法求next数组（重点），视频P36 5. 树与二叉树1. 树的基本概念 树的路径长度是从树根到每个节点的路径长度的总和 树中所有节点的度数之和 &#x3D; 树的所有分支 &#x3D; 树的节点数目 - 1 设树中度为 i 的节点数为 ni 12节点数 = 各个度的节点数之和 = 1 + 分支数 n=n0+n1+n2+n3 = 1+n1+2n2+3n3 2. 二叉树的概念 非空二叉树上的叶子节点数等于度为2的节点数加1，即 n0&#x3D; n2+1 非空二叉树第k层上至多有 2^(k-1) 个节点 高度为h的二叉树至多有 2^h -1 个节点 在含有n个节点的二叉链表中，含有 n+1 个空链域 3. 二叉树的遍历与线索二叉树 在二叉树中，m是n的祖先，使用后序遍历可以找到 m 到 n的路径 在二叉树的前序，中序，后序遍历中，所有叶子节点的先后顺序完全相同 二叉树的先序和后序完全相反，二叉树一定满足只有一个叶子节点 唯一不能确定一颗二叉树的是 先序遍历和后序遍历 线索二叉树是一种物理结构，tag为0时指向孩子节点，为1时指向线索节点 二叉树在线索化后，仍不能有效求解后序线索二叉树求后序后继 后序线索树遍历仍需要 栈 的支持 3. 树，森林 将树转变成二叉树：左孩子右兄弟 将森林F转换为对应的二叉树T，F中叶节点的个数等于 T中左孩子指针为空的节点个数 在一颗二叉树中，如果某个节点的左指针为NULL，就说明这个节点在原来的森林中没有孩子，是叶子节点 4. 树与二叉树的应用 若没有编码是另一个编码的前缀，则称这样的编码为前缀编码 在哈夫曼树中只有叶子结点才能作为字符编码 对应一组权值构造出的哈夫曼树不是惟一的 哈夫曼树的度只有0和2，没有1 并查集的结构是一种 双亲表示法存储的树 并查集查找操作的时间复杂度为 O(n) 6.图1. 图的基本概念 图中有关路径的定义：由顶点和相邻顶点序偶构成的边所形成的序列 无向图的全部顶点的度的和等于边数的两倍 强连通有向图至少有 n 条边（构成环） 2. 图的存储及基本操作 无向图的度为邻接矩阵中第i行或第i列非零元素之和 一个图的邻接矩阵表示唯一，邻接表表示不唯一 在有向图的邻接表存储结构中，顶点 v 在边表中出现的次数为 顶点v的入度 解释：这里的边表不包含顶点表（即出度） 假设有n个顶点，e条边的有向表用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为O(n+e) 十字链表是有向图的链式存储结构 邻接多重表是无向图的链式存储结构 3. 图的遍历 当各边的权值相等时，广度优先算法可以解决单源最短路径问题 图的广搜使用队列，深搜使用栈 图的深搜相当于树的 先序遍历 判断有向图中是否存在回路，除了利用拓扑排序外，还可以利用 深度优先遍历，求关键路径（求最短路径不行） 使用DFS算法递归的遍历一个有环无向图，在退出递归时输出相应顶点，这样得到的顶点序列是逆拓扑有序 4. 图的应用 只要无向连通图中没有权值相同的边，则其最小生成树唯一、 最短路径一定是简单路径 若一个有向图的顶点不能排成一个拓扑序列，则判定该有向图含义顶点数大于1的强连通分量 若一个有向图具有有序的拓扑排序序列，则它的邻接矩阵必定为 三角 最小生成树代价唯一（形状可能不唯一） 7.查找1. 顺序查找和折半查找 折半查找过程所对应的判定树是一棵平衡二叉树 折半查找和二叉排序树的时间性能有时不相同 二叉排序树的查找性能和数据的输入顺序有关，最坏情况形成单支树，查找长度为O(n) 对表长为n的有序表进行折半查找，判定树的高度为 log2(n+1)向上取整 2. 树形查找 平衡二叉树（AVL）左子树与右子树的高度差称为平衡因子（-1,0,1） 节点数最少的平衡二叉树节点数的递推公式（重要） 123n1=1 n2=2n3=n1+n2+1... AVL中所有非叶子节点的平衡因子均为1，说明它的叶子节点数最少 平衡树的查询效率一般优于红黑树 一棵含有n个节点的红黑树的高度至多为 2log(n+1) 红黑树任意节点的左右子树的高度之差不超过两倍 如果红黑树的所有节点都是黑色的，那么它一定是一棵满二叉树 3. B树，B+树 B+树不同于B树的特点之一是能支持顺序查找 B树和B+树都可以用于文件索引结构 B+树更加适用于实际应用中的操作系统中的文件索引和数据库索引 4. 散列表 散列表查找成功的平均查找长度与散列因子有关，与表长无关 若在散列表中删除一个元素，不能简单地将该元素删除（在删除地方做删除标记） 采用再散列法处理冲突时不易产生聚集 使用链地址法不会引起聚集现象 8. 排序1. 排序的基本概念 排序算法的稳定性是指经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变 拓扑排序不属于内部排序方法 使用链表也可以进行排序，只不过有些排序算法不在适用 对同一线性表使用不同的排序方法进行排序，得到的排序结果可能不同 对任意n个关键字排序的比较次数至少为 log2(n!) 向上取整 2. 插入排序 插入排序：直接插入排序，折半插入排序，希尔排序 对n个元素的顺序表进行直接插入排序算法，最坏情况下所需的比较次数是n(n-1)&#x2F;2 , 最好情况下是（n-1） 与直接插入排序相比，折半插入排序减少了比较元素的次数，元素的移动次数并未改变 3.交换排序 交换排序：冒泡排序，快速排序 快速排序：当每次枢轴都把表等分位长度相近的两个子表时，速度是最快的；当表本身已经有序或者逆序时，速度最慢 递归次数与每次划分后得到的分区的处理顺序无关 快速排序的阶段性特点是：第 i 趟完成时，会有i个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，右边的数都比它大 4. 选择排序 选择排序：简单选择排序，堆排序 简单选择排序的比较次数和移动次数分别为O(n^2)，O(n) 通常，取一大堆数据中的K个最大（最小）元素时，都优先采用堆排序 向具有n个元素的堆中插入一个元素的时间复杂度为 O(logn),删除一个元素的时间复杂度为 O(logn) 构建 n 个记录的初始堆，时间复杂度为 O(n) , 进行堆排序，最坏情况下，时间复杂度为 O(nlogn) 5. 归并排序和基数排序 基数排序不需要进行关键字的比较 平均情况下空间复杂度为O(n)的是归并排序，最坏情况下空间复杂度为O(n)的是 归并排序，快速排序 对10TB的数据文件进行排序，应使用的方法是归并排序 6.各个排序算法比较 排序算法名称 时间复杂度 空间复杂度 稳定性 适用性 直接插入排序 O(n^2) O(1) 稳定 顺序存储和链式存储 折半插入排序 O(n^2) 稳定 顺序存储 希尔排序 O(n^2) O(1) 不稳定 顺序存储 冒泡排序 O(n^2) O(1) 稳定 顺序存储 快速排序 O(nlogn) O(logn) 不稳定 顺序存储 简单选择排序 O(n^2) O(1) 不稳定 堆排序 O(nlogn) O(1) 不稳定 归并排序 O(nlogn) O(n) 稳定 基数排序 O(d（n+r）) O(r) 稳定 排序趟数与序列初始状态无关的排序算法是 直接插入，简单选择，基数排序 每趟排序结束后都至少能够确定一个元素最终位置的方法是简单选择，快速，堆排序 元素的移动次数与初始排列次序无关的是基数排序 7. 外部排序 在做m路平衡归并排序的过程中，为实现输入&#x2F;内部归并&#x2F;输出的并行处理，需要设置 2m个输入缓冲区，2个输出缓冲区 如何判定添加虚段的数目？ 设度为0的节点有N0个，度为k的节点有Nk个，则对严格的k叉树有 N0 &#x3D; (k-1)Nk+1 ，由此得 NK &#x3D; （N0-1）&#x2F;(k-1) (Nk必须为整数)","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"基础","slug":"基础","permalink":"http://1nameccc.github.io/tags/%E5%9F%BA%E7%A1%80/"}],"author":"coucou"},{"title":"微信小程序——echarts可视化","slug":"7-1-微信小程序-echarts可视化/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:45.889Z","comments":true,"path":"2023/08/01/7-1-微信小程序-echarts可视化/index/","permalink":"http://1nameccc.github.io/2023/08/01/7-1-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-echarts%E5%8F%AF%E8%A7%86%E5%8C%96/index/","excerpt":"echarts的使用","text":"echarts的使用 注：使用之前需到echarts官网下载 ec-canvas 包 1. chart.wxml123456789101112131415161718192021&lt;view class=&quot;content1&quot;&gt; &lt;view class=&quot;box1&quot;&gt; &lt;ec-canvas id=&quot;mychart-dom-bar1&quot; canvas-id=&quot;one&quot; ec=&quot;&#123;&#123; ec1&#125;&#125;&quot;&gt;&lt;/ec-canvas&gt; &lt;/view&gt;&lt;/view&gt; &lt;!-- &lt;view bindtap=&quot;getTime&quot; style=&quot;color:block;font-size: 15px;margin-left: 20%;&quot;&gt;当前时间 &#123;&#123;timer&#125;&#125;&lt;/view&gt; --&gt;&lt;view class=&quot;content2&quot;&gt; &lt;view class=&quot;sitdown&quot;&gt;坐下时间(s)&lt;/view&gt; &lt;view class=&quot;box2&quot;&gt; &lt;ec-canvas id=&quot;mychart-dom-bar2&quot; canvas-id=&quot;two&quot; ec=&quot;&#123;&#123; ec2&#125;&#125;&quot;&gt;&lt;/ec-canvas&gt;&lt;/view&gt;&lt;/view&gt;&lt;view class=&quot;content3&quot;&gt; &lt;view class=&quot;history&quot;&gt;历史记录&lt;/view&gt; &lt;view class=&quot;box3&quot; &gt; &lt;ec-canvas id=&quot;mychart-dom-bar3&quot; canvas-id=&quot;three&quot; ec=&quot;&#123;&#123; ec3&#125;&#125;&quot;&gt;&lt;/ec-canvas&gt; &lt;/view&gt;&lt;/view&gt; 2. chart.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286import * as echarts from &#x27;../../ec-canvas/echarts&#x27;;var util=require(&#x27;../../utils/util&#x27;); let&#123;score,xdata,ydata,downcount,watercount&#125;=getApp().globalData; //从app.js中接收到数据const app = getApp().globalData;Page(&#123; // 页面的初始数据 data: &#123; ec1: &#123; lazyLoad:true //仪表 &#125;, ec2: &#123; lazyLoad:true //柱状 &#125;, ec3: &#123; lazyLoad:true //多柱状 &#125;, time:&quot;&quot;, month:[], //月份 // xdata:[&quot;6:30&quot;, &quot;6:45&quot;, &quot;9:30&quot;,&quot;10:00&quot;, &quot;13:30&quot;, &quot;14:40&quot;, &quot;15:50&quot;], //小时 alldata:[ [&#x27;product&#x27;, &#x27;久坐次数&#x27;, &#x27;喝水次数&#x27;, &#x27;坐下时长(h)&#x27;], //历史记录 [&#x27;3月1日&#x27;, 3, 6, 7], [&#x27;3月2日&#x27;, 6, 4, 8], [&#x27;3月3日&#x27;, 5, 6, 4], [&#x27;3月4日&#x27;, 4, 9, 3], ], downCount:downcount, waterCount:watercount, &#125;, /** * 生命周期函数--监听页面加载 */ //动态刷新 onLoad: function (options) &#123; //获取小时并传到xdata中 var that = this; setInterval(function()&#123; that.setData(&#123; // xdata: util.formatHour(new Date()), //获取小时并传到xdata中 month: util.formatMonth(new Date()), //获取月日并传到xdata中 time: util.formatTime((new Date())), &#125;); &#125;,1000); //获取到数据后渲染到图表 setTimeout(()=&gt;&#123; this.lazyComponent=this.selectComponent(&#x27;#mychart-dom-bar2&#x27;) //获取到组件 this.initone(xdata,ydata), //坐下时间 this.lazyComponent=this.selectComponent(&#x27;#mychart-dom-bar1&#x27;) //获取到组件 this.inittwo(score), //得分 this.lazyComponent=this.selectComponent(&#x27;#mychart-dom-bar3&#x27;) //获取到组件 this.initthree(this.data.alldata) //历史记录 &#125; ,1000) //定时为1S &#125;, // 下拉刷新 onRefresh:function()&#123; //导航条加载动画 wx.showNavigationBarLoading() //loading 提示框 wx.showLoading(&#123; title: &#x27;Loading...&#x27;, &#125;) console.log(&quot;下拉刷新啦&quot;); setTimeout(function () &#123; wx.hideLoading(); wx.hideNavigationBarLoading(); //停止下拉刷新 wx.stopPullDownRefresh(); &#125;, 1500) &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh:function()&#123; this.onRefresh(); this.lazyComponent=this.selectComponent(&#x27;#mychart-dom-bar2&#x27;) //获取到组件 this.initone(xdata,ydata) //坐下时间 &#125;, //坐下时间 initone(xdata,ydata)&#123; //手动初始化 this.lazyComponent.init((canvas,width,height,dpr)=&gt;&#123; let chart=echarts.init(canvas,null,&#123; width:width, height:height, devicePixelRatio:dpr &#125;) let option=getOption(xdata,ydata) chart.setOption(option) this.chart=chart //将图表实例绑定到this上，方便其他函数访问 return chart &#125;)&#125;,// 得分inittwo(Score)&#123; //手动初始化 this.lazyComponent.init((canvas,width,height,dpr)=&gt;&#123; let chart=echarts.init(canvas,null,&#123; width:width, height:height, devicePixelRatio:dpr &#125;) let option=OnitChart(Score) chart.setOption(option) this.chart=chart //将图表实例绑定到this上，方便其他函数访问 return chart &#125;)&#125;,//历史记录initthree(xydata)&#123; //手动初始化 this.lazyComponent.init((canvas,width,height,dpr)=&gt;&#123; let chart=echarts.init(canvas,null,&#123; width:width, height:height, devicePixelRatio:dpr &#125;) let option=MoreinitChart(xydata) chart.setOption(option) this.chart=chart //将图表实例绑定到this上，方便其他函数访问 return chart &#125;)&#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; //对应的wxml中的ec-canvas id this.oneComponent = this.selectComponent(&#x27;ec1&#x27;); this.oneComponent = this.selectComponent(&#x27;ec2&#x27;); this.oneComponent = this.selectComponent(&#x27;ec3&#x27;); &#125;, /** * 生命周期函数--监听页面显示 */ // 异步加载数据&#125;)// 坐下时间function getOption (xdata,ydata) &#123; return&#123; title: &#123; text: &#x27;&#x27; &#125;, xAxis: &#123; type: &#x27;category&#x27;, data: xdata &#125;, yAxis: &#123; type: &#x27;value&#x27; &#125;, series: [ &#123; data: ydata, type: &#x27;bar&#x27;, showBackground: true, backgroundStyle: &#123; color: &#x27;rgba(180, 180, 180, 0.2)&#x27; &#125; &#125; ]&#125;&#125;//得分function OnitChart(Score) &#123; return&#123; series: [ &#123; type: &#x27;gauge&#x27;, startAngle: 180, endAngle: 0, min: 0, max: 1, splitNumber: 8, axisLine: &#123; lineStyle: &#123; width: 6, color: [ [0.25, &#x27;#FF6E76&#x27;], [0.5, &#x27;#FDDD60&#x27;], [0.75, &#x27;#58D9F9&#x27;], [1, &#x27;#7CFFB2&#x27;] ] &#125; &#125;, pointer: &#123; icon: &#x27;path://M12.8,0.7l12,40.1H0.7L12.8,0.7z&#x27;, length: &#x27;12%&#x27;, width: 20, offsetCenter: [0, &#x27;-60%&#x27;], itemStyle: &#123; color: &#x27;auto&#x27; &#125; &#125;, axisTick: &#123; length: 12, lineStyle: &#123; color: &#x27;auto&#x27;, width: 2 &#125; &#125;, splitLine: &#123; length: 20, lineStyle: &#123; color: &#x27;auto&#x27;, width: 5 &#125; &#125;, axisLabel: &#123; color: &#x27;#464646&#x27;, fontSize: 20, distance: -60, formatter: function (value) &#123; if (value === 0.875) &#123; return &#x27;A&#x27;; &#125; else if (value === 0.625) &#123; return &#x27;B&#x27;; &#125; else if (value === 0.375) &#123; return &#x27;C&#x27;; &#125; else if (value === 0.125) &#123; return &#x27;D&#x27;; &#125; return &#x27;&#x27;; &#125; &#125;, title: &#123; offsetCenter: [0, &#x27;-20%&#x27;], fontSize: 10 &#125;, detail: &#123; fontSize: 15, offsetCenter: [0, &#x27;0%&#x27;], valueAnimation: true, formatter: function (value) &#123; return Math.round(value * 100) + &#x27;分&#x27;; &#125;, color: &#x27;auto&#x27; &#125;, data: [ &#123; value:Score, name: &#x27;今日综合得分&#x27; &#125; ] &#125; ] &#125;&#125;//历史记录function MoreinitChart(xydata) &#123; return&#123; legend: &#123;&#125;, tooltip: &#123;&#125;, dataset: &#123; source: xydata, &#125;, xAxis: &#123; type: &#x27;category&#x27; &#125;, yAxis: &#123;&#125;, // Declare several bar series, each will be mapped // to a column of dataset.source by default. series: [&#123; type: &#x27;bar&#x27; &#125;, &#123; type: &#x27;bar&#x27; &#125;, &#123; type: &#x27;bar&#x27; &#125;] &#125;;&#125; 3. chart.wxss12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* 得分 */.content1&#123; width: 95%; height: 400rpx; background-color: white; padding-top: 30rpx; margin-top: 30rpx; margin-left: 2.5%; border-radius: 20rpx; align-items: center;&#125;.box1 &#123; width: 120%; height: 120%; bottom: 0; margin-left: -10%;&#125;/* 坐下时间 */.content2 &#123; width: 95%; height: 700rpx; margin-left: 2.5%; background-color: white; padding-top: 30rpx; margin-top: 30rpx; margin-left: 2.5%; border-radius: 20rpx; align-items: center; &#125; .box2 &#123; width: 100%; height: 90%; bottom: 0; left: 0; margin-top: 100rpx; right: 0rpx;&#125;.sitdown&#123; float: left; width: 300rpx; height: 60rpx; padding-top: 20rpx; border-radius: 20rpx; margin-left: 28%; margin-top: 30rpx; text-align: center; background-color: whitesmoke;&#125;/* 历史记录 */.content3 &#123; width: 95%; height: 1000rpx; margin-left: 2.5%; background-color: white; padding-top: 30rpx; margin-top: 30rpx; margin-left: 2.5%; border-radius: 20rpx; align-items: center; &#125; .box3&#123; padding-top: 80rpx; margin-top: 70rpx; width: 100%; height: 80%; margin-top: 50rpx; bottom: 0; left: 0; right: 0rpx; &#125;.history&#123; width: 20%; padding-top: 20rpx; margin-top: 5rpx; margin-left: 41%; float: left; width: 300rpx; height: 60rpx; padding-top: 20rpx; border-radius: 20rpx; margin-left: 28%; margin-top: 30rpx; text-align: center; background-color: whitesmoke;&#125; 4. chart.json12345678910&#123; &quot;usingComponents&quot;: &#123; &quot;ec-canvas&quot;: &quot;../../ec-canvas/ec-canvas&quot; &#125;, &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#7cd0ce&quot;, &quot;navigationBarTitleText&quot;: &quot;可视化报告&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;enablePullDownRefresh&quot;: true&#125; 上传图片1. img.wxml12345678910111213&lt;view class=&quot;three&quot;&gt;图片&lt;/view&gt; &lt;view class=&quot;weui-uploader&quot;&gt; &lt;view class=&#x27;pics&#x27; wx:for=&quot;&#123;&#123;imgs&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:key=&quot;*this&quot;&gt; &lt;image class=&#x27;weui-uploader__img&#x27; src=&quot;&#123;&#123;item&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; mode=&quot;aspectFill&quot; bindtap=&quot;previewImg&quot;&gt; &lt;icon type=&#x27;cancel&#x27; class=&quot;delete-btn&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; catchtap=&quot;deleteImg&quot;&gt;&lt;/icon&gt; &lt;/image&gt; &lt;/view&gt; &lt;view class=&quot;tp_cont &#123;&#123;tj_ycang?&#x27;&#x27;:&#x27;hide&#x27;&#125;&#125;&quot; bindtap=&quot;chooseImg&quot;&gt; &lt;view class=&quot;tp_add&quot;&gt;+&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 2. img.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// pages/abc/abc.jsconst app = getApp();Page(&#123; data: &#123; imgs: [] &#125;, // 上传图片 chooseImg: function (e) &#123; var that = this; var imgs = this.data.imgs; if (imgs.length &gt;= 9) &#123; this.setData(&#123; lenMore: 1 &#125;); setTimeout(function () &#123; that.setData(&#123; lenMore: 0 &#125;); &#125;, 2500); return false; &#125; wx.chooseImage(&#123; // count: 1, // 默认9 sizeType: [&#x27;original&#x27;, &#x27;compressed&#x27;], // 可以指定是原图还是压缩图，默认二者都有 sourceType: [&#x27;album&#x27;, &#x27;camera&#x27;], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) &#123; // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片 var tempFilePaths = res.tempFilePaths; var imgs = that.data.imgs; // console.log(tempFilePaths + &#x27;----&#x27;); for (var i = 0; i &lt; tempFilePaths.length; i++) &#123; if (imgs.length &gt;= 9) &#123; that.setData(&#123; imgs: imgs &#125;); return false; &#125; else &#123; imgs.push(tempFilePaths[i]); &#125; &#125; // console.log(imgs); that.setData(&#123; imgs: imgs &#125;); wx.uploadFile(&#123; url: getApp().globalData.url+&#x27;/home/login/uploadQuestionFile&#x27;, //接受图片的接口地址 filePath: tempFilePaths[0], name: &#x27;file&#x27;, formData: &#123; &#x27;user&#x27;: &#x27;test&#x27; &#125;, success (res)&#123; console.log(res); const data = res.data //do something &#125; &#125;) &#125; &#125;); &#125;, // 删除图片 deleteImg: function (e) &#123; var imgs = this.data.imgs; var index = e.currentTarget.dataset.index; imgs.splice(index, 1); this.setData(&#123; imgs: imgs &#125;); &#125;, // 预览图片 previewImg: function (e) &#123; //获取当前图片的下标 var index = e.currentTarget.dataset.index; //所有图片 var imgs = this.data.imgs; wx.previewImage(&#123; //当前显示图片 current: imgs[index], //所有图片 urls: imgs &#125;) &#125; &#125;) 3. img.wxss12345678910111213141516171819202122232425262728293031323334353637383940/* 图片 */.three&#123; margin-top: 27rpx;&#125;.weui-uploader&#123; margin-top: 16rpx;&#125;.tp_add&#123; width: 152rpx; height: 152rpx; border-radius: 10rpx; opacity: 1; border: 2rpx dashed #999999; display: flex; justify-content: center; align-items: center; font-size: 59rpx;&#125;.pics &#123; float:left; position:relative; margin-right:15px; margin-bottom:15px; &#125; .pics image&#123; width: 152rpx; height: 152rpx; &#125; .delete-btn&#123; width: 20rpx; height: 20rpx; position: absolute; top: -15rpx; right: -5rpx; &#125; .weui-uploader&#123; padding: 10rpx; &#125;","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://1nameccc.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://1nameccc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"echarts可视化","slug":"echarts可视化","permalink":"http://1nameccc.github.io/tags/echarts%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"author":"coucou"},{"title":"微信小程序——云开发","slug":"7-3-微信小程序-云开发/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:12:02.648Z","comments":true,"path":"2023/08/01/7-3-微信小程序-云开发/index/","permalink":"http://1nameccc.github.io/2023/08/01/7-3-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BA%91%E5%BC%80%E5%8F%91/index/","excerpt":"小程序云开发","text":"小程序云开发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556onLaunch: function () &#123; wx.cloud.init(&#123; env:&quot;cloud1-5gffyu7d7a7a5a08&quot; // 初始化，填写环境ID &#125;)&#125;const db = wx.cloud.database().collection(&quot;test_db&quot;) // 创建数据库对象 // 增 add_data() &#123; db.add(&#123; data: &#123; name: &quot;coucou&quot; &#125;, success(res) &#123; console.log(&quot;添加成功：&quot;, res) &#125; &#125;) &#125;, // 查 select_data() &#123; db.get(&#123; success(res) &#123; console.log(&quot;查询成功：&quot;, res) &#125; &#125;) &#125;, // 删 delete_data() &#123; db.doc(this.data.db_id).remove(&#123; success(res) &#123; console.log(&quot;删除成功&quot;, res) &#125; &#125;) &#125;, // 改 change_data() &#123; db.doc(this.data.db_id).update(&#123; data: &#123; name: &quot;hhhhh&quot; &#125;, success(res) &#123; console.log(&quot;修改成功&quot;, res) &#125; &#125;) &#125;, // 上传图片 add_img() &#123; wx.cloud.uploadFile(&#123; cloudPath: &quot;my_test/1111.jpg&quot;, filePath: &quot;/image/1.jpg&quot;, success(res)&#123; console.log(&quot;上传成功&quot;, res) &#125; &#125;) &#125;,","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://1nameccc.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://1nameccc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"云开发","slug":"云开发","permalink":"http://1nameccc.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"}],"author":"coucou"},{"title":"开发工具——Markdown","slug":"8-4-开发工具-Markdown/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:13:00.197Z","comments":true,"path":"2023/08/01/8-4-开发工具-Markdown/index/","permalink":"http://1nameccc.github.io/2023/08/01/8-4-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Markdown/index/","excerpt":"My first markdown","text":"My first markdown 1.字体​ 斜体： 斜体 ​ 粗体： 粗体 2.各种线​ 删除线： 删除线 ​ 下划线： 下划线 3.列表#### 3.1无序列表 第一项 第二项 #### 3.2有序列表 第一项 第二项 4.区块​ 这是区块 区块1 区块1 5.代码1234#include &quot;bits/stdc++.h&quot;void main()&#123; printf(&quot;hello world\\n&quot;);&#125; 6.链接​ 百度 ​ https://www.baidu.com/ ​ 补充：也可以是本地文件地址 ​ 页内跳转： [跳转](#My first markdown) 7.图片​ ​ ​ 示例： ​ 8.表格 表头 表头 表头 单元格 单元格 单元格 9.数学公式$$1 + 1 &#x3D; 2$$ 10.Typora与HTML字体样式 插入表情： :happy:","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"http://1nameccc.github.io/tags/Markdown/"}],"author":"coucou"},{"title":"开发工具——Cjson","slug":"8-1-开发工具-Cjson/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:12:09.094Z","comments":true,"path":"2023/08/01/8-1-开发工具-Cjson/index/","permalink":"http://1nameccc.github.io/2023/08/01/8-1-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Cjson/index/","excerpt":"mqtt+esp8266+单片机通信","text":"mqtt+esp8266+单片机通信 注：这里特别说明，在传输数据的时候特别建议在数据末尾加上 “\\r\\n”, 避免出现各种问题 1. C语言直接编写123456789101112131415161718192021// 传进来的参数pcRes需要申请空间，不然取值失败char *pcRes = (char*)malloc(sizeof(char) * 100); // 解析出的数据int fingString(char *pcBuf, char *left, char *right, char *pcRes)&#123; char *pcBegin = NULL; char *pcEnd = NULL; pcBegin = strstr(pcBuf, left); pcEnd = strstr(pcBegin + strlen(left) + 3, right); if(pcBegin == NULL || pcEnd == NULL || pcBegin &gt; pcEnd)&#123; return 0; &#125;else&#123; pcBegin += strlen(left); memcpy(pcRes, pcBegin + 3, pcEnd - pcBegin - 3); return 1; &#125;&#125;// 数据格式json// 例：&#123;&quot;msg&quot;:&quot;led_on&quot;,&quot;temp&quot;:&quot;32&quot; &#125; 2. cJSON库2.1 cJSON数据封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247// 直接上例程，需要运行源文件需包含cJSON.c以及cJSON.h#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;cJSON.h&quot;/* Used by some code below as an example datatype. */struct record&#123; const char *precision; double lat; double lon; const char *address; const char *city; const char *state; const char *zip; const char *country;&#125;;/* Create a bunch of objects as demonstration. */static int print_preallocated(cJSON *root)&#123; /* declarations */ char *out = NULL; char *buf = NULL; char *buf_fail = NULL; size_t len = 0; size_t len_fail = 0; /* formatted print */ out = cJSON_Print(root); /* create buffer to succeed */ /* the extra 5 bytes are because of inaccuracies when reserving memory */ len = strlen(out) + 5; buf = (char*)malloc(len); if (buf == NULL) &#123; printf(&quot;Failed to allocate memory.\\n&quot;); exit(1); &#125; /* create buffer to fail */ len_fail = strlen(out); buf_fail = (char*)malloc(len_fail); if (buf_fail == NULL) &#123; printf(&quot;Failed to allocate memory.\\n&quot;); exit(1); &#125; /* Print to buffer */ if (!cJSON_PrintPreallocated(root, buf, (int)len, 1)) &#123; printf(&quot;cJSON_PrintPreallocated failed!\\n&quot;); if (strcmp(out, buf) != 0) &#123; printf(&quot;cJSON_PrintPreallocated not the same as cJSON_Print!\\n&quot;); printf(&quot;cJSON_Print result:\\n%s\\n&quot;, out); printf(&quot;cJSON_PrintPreallocated result:\\n%s\\n&quot;, buf); &#125; free(out); free(buf_fail); free(buf); return -1; &#125; /* success */ printf(&quot;%s\\n&quot;, buf); /* force it to fail */ if (cJSON_PrintPreallocated(root, buf_fail, (int)len_fail, 1)) &#123; printf(&quot;cJSON_PrintPreallocated failed to show error with insufficient memory!\\n&quot;); printf(&quot;cJSON_Print result:\\n%s\\n&quot;, out); printf(&quot;cJSON_PrintPreallocated result:\\n%s\\n&quot;, buf_fail); free(out); free(buf_fail); free(buf); return -1; &#125; free(out); free(buf_fail); free(buf); return 0;&#125;/* Create a bunch of objects as demonstration. */static void create_objects(void)&#123; /* declare a few. */ cJSON *root = NULL; cJSON *fmt = NULL; cJSON *img = NULL; cJSON *thm = NULL; cJSON *fld = NULL; int i = 0; /* Our &quot;days of the week&quot; array: */ const char *strings[7] = &#123; &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot; &#125;; /* Our matrix: */ int numbers[3][3] = &#123; &#123;0, -1, 0&#125;, &#123;1, 0, 0&#125;, &#123;0 ,0, 1&#125; &#125;; /* Our &quot;gallery&quot; item: */ int ids[4] = &#123; 116, 943, 234, 38793 &#125;; /* Our array of &quot;records&quot;: */ struct record fields[2] = &#123; &#123; &quot;zip&quot;, 37.7668, -1.223959e+2, &quot;&quot;, &quot;SAN FRANCISCO&quot;, &quot;CA&quot;, &quot;94107&quot;, &quot;US&quot; &#125;, &#123; &quot;zip&quot;, 37.371991, -1.22026e+2, &quot;&quot;, &quot;SUNNYVALE&quot;, &quot;CA&quot;, &quot;94085&quot;, &quot;US&quot; &#125; &#125;; volatile double zero = 0.0; /* Here we construct some JSON standards, from the JSON site. */ /* Our &quot;Video&quot; datatype: */ root = cJSON_CreateObject(); cJSON_AddItemToObject(root, &quot;name&quot;, cJSON_CreateString(&quot;Jack (\\&quot;Bee\\&quot;) Nimble&quot;)); cJSON_AddItemToObject(root, &quot;format&quot;, fmt = cJSON_CreateObject()); cJSON_AddStringToObject(fmt, &quot;type&quot;, &quot;rect&quot;); cJSON_AddNumberToObject(fmt, &quot;width&quot;, 1920); cJSON_AddNumberToObject(fmt, &quot;height&quot;, 1080); cJSON_AddFalseToObject (fmt, &quot;interlace&quot;); cJSON_AddNumberToObject(fmt, &quot;frame rate&quot;, 24); /* Print to text */ if (print_preallocated(root) != 0) &#123; cJSON_Delete(root); exit(EXIT_FAILURE); &#125; cJSON_Delete(root); /* Our &quot;days of the week&quot; array: */ root = cJSON_CreateStringArray(strings, 7); if (print_preallocated(root) != 0) &#123; cJSON_Delete(root); exit(EXIT_FAILURE); &#125; cJSON_Delete(root); /* Our matrix: */ root = cJSON_CreateArray(); for (i = 0; i &lt; 3; i++) &#123; cJSON_AddItemToArray(root, cJSON_CreateIntArray(numbers[i], 3)); &#125; /* cJSON_ReplaceItemInArray(root, 1, cJSON_CreateString(&quot;Replacement&quot;)); */ if (print_preallocated(root) != 0) &#123; cJSON_Delete(root); exit(EXIT_FAILURE); &#125; cJSON_Delete(root); /* Our &quot;gallery&quot; item: */ root = cJSON_CreateObject(); cJSON_AddItemToObject(root, &quot;Image&quot;, img = cJSON_CreateObject()); cJSON_AddNumberToObject(img, &quot;Width&quot;, 800); cJSON_AddNumberToObject(img, &quot;Height&quot;, 600); cJSON_AddStringToObject(img, &quot;Title&quot;, &quot;View from 15th Floor&quot;); cJSON_AddItemToObject(img, &quot;Thumbnail&quot;, thm = cJSON_CreateObject()); cJSON_AddStringToObject(thm, &quot;Url&quot;, &quot;http:/*www.example.com/image/481989943&quot;); cJSON_AddNumberToObject(thm, &quot;Height&quot;, 125); cJSON_AddStringToObject(thm, &quot;Width&quot;, &quot;100&quot;); cJSON_AddItemToObject(img, &quot;IDs&quot;, cJSON_CreateIntArray(ids, 4)); if (print_preallocated(root) != 0) &#123; cJSON_Delete(root); exit(EXIT_FAILURE); &#125; cJSON_Delete(root); /* Our array of &quot;records&quot;: */ root = cJSON_CreateArray(); for (i = 0; i &lt; 2; i++) &#123; cJSON_AddItemToArray(root, fld = cJSON_CreateObject()); cJSON_AddStringToObject(fld, &quot;precision&quot;, fields[i].precision); cJSON_AddNumberToObject(fld, &quot;Latitude&quot;, fields[i].lat); cJSON_AddNumberToObject(fld, &quot;Longitude&quot;, fields[i].lon); cJSON_AddStringToObject(fld, &quot;Address&quot;, fields[i].address); cJSON_AddStringToObject(fld, &quot;City&quot;, fields[i].city); cJSON_AddStringToObject(fld, &quot;State&quot;, fields[i].state); cJSON_AddStringToObject(fld, &quot;Zip&quot;, fields[i].zip); cJSON_AddStringToObject(fld, &quot;Country&quot;, fields[i].country); &#125; /* cJSON_ReplaceItemInObject(cJSON_GetArrayItem(root, 1), &quot;City&quot;, cJSON_CreateIntArray(ids, 4)); */ if (print_preallocated(root) != 0) &#123; cJSON_Delete(root); exit(EXIT_FAILURE); &#125; cJSON_Delete(root); root = cJSON_CreateObject(); cJSON_AddNumberToObject(root, &quot;number&quot;, 1.0 / zero); if (print_preallocated(root) != 0) &#123; cJSON_Delete(root); exit(EXIT_FAILURE); &#125; cJSON_Delete(root);&#125;int main(void)&#123; /* print the version */ printf(&quot;Version: %s\\n&quot;, cJSON_Version()); /* Now some samplecode for building objects concisely: */ create_objects(); return 0;&#125; 2.2 cJSON数据解析2.2.1 cJSON结构体1234567891011// cJSON结构体typedef struct cJSON &#123; //cJSON结构体 struct cJSON *next,*prev; /* 遍历数组或对象链的前向或后向链表指针*/ struct cJSON *child; /* 数组或对象的孩子节点*/ int type; /* key的类型*/ char *valuestring; /* 字符串值*/ int valueint; /* 整数值*/ double valuedouble; /* 浮点数值*/ char *string; /* key的名字*/&#125; cJSON; 2.2.2 cJSON常用函数123456789101112131415cJSON *cJSON_Parse(const char *value);// 作用：将一个JSON数据包，按照cJSON结构体的结构序列化整个数据包，并在堆中开辟一块内存存储cJSON结构体// 返回值：成功返回一个指向内存块中的cJSON的指针，失败返回NULLcJSON *cJSON_GetObjectItem(cJSON *object,const char *string);// 作用:获取JSON字符串字段值// 返回值：成功返回一个指向cJSON类型的结构体指针，失败返回NULLchar *cJSON_Print(cJSON *item);// 作用：将cJSON数据解析成JSON字符串，并在堆中开辟一块char*的内存空间存储JSON字符串// 返回值：成功返回一个char*指针该指针指向位于堆中JSON字符串，失败返回NULL void cJSON_Delete(cJSON *c);// 作用：释放位于堆中cJSON结构体内存// 返回值：无 2.2.3 例程11234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &quot;cJSON.h&quot; int main()&#123; char json_string[] =&quot;&#123; \\&quot;cmd\\&quot;:12, \\ \\&quot;device\\&quot;:\\&quot;lamp\\&quot;, \\ \\&quot;power\\&quot;:1, \\ \\&quot;brightness\\&quot;:50 \\ &#125;&quot;; //JSON字符串到cJSON格式 cJSON* cjson = cJSON_Parse(json_string); //判断cJSON_Parse函数返回值确定是否打包成功 if(cjson == NULL) &#123; printf(&quot;json pack into cjson error...&quot;); &#125; else &#123;//打包成功调用cJSON_Print打印输出 printf(&quot;%s\\r\\n&quot;,cJSON_Print(cjson)); &#125; //获取字段值 //cJSON_GetObjectltem返回的是一个cJSON结构体所以我们可以通过函数返回结构体的方式选择返回类型！ int test_1_string = cJSON_GetObjectItem(cjson,&quot;cmd&quot;)-&gt;valueint; char* test_2_string = cJSON_GetObjectItem(cjson,&quot;device&quot;)-&gt;valuestring; int test_3_string = cJSON_GetObjectItem(cjson,&quot;power&quot;)-&gt;valueint; int test_4_string = cJSON_GetObjectItem(cjson,&quot;brightness&quot;)-&gt;valueint; //打印输出 printf(&quot;%d\\r\\n&quot;,test_1_string); printf(&quot;%s\\r\\n&quot;,test_2_string); printf(&quot;%d\\r\\n&quot;,test_3_string); printf(&quot;%d\\r\\n&quot;,test_4_string); //delete cjson cJSON_Delete(cjson);&#125; 2.2.3 例程2（解析数组）123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &quot;cJSON.h&quot; int main()&#123; char json_arr_string[]=&quot;&#123;\\&quot;test_arr\\&quot;:[&#123;\\&quot;test_1\\&quot;:\\&quot;arr_1\\&quot;,\\&quot;test_2\\&quot;:\\&quot;arr_2\\&quot;,\\&quot;test_3\\&quot;:\\&quot;arr_3\\&quot;&#125;,&#123;\\&quot;test_1\\&quot;:\\&quot;1\\&quot;,\\&quot;test_2\\&quot;:\\&quot;2\\&quot;,\\&quot;test_3\\&quot;:\\&quot;3\\&quot;&#125;]&#125;&quot;; cJSON* cjson = cJSON_Parse(json_arr_string); if(cjson == NULL) &#123; printf(&quot;cjson error...\\r\\n&quot;); &#125; else &#123;//打包成功调用cJSON_Print打印输出 printf(&quot;%s\\r\\n&quot;,cJSON_Print(cjson)); &#125; cJSON* test_arr = cJSON_GetObjectItem(cjson,&quot;test_arr&quot;); int arr_size = cJSON_GetArraySize(test_arr);//return arr_size 2 cJSON* arr_item = test_arr-&gt;child;//子对象 for(int i = 0;i &lt;=(arr_size-1)/*0*/;++i) &#123; printf(&quot;%s\\r\\n&quot;,cJSON_Print(cJSON_GetObjectItem(arr_item,&quot;test_1&quot;))); printf(&quot;%s\\r\\n&quot;,cJSON_Print(cJSON_GetObjectItem(arr_item,&quot;test_2&quot;))); printf(&quot;%s\\r\\n&quot;,cJSON_Print(cJSON_GetObjectItem(arr_item,&quot;test_3&quot;))); arr_item = arr_item-&gt;next;//下一个子对象 &#125; cJSON_Delete(cjson);&#125; 2.3 cJSON基础1、构造json对象；2、向对象中添加元素；3、获取对象中元素；4、获取元素的值；5、json对象与数组互转；6、释放json对象空间； 从官网直接下载cJSON源文件，添加到工程中即可。 char jssd_def[256]; 2.3.1 构造json对象1234cJSON* root = NULL;cJSON* item = NULL;item = cJSON_CreateObject();root = cJSON_CreateObject(); 2.3.2 向对象中添加元素1234567// 1、将对象作为元素进行添加：cJSON_AddItemToObject(item, &quot;name&quot;, cJSON_CreateString(&quot;xiaopeng&quot;));cJSON_AddItemToObject(item,&quot;age&quot;,cJSON_CreateNumber(21));cJSON_AddItemToObject(root,&quot;root&quot;,item);// 2、直接添加元素：cJSON_AddItemToObject(root,&quot;ID&quot;,cJSON_CreateNumber(1)); 2.3.3 获取对象中元素12root = cJSON_Parse(jssd_def);item = cJSON_GetObjectItem(root, &quot;root&quot;); 2.3.4 获取元素的值123cJSON* age = NULL;age = cJSON_GetObjectItem(item, &quot;age&quot;);printf( &quot;age=%d\\r\\n&quot;, age-&gt;valueint ); 2.3.5 json对象与数组互转123456// 1、json对象转字符串sprintf(jssd_def, &quot;%s&quot;, cJSON_Print(root));//带格式化\\n\\tsprintf(jssd_def, &quot;%s&quot;, cJSON_PrintUnformatted(root));//不带格式// 2、字符串转json对象root = cJSON_Parse(jssd_def); 2.3.6 释放json对象空间 12345// 如果使用cJSON_Delete(cJSON *c);进行对象释放：当一个对象是另一个对象的元素时，只调用外层对象释放，否则会出现硬件错误；如果内层对象被释放，再释放外层对象，也会出现硬件错误。如果不放心，则可以直接使用free进行多次释放。//cJSON_Delete( root );等价于&#123;free( item );free( root );&#125;//警告：使用cJSON_Delete( root );则不能使用cJSON_Delete( item );cJSON_Delete( root );","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Cjson","slug":"Cjson","permalink":"http://1nameccc.github.io/tags/Cjson/"}],"author":"coucou"},{"title":"开发工具——Makefile&CMake","slug":"8-3-开发工具-Makefile&CMake/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:12:55.032Z","comments":true,"path":"2023/08/01/8-3-开发工具-Makefile&CMake/index/","permalink":"http://1nameccc.github.io/2023/08/01/8-3-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Makefile&CMake/index/","excerpt":"Makefile","text":"Makefile Makefile 规则格式123456789101112131415161718192021222324252627282930313233目标…... : 依赖文件集合…… 命令 1 # 命令列表中的每条命令必须以 TAB 键开始，不能使用空格！ 命令 2 ……例1：main : main.o input.o calcu.o gcc -o main main.o input.o calcu.o# 这条规则的目标是 main，main.o、input.o 和 calcu.o 是生成 main 的依赖文件例2：main: main.o input.o calcu.o gcc -o main main.o input.o calcu.omain.o: main.c gcc -c main.cinput.o: input.c gcc -c input.ccalcu.o: calcu.c gcc -c calcu.cclean: rm *.o rm main# 首先更新第一条规则中的 main，第一条规则的目标成为默认目标，只要默认目标更新了那么就认为 Makefile 的工作。在第一次编译的时候由于 main 还不存在，因此第一条规则会执行，第一条规则依赖于文件 main.o、input.o 和 calcu.o 这个三个.o 文件，这三个.o 文件目前还都没有，因此必须先更新这三个文件。make 会查找以这三个.o 文件为目标的规则并执行。例3：main: main.o input.o calcu.o gcc -o main main.o input.o calcu.o %.o : %.c # 通配符 gcc -c $&lt; # 自动化变量，依赖文件集合中的第一个文件，如果依赖文件是以模式(即“%”)定义的，那么“$&lt;”就是符合模式的一系列 的文件集合。clean: rm *.o rm main Makefile 变量12345# Makefile 变量的使用objects = main.o input.o # objects为变量objects += calcu.o # 追加main: $(objects) gcc -o main $(objects) Makefile 函数12345678910111213141516# 格式$(函数名 参数集合)# 1. 字符串替换$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)例： $(subst zzk,ZZK,my name is zzk) # 把字符串“my name is zzk”中的“zzk”替换为“ZZK”# 2. 获取目录$(dir &lt;names…&gt;)例： $(dir &lt;/src/a.c&gt;) # 返回 “/src”# 3. 提取文件名$(notdir &lt;names…&gt;)# 4. 完成循环$(foreach &lt;var&gt;, &lt;list&gt;, &lt;text&gt;) # 意思就是把参数&lt;list&gt;中的单词逐一取出来放到参数&lt;var&gt;中，然后再执行&lt;text&gt;所包含的表达式。每次&lt;text&gt;都会返回一个字符串，循环的过程中，&lt;text&gt;中所包含的每个字符串会以空格隔开，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串将会是函数 foreach 函数的返回值 CMake 源文件：CMakeLists.txt CMake常用命令12345678910111213141516171819202122232425262728293031323334353637# 0message(&quot;Hello World!&quot;) # 打印&quot;Hello World&quot;project(HELLO) # 设置工程名称为 HELLO# 1. add_executable 命令用于添加一个可执行程序目标，并设置目标所需的源文件例： add_executable(hello 1.c 2.c 3.c) # 生成可执行文件 hello# 2. add_library 命令用于添加一个库文件目标，并设置目标所需的源文件例： add_library(mylib STATIC 1.c 2.c 3.c) # 生成静态库文件 libmylib.a add_library(mylib SHARED 1.c 2.c 3.c) # 生成动态库文件 libmylib.so# 3. add_subdirectory 命令告诉 cmake 去指定的目录中寻找源码并执行它例： add_subdirectory(src) # 告诉 cmake 去 src 目录下寻找 CMakeLists.txt# 4. aux_source_directory 命令会查找目录中的所有源文件例：aux_source_directory(src SRC_LIST) # 查找 src 目录下的所有源文件 message(&quot;$&#123;SRC_LIST&#125;&quot;) # 打印 SRC_LIST 变量# 5. include_directories 命令用于设置头文件的搜索路径include_directories(include) # 头文件路径include# 6. link_directories 命令用于设置库文件的搜索路径# link_libraries 命令会将指定库文件添加到链接库列表 例： link_directories(lib) link_libraries($&#123;PROJECT_SOURCE_DIR&#125;/lib/libhello.so)# 7. target_include_directories 命令为指定目标设置头文件搜索路径# target_link_libraries 命令为指定目标设置链接库文件 例：target_link_libraries(hello-world PUBLIC libhello.so) target_include_directories(hello-world PUBLIC libhello.so)注：include_directories()、link_libraries()是针对当前源码中的所有目标，并且还会向下传递（譬如通过add_subdirectory 加载子源码时，也会将其传递给子源码）。在一个大的工程当中，这通常不规范、有时还会编译出现错误、混乱，所以我们应尽量使用 target_include_directories()和 target_link_libraries()，保持整个工程的目录清晰。# 8. set 命令用于设置变量例： set(SRC_LIST 1.c 2.c 3.c 4.c 5.c) #设置变量 VAR1=Hello message($&#123;VAR1&#125;) CMake常用变量123456789101. $(PROJECT_SOURCE_DIR) # 工程顶层目录，也就是顶层 CMakeLists.txt 源码所在目录2. $(PROJECT_BINARY_DIR) # 工 程 BINARY_DIR ， 也 就 是 顶 层 CMakeLists.txt 源码的BINARY_DIR3. CMAKE_CURRENT_SOURCE_DIR # 当前源码所在路径 4. CMAKE_CURRENT_BINARY_DIR # 当前源码的 BINARY_DIR5. EXECUTABLE_OUTPUT_PATH # 可执行程序的输出路径6. LIBRARY_OUTPUT_PATH # 库文件的输出路径例： # 设置可执行文件和库文件输出路径 set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin) set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib) CMake条件语句1234567891011121314if(expression) # then section. command1(args ...) command2(args ...) ...elseif(expression2) # elseif section. command1(args ...) command2(args ...) ...else(expression) # else section. command1(args ...) command2(args ...) CMake循环语句1234567891011121314151617181920212223242526272829303132# foreach循环foreach(loop_var arg1 arg2 ...) command1(args ...) command2(args ...) ... endforeach(loop_var) 例： # foreach 循环测试set(my_list hello world china)foreach(loop_var $&#123;my_list&#125;) message(&quot;$&#123;loop_var&#125;&quot;)endforeach()foreach(loop_var RANGE 4) # RANGE 关键字表示范围 message(&quot;$&#123;loop_var&#125;&quot;)endforeach()set(my_list A B C D)foreach(loop_var IN LISTS my_list) # IN 关键字，循环列表 message(&quot;$&#123;loop_var&#125;&quot;)endforeach()# while...break 测试set(loop_var 10)while(loop_var GREATER 0) #loop_var&gt;0 时 执行循环体 message(&quot;$&#123;loop_var&#125;&quot;) if(loop_var LESS 6) #当 loop_var 小于 6 时 message(&quot;break&quot;) break() #跳出循环 endif() math(EXPR loop_var &quot;$&#123;loop_var&#125; - 1&quot;)#loop_var--endwhile() CMake函数 通过 function()定义的函数它的使用范围是全局的，并不局限于当前 源码、可以在其子源码或者父源码中被使用 123456789101112131415161718192021222324252627# function 函数function(&lt;name&gt; [arg1 [arg2 [arg3 ...]]]) command1(args ...) command2(args ...) ...endfunction(&lt;name&gt;)例：# 函数名: xyzfunction(xyz arg1 arg2) message(&quot;$&#123;arg1&#125; $&#123;arg2&#125;&quot;)endfunction()xyz(Hello World) # 调用函数# 函数名: xyzfunction(xyz arg1 arg2) message(&quot;ARGC: $&#123;ARGC&#125;&quot;) # 传参数量 message(&quot;ARGV: $&#123;ARGV&#125;&quot;) # 传参列表 message(&quot;ARGV0: $&#123;ARGV0&#125;&quot;) # 第一个参数 # 循环打印出各个参数 set(i 0) foreach(loop $&#123;ARGV&#125;) message(&quot;arg$&#123;i&#125;: &quot; $&#123;loop&#125;) math(EXPR i &quot;$&#123;i&#125; + 1&quot;) endforeach()endfunction()# 调用函数xyz(A B C D E F G) CMake宏定义123456789101112131415161718192021macro(abc arg1 arg2) # macro 宏 if(DEFINED ARGC) message(true) else() message(false) endif()endmacro()function(xyz arg1 arg2) # function 函数 if(DEFINED ARGC) message(true) else() message(false) endif()endfunction()abc(A B C D) # 调用宏xyz(A B C D) # 调用函数# false# true CMake交叉编译1234567891011121314151617181920212223242526272829# CMakeLists.txt 配置 ARM 交叉编译cmake_minimum_required(VERSION 3.16.3)set(CMAKE_SYSTEM_NAME Linux) #设置目标系统名字set(CMAKE_SYSTEM_PROCESSOR arm) #设置目标处理器架构# 指定编译器的 sysroot 路径set(TOOLCHAIN_DIR /usr/local/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf)set(CMAKE_SYSROOT $&#123;TOOLCHAIN_DIR&#125;)# 指定交叉编译器 arm-linux-gcc 和 arm-linux-g++set(CMAKE_C_COMPILER $&#123;TOOLCHAIN_DIR&#125;/bin/arm-linux-gnueabihf-gcc)set(CMAKE_CXX_COMPILER $&#123;TOOLCHAIN_DIR&#125;/bin/arm-linux-gnueabihf-g++)# 为编译器添加编译选项set(CMAKE_C_FLAGS &quot;-march=armv7ve -mfpu=neon -mfloat-abi=hard -mcpu=cortex-a7&quot;)set(CMAKE_CXX_FLAGS &quot;-march=armv7ve -mfpu=neon -mfloat-abi=hard -mcpu=cortex-a7&quot;)set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)################################## end##################################project(HELLO) #设置工程名称add_executable(main main.c)# 编译选项 详见：https://blog.csdn.net/u013836909/article/details/107770465-march=name # 这指定了目标ARM体系结构的名称","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Makefile&CMake","slug":"Makefile-CMake","permalink":"http://1nameccc.github.io/tags/Makefile-CMake/"}],"author":"coucou"},{"title":"开发工具——Mysql","slug":"8-5-开发工具-Mysql/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:13:04.984Z","comments":true,"path":"2023/08/01/8-5-开发工具-Mysql/index/","permalink":"http://1nameccc.github.io/2023/08/01/8-5-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Mysql/index/","excerpt":"mysql 命令集","text":"mysql 命令集 1. 进入mysql1mysql -u root -p 2. 数据库查看、创建、使用123show databases; # 查看create database [name]; #创建use [name]; # 使用 3. 创建表、查看表12345creat table [name] (name VARCHAR(20), id VARCHAR(20)); # 需要初始化表项以及数据类型show tables; # 查看表# var()与varchar()的区别在于var()是定常的,哪怕存储的字符串没有达到&quot;()&quot;中数字的上限,var()依然会占用空格来填充空间.而 varchar()则是不定长的,没有达到&quot;()&quot;中的上限则会自动去掉后面的空格;、# 数据类型可以用小写.不过最好用大写来表示区分关键字, 4. 表的增删改查4.1 增1insert into [table] values([name], [id]); 4.2 删1delete from [table] where 条件(字段1=值1); 4.3 改1update [table] set 字段1=值1,字段2=值2 ... WHERE 条件; 4.4 查12345select * from [table] where 条件; # * 指所有，查找时也可以是某字段select * from [table] order by [value] desc; # 降序，升序则为 &quot;asc&quot;select count([value]) from [table] where 条件; # 计数，&quot;avg&quot; 可取平均# 查找还有许多方式这里列出部分 5. 约束条件5.1 主键约束123456789101112131415161718create table user(id int PRIMARY KEY,name VARCHAR(20)); # 所有字段都不同，允许重复+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+CREATE TABLE user2(id INT,name VARCHAR(20),password VARCHAR(20),PRIMARY key(id,name)); # 复合主键，只要所有的字段都不是相同的情况下可以允许其中的字段重复:+----+------+----------+| id | name | password |+----+------+----------+| 1 | 老李 | 123456 || 1 | 老王 | 123456 || 2 | 老王 | 123456 |+----+------+----------+# 场景:表中有班级号以及学生座位号,我们可以用班级号+学生的座位号可以准确的定位一个学生,如:(1班5号可以准确的确定一个学生) 5.2 自增约束123456789101112131415CREATE TABLE user3(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(20)); # id会自动递增，无需赋值+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+INSERT INTO user3(name) VALUES(&#x27;张三&#x27;);INSERT INTO user3(name) VALUES(&#x27;李四&#x27;);+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 |+----+------+ 5.3 唯一约束123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657CREATE TABLE user5( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20));运行 DESCRIBE user5;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+# 新增name为唯一约束:ALTER TABLE user5 ADD UNIQUE(name);运行 DESCRIBE user5;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | UNI | NULL | |+-------+-------------+------+-----+---------+----------------+# 测试:插入数据INSERT INTO user5 (name) VALUES (&#x27;cc&#x27;);运行 SELECT * FROM user5; 查看结果:+----+------+| id | name |+----+------+| 1 | cc |+----+------+再次插入INSERT INTO user5(name) VALUES (&#x27;cc&#x27;);出现:ERROR 1062 (23000): Duplicate entry &#x27;cc&#x27; for key &#x27;name&#x27;换个试试 INSERT INTO user5(name) VALUES (&#x27;aa&#x27;);运行 SELECT * FROM user5; 查看结果:+----+------+| id | name |+----+------+| 3 | aa || 1 | cc |+----+------+总结一下: 主键约束(primary key)中包含了唯一约束# 场景:业务需求:设计一张用户注册表,用户姓名必须要用手机号来注册,而且手机号和用户名称都不能为空,那么:CREATE TABLE user_test( id INT PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键id&#x27;, name VARCHAR(20) NOT NULL COMMENT &#x27;用户姓名,不能为空&#x27;, phone_number VARCHAR(20) UNIQUE NOT NULL COMMENT &#x27;用户手机,不能重复且不能为空&#x27;);运行 DESCRIBE user_test;+--------------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | NO | | NULL | || phone_number | int(11) | NO | UNI | NULL | |+--------------+-------------+------+-----+---------+----------------+这样的话就达到了每一个手机号都只能出现一次,达到了每个手机号只能被注册一次.用户姓名可以重复,但是手机号码却不能重复,复合正常的逻辑需求 5.4 非空约束1CREATE TABLE user6(name VARCHAR(20) NOT NULL COMMENT &#x27;用户姓名,不能为空&#x27;); # 非空即输入不能留空，除非设置了默认约束 5.5 默认约束1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253CREATE TABLE user6( id int PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键id&#x27;, name VARCHAR(20) NOT NULL COMMENT &#x27;用户姓名不能为空&#x27;, phone_number VARCHAR(20) NOT NULL COMMENT &#x27;用户手机号,不能为空&#x27;, status INT DEFAULT 0 COMMENT &#x27;用户状态0:启用 1:禁封 默认:0&#x27;);运行DESCRIBE user6;+--------------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | NO | | NULL | || phone_number | varchar(20) | NO | | NULL | || status | int(11) | YES | | 0 | |+--------------+-------------+------+-----+---------+----------------+插入数据:INSERT INTO user6(name,phone_number) VALUES (&#x27;aa&#x27;,&#x27;123&#x27;);INSERT INTO user6(name,phone_number) VALUES(&#x27;bb&#x27;,&#x27;1234&#x27;);INSERT INTO user6(name,phone_number) VALUES(&#x27;cc&#x27;,&#x27;1263456&#x27;);查看数据:SELECT * FROM user6;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+| 1 | aa | 123 | 0 || 2 | bb | 1234 | 0 || 3 | cc | 1263456 | 0 |+----+------+--------------+--------+我们没有设置status的值,但是给我们创建了默认值 0.应用场景:业务需求:找正常的用户,对这些正常用户进行发放优惠卷或者积分之类的东西,而被禁封的用户我们不让其参加多动.我们想要封用户只要将status的值从0改为1就行了,当然我们取用户的时候必须要先判断status是否是0.若是1.说明该用户已经被禁封.先封手机号为&#x27;1234&#x27;的用户:UPDATE user6 SET status = 1 WHERE phone_number= &#x27;1234&#x27;;SELECT * FROM user6;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+| 1 | aa | 123 | 0 || 2 | bb | 1234 | 1 || 3 | cc | 1263456 | 0 |+----+------+--------------+--------+status为1,说明用户已经被封,该用户不可以参加活动我们取用户的时候加上status的判断,如:SELECT * FROM user6 WHERE status = 0;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+| 1 | aa | 123 | 0 || 3 | cc | 1263456 | 0 |+----+------+--------------+--------+ 5.6 外键约束123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384CREATE TABLE classes( id INT PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;班级表id&#x27;, name VARCHAR(20) COMMENT &#x27;班级名称&#x27;);运行DESCRIBE classes;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;学生表id&#x27;, name VARCHAR(20) COMMENT &#x27;学生姓名&#x27;, class_id int COMMENT &#x27;教室id,这张表中的class_id是classes表中id的值&#x27;, FOREIGN KEY (class_id) REFERENCES classes(id));//FOREIGN :外来 REFERENCES:应用,参考运行DESCRIBE student;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(20) | YES | | NULL | || class_id | int(11) | YES | MUL | NULL | |+----------+-------------+------+-----+---------+----------------+班级插入数据:INSERT INTO CLASSES (name) VALUES (&#x27;一班&#x27;);INSERT INTO CLASSES (name) VALUES (&#x27;二班&#x27;);INSERT INTO CLASSES (name) VALUES (&#x27;三班&#x27;);INSERT INTO CLASSES (name) VALUES (&#x27;四班&#x27;);查看数据 SELECT * FROM classes;+----+------+| id | name |+----+------+| 1 | 一班 || 2 | 二班 || 3 | 三班 || 4 | 四班 |+----+------+学生插入数据:INSERT INTO student (name,class_id) VALUES (&#x27;小赵&#x27;,1);INSERT INTO student (name,class_id) VALUES (&#x27;小钱&#x27;,2);INSERT INTO student (name,class_id) VALUES (&#x27;小孙&#x27;,3);INSERT INTO student (name,class_id) VALUES (&#x27;小李&#x27;,4);查看数据 SELECT * FROM student;+----+------+----------+| id | name | class_id |+----+------+----------+| 1 | 小赵 | 1 || 2 | 小钱 | 2 || 3 | 小孙 | 3 || 4 | 小李 | 4 |+----+------+----------+若是像插入班级为5的数据 如:INSERT INTO student (name,class_id) VALUES (&#x27;小周&#x27;,5);报错: Cannot add or update a child row我们删除正在被学生表引用的&#x27;四班&#x27;试试:DELETE classes WHERE name = &#x27;四班&#x27;;出现:Cannot delete or update a parent row:不能删除主表中的行我们先删除学生表中的 &#x27;小李&#x27;从而解除班级中&#x27;四班&#x27;的外键约束,再来删除&#x27;四班&#x27;(因为小李引用了四班)DELETE FROM student WHERE name = &#x27;小李&#x27;;再次删除classes表中的&#x27;四班&#x27;;DELETE FROM classes WHERE name = &#x27;四班&#x27;;最后: SELECT * FROM classes;+----+------+| id | name |+----+------+| 1 | 一班 || 2 | 二班 || 3 | 三班 |+----+------+&#x27;四班&#x27;被成功删除!总结:1.主表中没有的数据,在附表中,是不可以使用的.2.主表中记录的数据现在正在被附表所引用,那么主表中正在被引用的数据不可以被删除3.若要想删除,先将附表中的数据删除在删除主表数据4.对于外键约束大家可以联想 省,市 来进行联想 (市必须要依赖于省,只要省还有一个市在引用,那么就不可以删除省,要不然市就没有省了. 那么我们想删除省,必须要将该省下所有的市全部删除之后,才可以删除这个省) 6. 约束条件的增删改1234567891011CREATE TABLE user4( id INT, name VARCHAR(20));运行DESCRIBE user4;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+ 6.1 加入主键约束12345678ALTER TABLE user4 add PRIMARY KEY(id);再次运行DESCRIBE user4;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+ 6.2 删除主键约束12345678ALERT TABLE user4 DROP PRIMARY KEY;运行DESCRIBE user4查看表结构:+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+ 6.3 修改约束12345678ALTER TABLE user4 MODIFY id INT PRIMARY KEY; # 使用modify 修改字段,添加约束使用DESCRIBE user4 查看表结构:+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+ 7. 事务","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Mysql","slug":"Mysql","permalink":"http://1nameccc.github.io/tags/Mysql/"}],"author":"coucou"},{"title":"开发工具——Git","slug":"8-2-开发工具-Git/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:12:51.804Z","comments":true,"path":"2023/08/01/8-2-开发工具-Git/index/","permalink":"http://1nameccc.github.io/2023/08/01/8-2-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git/index/","excerpt":"Git学习记录","text":"Git学习记录 一、Git基本命令1. 设置用户名和邮箱123git config --global user.name &quot;coucou&quot;git config --global user.email &quot;coucou&quot; 2. 初始化和查看日志12git initgit log 3. 添加文件和提交文件12git add test.txt // 表示文件放到暂存区git commit -m &quot;注释&quot; test.txt // -m 表注释 4. 查看工作区和暂存区状态1git status 5.删除文件123rm test.txtgit add test.txtgit commit -m &quot;删除test.txt&quot; test.txt 二、Git分支命令1. 查看、创建、切换分支123git branch branch01 // 创建分支git branch -v // 查看分支git branch branch01 // 切换分支 三、GitHub相关1. 为URL起别名以及查看别名12git remote add origin [url]git remote -v 2. 推送操作和克隆操作12git push [url] master // master表示要推送的分支git clone [url] 3. 远程库修改的拉取1git pull [url] master 四、IDEA使用Git五、实例12345git remote add cs_notes https://github.com/CyC2018/CS-Notes.git // 起别名git pull cs_notes master // 拉项目git add . // 添加到暂存区git commit -m &quot;modify test&quot; // 提交给git管理git push cs_notes master // 提交到GitHub","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"Git","permalink":"http://1nameccc.github.io/tags/Git/"}],"author":"coucou"},{"title":"微信小程序——生成二维码","slug":"7-2-微信小程序-生成二维码/index","date":"2023-08-01T00:00:00.000Z","updated":"2024-09-10T05:11:54.190Z","comments":true,"path":"2023/08/01/7-2-微信小程序-生成二维码/index/","permalink":"http://1nameccc.github.io/2023/08/01/7-2-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/index/","excerpt":"小程序生成二维码","text":"小程序生成二维码 注：使用之前需包含__weapp.qrcode.esm.js__ 文件，可到GitHub下载 1. qrcode.wxml1&lt;canvas type=&quot;2d&quot; style=&quot;width: 260px; height: 260px;&quot; id=&quot;myQrcode&quot;&gt;&lt;/canvas&gt; 2. qrcode.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// index.jsimport drawQrcode from &#x27;../../utils/weapp.qrcode.esm.js&#x27;// 获取应用实例const app = getApp()// const query = wx.createSelectorQuery()Page(&#123; data: &#123; qrcodeWidth: 0 &#125;, onLoad: function () &#123; const query = wx.createSelectorQuery() query.select(&#x27;#myQrcode&#x27;) .fields(&#123; node: true, size: true &#125;) .exec((res) =&gt; &#123; var canvas = res[0].node // 调用方法drawQrcode生成二维码 drawQrcode(&#123; canvas: canvas, canvasId: &#x27;myQrcode&#x27;, width: 260, padding: 30, background: &#x27;#ffffff&#x27;, foreground: &#x27;#000000&#x27;, text: &#x27;hello world&#x27;, &#125;) // 获取临时路径（得到之后，想干嘛就干嘛了） wx.canvasToTempFilePath(&#123; canvasId: &#x27;myQrcode&#x27;, canvas: canvas, x: 0, y: 0, width: 260, height: 260, destWidth: 260, destHeight: 260, success(res) &#123; console.log(&#x27;二维码临时路径：&#x27;, res.tempFilePath) &#125;, fail(res) &#123; console.error(res) &#125; &#125;) &#125;) &#125;, // 生成二维码&#125;)","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://1nameccc.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://1nameccc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"生成二维码","slug":"生成二维码","permalink":"http://1nameccc.github.io/tags/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"}],"author":"coucou"}],"categories":[{"name":"嵌软笔试面试","slug":"嵌软笔试面试","permalink":"http://1nameccc.github.io/categories/%E5%B5%8C%E8%BD%AF%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"},{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/categories/%E7%A1%AC%E4%BB%B6/"},{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://1nameccc.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"嵌软笔试面试","slug":"嵌软笔试面试","permalink":"http://1nameccc.github.io/tags/%E5%B5%8C%E8%BD%AF%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/"},{"name":"C语言","slug":"C语言","permalink":"http://1nameccc.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"指针&数组篇","slug":"指针-数组篇","permalink":"http://1nameccc.github.io/tags/%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84%E7%AF%87/"},{"name":"内存篇","slug":"内存篇","permalink":"http://1nameccc.github.io/tags/%E5%86%85%E5%AD%98%E7%AF%87/"},{"name":"预处理篇","slug":"预处理篇","permalink":"http://1nameccc.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86%E7%AF%87/"},{"name":"关键字篇","slug":"关键字篇","permalink":"http://1nameccc.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97%E7%AF%87/"},{"name":"操作系统","slug":"操作系统","permalink":"http://1nameccc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程&线程","slug":"进程-线程","permalink":"http://1nameccc.github.io/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"},{"name":"杂项","slug":"杂项","permalink":"http://1nameccc.github.io/tags/%E6%9D%82%E9%A1%B9/"},{"name":"Linux","slug":"Linux","permalink":"http://1nameccc.github.io/tags/Linux/"},{"name":"进程&线程实操","slug":"进程-线程实操","permalink":"http://1nameccc.github.io/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%93%8D/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"http://1nameccc.github.io/tags/FreeRTOS/"},{"name":"Linux命令","slug":"Linux命令","permalink":"http://1nameccc.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"},{"name":"UCOS3","slug":"UCOS3","permalink":"http://1nameccc.github.io/tags/UCOS3/"},{"name":"imx6ull","slug":"imx6ull","permalink":"http://1nameccc.github.io/tags/imx6ull/"},{"name":"单片机","slug":"单片机","permalink":"http://1nameccc.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"IO","slug":"IO","permalink":"http://1nameccc.github.io/tags/IO/"},{"name":"通信协议","slug":"通信协议","permalink":"http://1nameccc.github.io/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"},{"name":"配置相关术语","slug":"配置相关术语","permalink":"http://1nameccc.github.io/tags/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/"},{"name":"ARM架构","slug":"ARM架构","permalink":"http://1nameccc.github.io/tags/ARM%E6%9E%B6%E6%9E%84/"},{"name":"蓝桥杯51","slug":"蓝桥杯51","permalink":"http://1nameccc.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF51/"},{"name":"汇编","slug":"汇编","permalink":"http://1nameccc.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"网络协议","slug":"网络协议","permalink":"http://1nameccc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"常见协议","slug":"常见协议","permalink":"http://1nameccc.github.io/tags/%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/"},{"name":"TCP&UDP","slug":"TCP-UDP","permalink":"http://1nameccc.github.io/tags/TCP-UDP/"},{"name":"LVGL","slug":"LVGL","permalink":"http://1nameccc.github.io/tags/LVGL/"},{"name":"MQTT","slug":"MQTT","permalink":"http://1nameccc.github.io/tags/MQTT/"},{"name":"Zigbee","slug":"Zigbee","permalink":"http://1nameccc.github.io/tags/Zigbee/"},{"name":"硬件","slug":"硬件","permalink":"http://1nameccc.github.io/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"模拟电路","slug":"模拟电路","permalink":"http://1nameccc.github.io/tags/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://1nameccc.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数字逻辑","slug":"数字逻辑","permalink":"http://1nameccc.github.io/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"},{"name":"处理器&架构","slug":"处理器-架构","permalink":"http://1nameccc.github.io/tags/%E5%A4%84%E7%90%86%E5%99%A8-%E6%9E%B6%E6%9E%84/"},{"name":"存储","slug":"存储","permalink":"http://1nameccc.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"http://1nameccc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"实践","slug":"实践","permalink":"http://1nameccc.github.io/tags/%E5%AE%9E%E8%B7%B5/"},{"name":"理论","slug":"理论","permalink":"http://1nameccc.github.io/tags/%E7%90%86%E8%AE%BA/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://1nameccc.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"c++容器","slug":"c-容器","permalink":"http://1nameccc.github.io/tags/c-%E5%AE%B9%E5%99%A8/"},{"name":"基础","slug":"基础","permalink":"http://1nameccc.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://1nameccc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"echarts可视化","slug":"echarts可视化","permalink":"http://1nameccc.github.io/tags/echarts%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"云开发","slug":"云开发","permalink":"http://1nameccc.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"开发工具","slug":"开发工具","permalink":"http://1nameccc.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"http://1nameccc.github.io/tags/Markdown/"},{"name":"Cjson","slug":"Cjson","permalink":"http://1nameccc.github.io/tags/Cjson/"},{"name":"Makefile&CMake","slug":"Makefile-CMake","permalink":"http://1nameccc.github.io/tags/Makefile-CMake/"},{"name":"Mysql","slug":"Mysql","permalink":"http://1nameccc.github.io/tags/Mysql/"},{"name":"Git","slug":"Git","permalink":"http://1nameccc.github.io/tags/Git/"},{"name":"生成二维码","slug":"生成二维码","permalink":"http://1nameccc.github.io/tags/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"}]}