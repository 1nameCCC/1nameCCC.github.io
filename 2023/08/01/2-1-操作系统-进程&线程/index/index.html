
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>操作系统——进程&amp;线程 | 这是一个主标题</title>
    <meta name="author" content="CCC" />
    <meta name="description" content="学习一下" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="../../../../../images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="../../../../../js/lib/highlight.js"></script>



<script src="../../../../../js/lib/preview.js"></script>









<link rel="stylesheet" href="../../../../../css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="../../../../../images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>这是一个主标题</span>
        </a>
        
        <a href="../../../../../index.html">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="../../../../../about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="../../../../../archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="../../../../../categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="../../../../../tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;这是一个主标题</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="../../../../../index.html">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="../../../../../about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="../../../../../archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="../../../../../categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="../../../../../tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>操作系统——进程&amp;线程</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/8/1
        </span>
        
        <span class="category">
            <a href="../../../../../categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                操作系统
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="../../../../../tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: #03a9f4">
                    操作系统
                </a>
            </span>
            
            <span class="tag">
                
                <a href="../../../../../tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/" style="color: #00a596">
                    进程&amp;线程
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <!-- ![](1.jpg) -->

<h2 id="操作系统——进程-线程"><a href="#操作系统——进程-线程" class="headerlink" title="操作系统——进程&amp;线程"></a>操作系统——进程&amp;线程</h2><span id="more"></span>
<h3 id="进程和线程的定义"><a href="#进程和线程的定义" class="headerlink" title="进程和线程的定义"></a>进程和线程的定义</h3><blockquote>
<p>进程是资源分配的基本单位，他是程序执行是的一个实例，在程序运行时创建</p>
<p>线程是程序执行的最小单位，是进程的一个执行流，一个进程里包含多个线程</p>
</blockquote>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote>
<ol>
<li><p><strong>定义：</strong><br> 进程：进程是独立的执行单位，每个进程都有自己独立的内存空间和系统资源。进程之间通常是相互隔离的。<br> 线程：线程是进程内的执行单元，多个线程可以共享同一个进程的内存空间和系统资源。</p>
</li>
<li><p><strong>资源占用：</strong><br> 进程：每个进程都有独立的内存空间，因此占用较多的系统资源。<br>  线程：线程共享同一个进程的内存空间，因此占用的系统资源较少。</p>
</li>
<li><p><strong>通信和同步：</strong><br> 进程：不同进程之间的通信较复杂，需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等。进程之间的同步也需要额外的手段。<br>  线程：线程之间可以直接共享内存，因此通信较为简单。线程之间的同步可以使用线程同步原语，如互斥锁、信号量等。</p>
</li>
<li><p><strong>创建和销毁开销：</strong><br> 进程：创建和销毁进程通常需要较大的开销，包括分配和释放内存、建立和销毁进程控制块等。<br>  线程：创建和销毁线程的开销较小，因为它们共享了大部分进程的资源。</p>
</li>
<li><p><strong>独立性：</strong><br> 进程：进程是相对独立的，一个进程的崩溃通常不会影响其他进程。<br>  线程：线程是共享同一个进程的资源，因此一个线程的错误可能会影响整个进程。</p>
</li>
<li><p><strong>适用场景：</strong><br> 进程：适用于需要高度隔离和独立性的任务，如独立的应用程序。<br>  线程：适用于需要轻量级并发、共享数据、协同工作的任务，如多线程编程和并行计算。</p>
</li>
</ol>
</blockquote>
<h3 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h3><blockquote>
<ol>
<li><strong>创建状态（New）</strong>：当一个新的进程被创建，但操作系统尚未为其分配足够的资源或初始化必要的数据结构时，进程处于创建状态。在这个阶段，进程正在初始化，并等待操作系统分配资源。</li>
<li><strong>就绪状态（Ready）</strong>：一旦进程获得了必要的资源，它进入就绪状态。在就绪状态下，进程已准备好运行，只等待CPU的分配。多个就绪状态的进程可以等待CPU时间片，等待操作系统的调度。</li>
<li><strong>运行状态（Running）</strong>：进程进入运行状态时，它正在执行指令并占用CPU。在任何给定时间，只有一个进程可以处于运行状态。其他进程则处于就绪或阻塞状态。</li>
<li><strong>阻塞状态（Blocked）</strong>：当进程在执行中遇到需要等待某些事件发生的情况（如等待I&#x2F;O操作完成或等待其他进程的信号）时，它会从运行状态切换到阻塞状态。在阻塞状态下，进程暂停执行，直到所需事件发生。</li>
<li><strong>终止状态（Terminated）</strong>：当进程完成其任务或被操作系统终止时，它进入终止状态。在终止状态下，操作系统会回收进程的资源，包括内存空间、文件描述符等。</li>
</ol>
</blockquote>
<h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><blockquote>
<ol>
<li><strong>管道（Pipes）</strong>：管道是一种单向通信机制，通常用于父子进程之间或具有亲缘关系的进程之间。有命名管道和匿名管道两种。匿名管道在内存中创建，而命名管道则存在于文件系统中，允许无亲缘关系的进程之间通信。</li>
<li><strong>消息队列（Message Queues）</strong>：消息队列是一种通过消息进行通信的IPC方式。进程可以将消息发送到队列中，而其他进程可以从队列中接收消息。这种方式适用于异步通信，不要求发送者和接收者同时在线。</li>
<li><strong>共享内存（Shared Memory）</strong>：共享内存允许多个进程共享同一块内存区域，从而可以非常高效地进行数据交换。但需要额外的同步机制来避免数据竞争。</li>
<li><strong>信号（Signals）</strong>：信号是一种用于通知进程发生特定事件的机制，如中断或错误。进程可以发送信号给其他进程，以请求它们采取某种动作。例如，<code>SIGKILL</code>信号用于终止进程。</li>
<li><strong>套接字（Sockets）</strong>：套接字通常用于网络编程，但它们也可以在本地进程之间进行通信。本地套接字（Unix域套接字）可以实现进程之间的双向通信。</li>
<li><strong>信号量（Semaphores）</strong>：信号量是一种用于控制并发访问共享资源的IPC方式。它们可以用于同步多个进程，以确保只有一个进程可以访问临界区。</li>
</ol>
</blockquote>
<h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h3><blockquote>
<ol>
<li><strong>共享内存</strong>：多个线程可以通过访问共享内存区域来进行通信。这是一种高效的通信方式，但需要额外的同步机制来避免数据竞争。</li>
<li><strong>互斥锁（Mutex）</strong>：互斥锁用于保护共享资源，确保在任何时候只有一个线程可以访问它。当一个线程锁住互斥锁时，其他线程将被阻塞，直到该锁被释放。</li>
<li><strong>信号量（Semaphores）</strong>：信号量是一种计数器，可以用于控制多个线程对共享资源的访问。它可以用于限制同时访问资源的线程数量。</li>
<li><strong>消息队列</strong>：与进程间通信类似，线程间也可以使用消息队列进行通信。这是一种异步通信的方式。</li>
<li><strong>管道</strong>：类似于进程间通信中的管道，线程间也可以使用管道进行通信。然而，它们通常用于父子线程之间或在同一进程中。</li>
</ol>
</blockquote>
<h3 id="进程和线程通信区别"><a href="#进程和线程通信区别" class="headerlink" title="进程和线程通信区别"></a>进程和线程通信区别</h3><blockquote>
<ol>
<li><strong>共享资源</strong>：</li>
</ol>
<ul>
<li><strong>线程间通信</strong>：线程共享同一进程的内存空间，它们可以直接访问共享变量和数据结构，因此通信相对容易。但同时需要特别小心数据竞争和同步问题。</li>
<li><strong>进程间通信</strong>：进程有各自独立的内存空间，彼此之间不能直接访问，因此进程间通信需要特殊的机制来交换数据，如管道、消息队列或共享内存。</li>
</ul>
<ol start="2">
<li><strong>资源开销</strong>：</li>
</ol>
<ul>
<li><strong>线程间通信</strong>：由于线程共享进程的内存空间，通信的开销较小。</li>
<li><strong>进程间通信</strong>：进程间通信需要操作系统提供额外的资源和机制，通常开销较大，例如在不同地址空间之间传递数据需要复制数据。</li>
</ul>
<ol start="3">
<li><strong>并发性</strong>：</li>
</ol>
<ul>
<li><strong>线程间通信</strong>：由于线程共享相同的内存空间，它们可以更容易地实现并发操作，但也更容易出现竞争条件。</li>
<li><strong>进程间通信</strong>：进程之间相对更独立，通信和同步需要更多的开销，但可以提供更好的隔离性和稳定性。</li>
</ul>
<ol start="4">
<li><strong>编程难度</strong>：</li>
</ol>
<ul>
<li><strong>线程间通信</strong>：由于线程共享内存，开发者需要小心处理同步和竞争条件，以避免数据不一致或死锁等问题。</li>
<li><strong>进程间通信</strong>：进程间通信需要使用特定的IPC机制，编写代码可能相对复杂，但它提供了更好的隔离性，降低了程序的耦合度。</li>
</ul>
<ol start="5">
<li><strong>安全性</strong>：</li>
</ol>
<ul>
<li><strong>线程间通信</strong>：由于线程共享内存，必须小心处理同步，以避免数据竞争和不一致性。</li>
<li><strong>进程间通信</strong>：进程间通信通常更安全，因为进程具有独立的地址空间，相互之间不会直接影响，降低了错误传播的风险。</li>
</ul>
</blockquote>
<h3 id="僵尸-孤儿-守护进程"><a href="#僵尸-孤儿-守护进程" class="headerlink" title="僵尸&#x2F;孤儿&#x2F;守护进程"></a>僵尸&#x2F;孤儿&#x2F;守护进程</h3><blockquote>
<ol>
<li><strong>僵尸进程（Zombie Process）</strong>：</li>
</ol>
<ul>
<li>僵尸进程是已经完成执行的子进程，但其父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来获取子进程的退出状态。</li>
<li>僵尸进程的进程控制块仍然存在，但它不再执行任何操作。僵尸进程占用系统资源，但不能执行任何操作。</li>
<li>通常，父进程会在子进程退出后获取其退出状态，以释放子进程的资源，并告诉操作系统该子进程不再需要保留。如果父进程没有处理僵尸进程，它们可能会累积并浪费系统资源。</li>
</ul>
<ol start="2">
<li><strong>孤儿进程（Orphan Process）</strong>：</li>
</ol>
<ul>
<li>孤儿进程是指其父进程已经终止或意外终止，但孤儿进程仍在运行。在这种情况下，孤儿进程会被操作系统的 <code>init</code> 进程（通常具有进程ID 1）接管。</li>
<li><code>init</code> 进程成为孤儿进程的新父进程，负责回收孤儿进程的资源并管理它们的终止。</li>
</ul>
<ol start="3">
<li><strong>守护进程（Daemon Process）</strong>：</li>
</ol>
<ul>
<li>守护进程是在后台运行的系统进程，通常在系统启动时启动，以执行某种系统任务或服务，如日志记录、定时任务等。</li>
<li>守护进程通常以超级用户权限（root）运行，独立于用户会话，没有终端关联。</li>
<li>守护进程的目的是在后台执行任务，不与用户直接交互。它们通常会在系统启动时启动，并在系统关闭时停止。</li>
</ul>
</blockquote>
<h3 id="内核线程和用户线程区别"><a href="#内核线程和用户线程区别" class="headerlink" title="内核线程和用户线程区别"></a>内核线程和用户线程区别</h3><blockquote>
<ul>
<li><strong>特权级别</strong>：</li>
<li>内核线程在内核级别运行，具有更高的特权级别，可以执行特权指令和访问受限资源。</li>
<li>用户线程在用户级别运行，其执行受到限制，无法直接访问系统资源。</li>
<li><strong>调度和管理</strong>：</li>
<li>内核线程由操作系统内核直接管理，包括调度、撤销等。</li>
<li>用户线程的创建和调度由用户级线程库完成，操作系统对其无直接感知。</li>
<li><strong>开销和效率</strong>：</li>
<li>用户线程的切换和管理开销相对较小，因为它们不涉及内核的直接参与。</li>
<li>内核线程的管理开销相对较大，���它们可以更灵活地利用操作系统的各种功能。</li>
</ul>
</blockquote>
<h3 id="进程调度算法即策略"><a href="#进程调度算法即策略" class="headerlink" title="进程调度算法即策略"></a>进程调度算法即策略</h3><blockquote>
<ol>
<li><strong>先来先服务调度（First-Come, First-Served，FCFS）</strong>：</li>
</ol>
<ul>
<li>进程按照它们到达调度队列的顺序执行，先到达的进程先执行。</li>
<li>简单且容易实现，但可能导致”等待时间过长”（Convoy Effect）问题。</li>
</ul>
<ol start="2">
<li><strong>短作业优先调度（Shortest Job Next，SJN）</strong>：</li>
</ol>
<ul>
<li>选择估计执行时间最短的进程，以最小化平均等待时间。</li>
<li>也称为最短作业优先（Shortest Job First，SJF）。</li>
</ul>
<ol start="3">
<li><strong>优先级调度</strong>：</li>
</ol>
<ul>
<li>每个进程被分配一个优先级，优先级高的进程先执行。</li>
<li>静态优先级：由系统分配。</li>
<li>动态优先级：根据进程的行为和等待时间进行调整。</li>
</ul>
<ol start="4">
<li><strong>轮转调度（Round Robin，RR）</strong>：</li>
</ol>
<ul>
<li>每个进程在调度队列中轮流执行一个时间片，当时间片用尽时，被移到队列末尾等待。</li>
<li>确保每个进程都有机会执行，适用于时间共享系统。</li>
</ul>
<ol start="5">
<li><strong>多级反馈队列调度</strong>：</li>
</ol>
<ul>
<li>将就绪队列划分为多个队列，每个队列具有不同的优先级。</li>
<li>进程首先从最高优先级队列开始执行，如果时间片用尽而未完成，移至较低优先级队列。</li>
</ul>
<ol start="6">
<li><strong>最高响应比优先调度（Highest Response Ratio Next，HRRN）</strong>：</li>
</ol>
<ul>
<li>选择响应比最高的进程执行，响应比定义为（等待时间 + 服务时间）&#x2F; 服务时间。</li>
<li>优先选择等待时间较长且服务时间较短的进程。</li>
</ul>
</blockquote>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><blockquote>
<p><strong>并发</strong>是对于单个cpu来说，在一个是个只能一个进程运行，但是线程的切换时间则是减少到纳秒数量级，多个任务不停的来回切换;</p>
<p><strong>并行</strong>是对于多个CPU来说，多个进程同时运行;</p>
<p><strong>区别</strong>;并行的”同时”是同一时刻可以多个任务在运行(处于running)，并发的”同时”是经过不同线程快速切换;</p>
</blockquote>
<p><strong>死锁</strong></p>
<blockquote>
<p><strong>死锁</strong>是指多个进程在执行过程中，因争夺资源而造成互相等待，此时系统产生了死锁;</p>
<p><strong>产生条件：</strong></p>
<ol>
<li>互斥条件：进程对所分配的资源不允许其他进程访问，若其他进程需要访问，只能等待，知道该进程使用完毕后释放资源</li>
<li>请求保持条件：进程获得一定资源后，有对其他资源发出请求，但该资源被其他进程占用，此时请求阻塞，而且这个进程不会释放自己已经占有的资源</li>
<li>不可剥夺条件：进程获得资源，只能自己释放，不可剥夺</li>
<li>环路等待条件：若干进程之间形成一种头尾相接等待资源关系</li>
</ol>
<p><strong>解决：</strong>   </p>
<ol>
<li>资源一次性分配，从而解决请求保持的问题 </li>
<li>可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；</li>
<li>资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反</li>
</ol>
</blockquote>
<h3 id="多线程程序考虑加锁"><a href="#多线程程序考虑加锁" class="headerlink" title="多线程程序考虑加锁"></a>多线程程序考虑加锁</h3><blockquote>
<p>因为线程锁只要是用来实现线程的同步和通信，在抢占是操作系统中，通常为每个县城分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突</p>
</blockquote>
<h3 id="线程的中断切换"><a href="#线程的中断切换" class="headerlink" title="线程的中断切换"></a>线程的中断切换</h3><blockquote>
<ol>
<li><strong>中断发生</strong>：与进程中断一样，硬件或软件引发中断。</li>
<li><strong>内核响应</strong>：操作系统内核捕获到中断并选择相应的中断服务例程。</li>
<li><strong>当前线程上下文保存</strong>：操作系统保存当前运行线程的上下文信息，如寄存器状态、程序计数器、栈指针等。</li>
<li><strong>中断处理程序执行</strong>：执行与中断相关的处理程序，可能包括设备驱动程序、系统调用等。</li>
<li><strong>线程调度</strong>：操作系统可能决定切换到另一个线程。这可能会涉及线程调度算法。</li>
<li><strong>新线程上下文加载</strong>：如果发生线程切换，操作系统加载新线程的上下文信息。</li>
<li><strong>中断处理完成</strong>：中断处理程序执行完毕，控制返回到新的或原始的线程。</li>
</ol>
</blockquote>
<h3 id="多线程和单线程"><a href="#多线程和单线程" class="headerlink" title="多线程和单线程"></a>多线程和单线程</h3><blockquote>
<p><strong>多线程 vs. 单线程</strong>：</p>
<ol>
<li><strong>并行执行</strong>：</li>
</ol>
<ul>
<li>多线程允许多个线程同时执行，以提高系统性能，尤其在多核处理器上。</li>
<li>单线程一次只能执行一个任务，无法充分利用多核处理器。</li>
</ul>
<ol start="2">
<li><strong>资源共享</strong>：</li>
</ol>
<ul>
<li>多线程可以共享相同的内存空间，这使得线程之间的通信更容易。</li>
<li>单线程通常无法轻松地实现资源共享，因为它们运行在相对隔离的环境中。</li>
</ul>
<ol start="3">
<li><strong>复杂性</strong>：</li>
</ol>
<ul>
<li>多线程编程通常更复杂，因为需要处理竞争条件和并发问题。</li>
<li>单线程编程通常更简单，因为不需要担心并发。</li>
</ul>
<p><strong>多线程编程注意事项</strong>：</p>
<ol>
<li><strong>线程同步</strong>：确保多个线程之间的安全访问共享资源。使用互斥锁、信号量等机制来控制线程访问。</li>
<li><strong>避免竞争条件</strong>：竞争条件会导致不可预测的结果。通过合理的同步和锁定来避免竞争条件。</li>
<li><strong>线程安全数据结构</strong>：使用线程安全的数据结构，如线程安全的队列，以减少自己实现同步逻辑的复杂性。</li>
<li><strong>避免死锁</strong>：死锁是多线程编程中的常见问题。确保良好的锁定管理和避免相互等待。</li>
</ol>
<p><strong>多线程加锁注意事项</strong>：</p>
<ol>
<li><strong>锁粒度</strong>：选择适当的锁粒度。锁的范围应该足够小，以减少竞争，但不应过小，以避免锁争用带来的开销。</li>
<li><strong>锁顺序</strong>：在多个锁的情况下，确保按照相同的顺序获取锁，以减少死锁的风险。</li>
<li><strong>锁超时</strong>：在尝试获取锁时，考虑设置锁超时机制，以避免长时间等待锁导致的性能问题。</li>
<li><strong>锁性能</strong>：了解锁的性能特性，以确保不会因锁开销而降低程序性能。</li>
<li><strong>避免锁滥用</strong>：不是每个代码段都需要锁，避免过度使用锁，以避免不必要的同步开销。</li>
</ol>
</blockquote>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote>
<p><strong>线程池</strong>是为了有效管理和复用线程资源而创建的一种机制。它的存在有以下主要原因和优势：</p>
<ol>
<li><strong>降低线程创建和销毁开销</strong>：线程的创建和销毁代价较高。线程池维护一组可重用的线程，避免频繁地创建和销毁线程，从而降低开销。</li>
<li><strong>控制并发度</strong>：线程池允许您限制同时执行的线程数量，以控制系统的并发度。这有助于防止系统过载和资源饱和。</li>
<li><strong>提高响应时间</strong>：线程池使任务能够迅速排队并执行，而不必等待新线程的创建。这有助于提高系统的响应时间。</li>
<li><strong>资源管理</strong>：线程池可以帮助有效管理系统的资源，防止不受控制的线程数量导致资源耗尽。</li>
</ol>
<p>线程池的设计思路通常包括以下要点：</p>
<ol>
<li><strong>线程池大小</strong>：决定线程池可以容纳多少线程。线程池大小的选择通常取决于系统资源、性能需求和可用硬件。如果线程池太小，可能无法满足并发需求；如果太大，可能导致资源浪费和竞争条件。</li>
<li><strong>任务队列</strong>：线程池通常维护一个任务队列，其中等待执行的任务排队。新任务被提交到队列中，并由线程池中的线程异步执行。</li>
<li><strong>线程复用</strong>：线程池中的线程是可重用的，它们在完成一个任务后会从队列中获取下一个任务而不被销毁。这减少了线程创建和销毁的开销。</li>
<li><strong>线程调度</strong>：线程池负责调度线程以执行任务，通常使用调度算法（如先进先出、最短作业优先等）来选择下一个任务。</li>
</ol>
<p>线程池中线程的数量由以下因素确定：</p>
<ul>
<li><strong>系统资源</strong>：线程池的大小应受限于可用的物理内存和处理器核心数量。不宜创建过多线程，以避免资源耗尽和上下文切换开销。</li>
<li><strong>性能需求</strong>：线程池的大小应该根据应用程序的性能需求来确定。如果需要高并发性能，可以增加线程池的大小。</li>
<li><strong>任务性质</strong>：不同类型的任务可能需要不同数量的线程来获得最佳性能。某些任务可能需要更多线程来并行执行。</li>
<li><strong>硬件特性</strong>：线程池的大小还取决于硬件特性，如多核处理器的数量，以充分利用硬件资源。</li>
</ul>
</blockquote>
<h3 id="自旋锁和信号量区别"><a href="#自旋锁和信号量区别" class="headerlink" title="自旋锁和信号量区别"></a>自旋锁和信号量区别</h3><blockquote>
<p><strong>自旋锁</strong>：</p>
<ul>
<li>自旋锁是一种轻量级的锁，通常用于保护临界区，确保同时只有一个线程可以进入临界区执行。</li>
<li>当一个线程尝试获取自旋锁时，如果锁已被其他线程占用，它会不断自旋（循环检查锁状态），而不是立即被阻塞挂起。</li>
<li>自旋锁适用于短时间内的临界区保护，因为它减少了线程的上下文切换开销。但如果锁被占用时间较长，自旋可能会浪费CPU资源。</li>
</ul>
<p><strong>信号量</strong>：</p>
<ul>
<li>信号量是一种更通用的同步机制，可以用于控制并发线程的访问或控制资源的分配。</li>
<li>信号量有两种类型：二进制信号量（只有0和1）和计数信号量（可以大于1）。</li>
<li>二进制信号量通常用于互斥，即只有一个线程可以访问临界区。计数信号量用于限制同时访问某些资源的线程数量。</li>
</ul>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>等待机制</strong>：</li>
</ol>
<ul>
<li>自旋锁通过忙等待来获取锁，不会阻塞线程，<strong>不会进入睡眠</strong></li>
<li>信号量使用阻塞和唤醒机制，当线程无法获得信号量时，它将被阻塞，直到信号量可用，<strong>会进入睡眠</strong></li>
</ul>
<ol start="2">
<li><strong>用途</strong>：</li>
</ol>
<ul>
<li>自旋锁通常用于短时间内的临界区保护，以减少上下文切换开销。</li>
<li>信号量更通用，可以用于控制线程数量、资源分配和同步多个线程之间的操作。</li>
</ul>
<ol start="3">
<li><strong>适用性</strong>：</li>
</ol>
<ul>
<li>自旋锁适合用于低竞争和低争用的情况，例如多核CPU上的短期临界区。</li>
<li>信号量更适合于需要阻塞等待的场景，例如生产者-消费者问题或限制同时访问资源的情况。</li>
</ul>
</blockquote>
<h3 id="线程的同步和互斥的区别"><a href="#线程的同步和互斥的区别" class="headerlink" title="线程的同步和互斥的区别"></a>线程的同步和互斥的区别</h3><blockquote>
<p><strong>同步</strong>：</p>
<ul>
<li><strong>同步</strong>是一种协调多个线程之间的操作顺序或执行时机的机制，以确保它们按照一定的顺序或条件来执行。</li>
<li>同步通常涉及在多个线程之间建立依赖关系，以便它们协同工作或按照特定的规则执行。</li>
<li>同步机制可以包括等待其他线程完成、通知其他线程继续执行、等待条件变为真等。</li>
</ul>
<p><strong>互斥</strong>：</p>
<ul>
<li><strong>互斥</strong>是一种同步机制，用于确保在同一时间只有一个线程可以访问共享资源或进入临界区。</li>
<li>互斥锁、信号量、互斥量等是用于实现互斥的工具，它们用于防止多个线程同时访问或修改共享资源，从而避免数据竞争和不一致性。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>同步是更广泛的概念</strong>，它可以包括协调线程的任何方式，而不仅限于互斥。同步可以用于等待事件、通信、任务协作等。</li>
<li><strong>互斥是同步的一种特定形式</strong>，它关注的是线程在访问共享资源或执行临界区时的互斥性。</li>
</ul>
<p><strong>联系</strong>：</p>
<ul>
<li>互斥通常用于同步的实现中，以确保在某个时间点只有一个线程可以执行共享资源的操作。</li>
<li>同步机制可以包括互斥，但也可以包括其他形式的同步，如条件变量、信号量、屏障等，用于线程之间的协调和通信。</li>
</ul>
</blockquote>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 这是一个主标题
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;CCC
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="../../../../../js/main.js"></script>
    
    




    
</body>
</html>
