
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>数据结构——基础 | 这是一个主标题</title>
    <meta name="author" content="CCC" />
    <meta name="description" content="学习一下" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="../../../../../images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="../../../../../js/lib/highlight.js"></script>



<script src="../../../../../js/lib/preview.js"></script>









<link rel="stylesheet" href="../../../../../css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="../../../../../images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>这是一个主标题</span>
        </a>
        
        <a href="../../../../../index.html">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="../../../../../about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="../../../../../archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="../../../../../categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="../../../../../tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;这是一个主标题</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="../../../../../index.html">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="../../../../../about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="../../../../../archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="../../../../../categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="../../../../../tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>数据结构——基础</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/8/1
        </span>
        
        <span class="category">
            <a href="../../../../../categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                数据结构
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="../../../../../tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #00a596">
                    数据结构
                </a>
            </span>
            
            <span class="tag">
                
                <a href="../../../../../tags/%E5%9F%BA%E7%A1%80/" style="color: #ffa2c4">
                    基础
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <!-- ![](1.png) -->

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><span id="more"></span>
<h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h2><h3 id="1-数据结构的基本概念"><a href="#1-数据结构的基本概念" class="headerlink" title="1. 数据结构的基本概念"></a>1. 数据结构的基本概念</h3><ul>
<li>可以用<strong>抽象数据类型</strong>定义一个完整的数据结构</li>
<li>与数据存储结构无关的术语是<strong>栈</strong>，    <strong>循环队列</strong>是用顺序表表示的队列，是一种数据结构</li>
<li><strong>数据的逻辑结构独立于其存储结构</strong></li>
<li>在存储数据时，不仅要存储数据元素的值，还要存储<strong>数据元素之间的关系</strong></li>
<li>链式存储设计时，节点内的存储单元地址<strong>一定连续</strong></li>
</ul>
<p>不同节点的存储单元地址可以不连续，节点内的存储单元地址必须连续</p>
<h3 id="2-算法和算法评价"><a href="#2-算法和算法评价" class="headerlink" title="2. 算法和算法评价"></a>2. 算法和算法评价</h3><ul>
<li>一个算法应该是<strong>问题求解的步骤</strong></li>
<li>算法原地工作是指<strong>算法所需的辅助空间是常量</strong></li>
</ul>
<h2 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h2><h3 id="1-线性表的顺序表示"><a href="#1-线性表的顺序表示" class="headerlink" title="1. 线性表的顺序表示"></a>1. 线性表的顺序表示</h3><ul>
<li><strong>存储密度大</strong>是顺序存储结构的优点</li>
<li>线性表的顺序存储结构是一种<strong>随机存取的存储结构</strong></li>
<li><strong>线性表的序号是从一开始</strong></li>
</ul>
<h3 id="2-线性表的链式表示"><a href="#2-线性表的链式表示" class="headerlink" title="2. 线性表的链式表示"></a>2. 线性表的链式表示</h3><ul>
<li><strong>链式存储结构比顺序存储结构能更方便的表示各种逻辑结构</strong></li>
<li><strong>静态链表需要分配较大的连续空间，插入和删除不需要移动元素</strong></li>
<li>单链表中，增加一个头结点的目的是方便运算的实现</li>
<li><strong>单链表中，删除最后一个元素与链表长度有关，其他操作均无关</strong></li>
<li><strong>在尾结点插入和删除数据，带头结点的双循环链表最节省时间</strong></li>
</ul>
<h2 id="3-栈，队列和数组"><a href="#3-栈，队列和数组" class="headerlink" title="3. 栈，队列和数组"></a>3. 栈，队列和数组</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><ul>
<li>栈和队列具有相同的<strong>逻辑结构</strong></li>
<li>向一个栈顶指针为top的链栈（不带头结点）中插入一个X节点，则执行<strong>x-&gt;next&#x3D;top;top&#x3D;x</strong></li>
<li>采用共享栈的好处是<strong>节省存储空间，降低发生上溢的可能</strong></li>
</ul>
<h3 id="2-栈和队列的应用"><a href="#2-栈和队列的应用" class="headerlink" title="2. 栈和队列的应用"></a>2. 栈和队列的应用</h3><ul>
<li>栈在<strong>括号应用，表达式求值，递归，进制转换，迷宫求解</strong>等中有应用</li>
<li>队列在<strong>层序遍历，bfs，缓冲区，页面替换算法等</strong>中有应用</li>
</ul>
<h2 id="4-串"><a href="#4-串" class="headerlink" title="4. 串"></a>4. 串</h2><ul>
<li><strong>简单的模式匹配算法时间复杂度为O(mn)，KMP算法的时间复杂度为O(m+n)</strong></li>
<li>KMP算法求next数组（重点），视频P36</li>
</ul>
<h2 id="5-树与二叉树"><a href="#5-树与二叉树" class="headerlink" title="5. 树与二叉树"></a>5. 树与二叉树</h2><h3 id="1-树的基本概念"><a href="#1-树的基本概念" class="headerlink" title="1. 树的基本概念"></a>1. 树的基本概念</h3><ul>
<li>树的路径长度是<strong>从树根到每个节点的路径长度的总和</strong></li>
<li>树中所有节点的度数之和 &#x3D; 树的所有分支 &#x3D; 树的节点数目 - 1</li>
<li>设树中度为 i 的节点数为  ni</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">节点数 = 各个度的节点数之和 = 1 + 分支数 </span><br><span class="line">n=n0+n1+n2+n3 = 1+n1+2n2+3n3</span><br></pre></td></tr></table></figure>

<h3 id="2-二叉树的概念"><a href="#2-二叉树的概念" class="headerlink" title="2. 二叉树的概念"></a>2. 二叉树的概念</h3><ul>
<li>非空二叉树上的叶子节点数等于度为2的节点数加1，即 <strong>n0&#x3D; n2+1</strong></li>
<li>非空二叉树第k层上至多有 <strong>2^(k-1)</strong> 个节点</li>
<li>高度为h的二叉树至多有 <strong>2^h -1</strong> 个节点</li>
<li>在含有n个节点的二叉链表中，含有 <strong>n+1</strong> 个空链域</li>
</ul>
<h3 id="3-二叉树的遍历与线索二叉树"><a href="#3-二叉树的遍历与线索二叉树" class="headerlink" title="3. 二叉树的遍历与线索二叉树"></a>3. 二叉树的遍历与线索二叉树</h3><ul>
<li>在二叉树中，m是n的祖先，使用<strong>后序遍历</strong>可以找到 m 到 n的路径</li>
<li>在二叉树的前序，中序，后序遍历中，所有叶子节点的先后顺序<strong>完全相同</strong></li>
<li>二叉树的先序和后序完全相反，二叉树一定满足<strong>只有一个叶子节点</strong></li>
<li><strong>唯一不能确定一颗二叉树的是 先序遍历和后序遍历</strong></li>
<li>线索二叉树是一种<strong>物理结构</strong>，<strong>tag为0时指向孩子节点，为1时指向线索节点</strong></li>
<li><strong>二叉树在线索化后，仍不能有效求解后序线索二叉树求后序后继</strong></li>
<li><strong>后序线索树</strong>遍历仍需要 栈 的支持</li>
</ul>
<h3 id="3-树，森林"><a href="#3-树，森林" class="headerlink" title="3. 树，森林"></a>3. 树，森林</h3><ul>
<li><p>将树转变成二叉树：<strong>左孩子右兄弟</strong></p>
</li>
<li><p>将森林F转换为对应的二叉树T，F中叶节点的个数等于 <strong>T中左孩子指针为空的节点个数</strong></p>
</li>
</ul>
<p>在一颗二叉树中，如果某个节点的左指针为NULL，就说明这个节点在原来的森林中没有孩子，是叶子节点</p>
<h3 id="4-树与二叉树的应用"><a href="#4-树与二叉树的应用" class="headerlink" title="4. 树与二叉树的应用"></a>4. 树与二叉树的应用</h3><ul>
<li>若没有编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong></li>
<li><strong>在哈夫曼树中只有叶子结点才能作为字符编码</strong></li>
<li>对应一组权值构造出的哈夫曼树不是惟一的</li>
<li>哈夫曼树的度只有0和2，没有1</li>
<li>并查集的结构是一种 <strong>双亲表示法存储的树</strong></li>
<li><strong>并查集查找操作的时间复杂度为 O(n)</strong></li>
</ul>
<h2 id="6-图"><a href="#6-图" class="headerlink" title="6.图"></a>6.图</h2><h3 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1. 图的基本概念"></a>1. 图的基本概念</h3><ul>
<li>图中有关路径的定义：<strong>由顶点和相邻顶点序偶构成的边所形成的序列</strong></li>
<li><strong>无向图的全部顶点的度的和等于边数的两倍</strong></li>
<li><strong>强连通有向图至少有 n 条边</strong>（构成环）</li>
</ul>
<h3 id="2-图的存储及基本操作"><a href="#2-图的存储及基本操作" class="headerlink" title="2. 图的存储及基本操作"></a>2. 图的存储及基本操作</h3><ul>
<li>无向图的度为<strong>邻接矩阵中第i行或第i列非零元素之和</strong></li>
<li>一个图的邻接矩阵表示唯一，邻接表表示不唯一</li>
<li>在有向图的邻接表存储结构中，顶点 v 在边表中出现的次数为 <strong>顶点v的入度</strong></li>
</ul>
<p>解释：这里的边表不包含顶点表（即出度）</p>
<ul>
<li>假设有n个顶点，e条边的有向表用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为<strong>O(n+e)</strong></li>
<li><strong>十字链表是有向图的链式存储结构</strong></li>
<li><strong>邻接多重表是无向图的链式存储结构</strong></li>
</ul>
<h3 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h3><ul>
<li><p>当各边的权值相等时，广度优先算法可以解决<strong>单源最短路径问题</strong></p>
</li>
<li><p><strong>图的广搜使用队列，深搜使用栈</strong></p>
</li>
<li><p><strong>图的深搜相当于树的 先序遍历</strong></p>
</li>
<li><p>判断有向图中是否存在回路，除了利用拓扑排序外，还可以利用 <strong>深度优先遍历，求关键路径</strong>（求最短路径不行）</p>
</li>
<li><p>使用DFS算法递归的遍历一个有环无向图，在退出递归时输出相应顶点，这样得到的顶点序列是<strong>逆拓扑有序</strong></p>
</li>
</ul>
<h3 id="4-图的应用"><a href="#4-图的应用" class="headerlink" title="4. 图的应用"></a>4. 图的应用</h3><ul>
<li><strong>只要无向连通图中没有权值相同的边，则其最小生成树唯一</strong>、</li>
<li><strong>最短路径一定是简单路径</strong></li>
<li>若一个有向图的顶点不能排成一个拓扑序列，则判定该有向图<strong>含义顶点数大于1的强连通分量</strong></li>
<li>若一个有向图具有<strong>有序</strong>的拓扑排序序列，则它的邻接矩阵必定为 <strong>三角</strong></li>
<li>最小生成树代价唯一（形状可能不唯一）</li>
</ul>
<h2 id="7-查找"><a href="#7-查找" class="headerlink" title="7.查找"></a>7.查找</h2><h3 id="1-顺序查找和折半查找"><a href="#1-顺序查找和折半查找" class="headerlink" title="1. 顺序查找和折半查找"></a>1. 顺序查找和折半查找</h3><ul>
<li>折半查找过程所对应的判定树是一棵<strong>平衡二叉树</strong></li>
<li>折半查找和二叉排序树的时间性能<strong>有时不相同</strong></li>
</ul>
<p>二叉排序树的查找性能和数据的输入顺序有关，最坏情况形成单支树，查找长度为O(n)</p>
<ul>
<li>对表长为n的有序表进行折半查找，判定树的高度为 <strong>log2(n+1)向上取整</strong></li>
</ul>
<h3 id="2-树形查找"><a href="#2-树形查找" class="headerlink" title="2. 树形查找"></a>2. 树形查找</h3><ul>
<li>平衡二叉树（AVL）左子树与右子树的高度差称为平衡因子（-1,0,1）</li>
<li><strong>节点数最少的平衡二叉树节点数的递推公式（重要）</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n1=1  n2=2</span><br><span class="line">n3=n1+n2+1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>AVL中所有非叶子节点的平衡因子均为1，说明它的叶子节点数最少</li>
<li>平衡树的查询效率一般优于红黑树</li>
<li>一棵含有n个节点的红黑树的高度至多为 <strong>2log(n+1)</strong></li>
<li><strong>红黑树任意节点的左右子树的高度之差不超过两倍</strong></li>
<li><strong>如果红黑树的所有节点都是黑色的，那么它一定是一棵满二叉树</strong></li>
</ul>
<h3 id="3-B树，B-树"><a href="#3-B树，B-树" class="headerlink" title="3. B树，B+树"></a>3. B树，B+树</h3><ul>
<li>B+树不同于B树的特点之一是<strong>能支持顺序查找</strong></li>
<li>B树和B+树都可以用于文件索引结构</li>
<li>B+树更加适用于实际应用中的<strong>操作系统中的文件索引和数据库索引</strong></li>
</ul>
<h3 id="4-散列表"><a href="#4-散列表" class="headerlink" title="4. 散列表"></a>4. 散列表</h3><ul>
<li><strong>散列表查找成功的平均查找长度与散列因子有关，与表长无关</strong></li>
<li>若在散列表中删除一个元素，不能简单地将该元素删除（在删除地方做删除标记）</li>
<li><strong>采用再散列法处理冲突时不易产生聚集</strong></li>
<li><strong>使用链地址法不会引起聚集现象</strong></li>
</ul>
<h2 id="8-排序"><a href="#8-排序" class="headerlink" title="8. 排序"></a>8. 排序</h2><h3 id="1-排序的基本概念"><a href="#1-排序的基本概念" class="headerlink" title="1. 排序的基本概念"></a>1. 排序的基本概念</h3><ul>
<li><strong>排序算法的稳定性是指经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变</strong></li>
<li>拓扑排序不属于内部排序方法</li>
<li><strong>使用链表也可以进行排序，只不过有些排序算法不在适用</strong></li>
<li><strong>对同一线性表使用不同的排序方法进行排序，得到的排序结果可能不同</strong></li>
<li>对任意n个关键字排序的比较次数至少为 <strong>log2(n!) 向上取整</strong></li>
</ul>
<h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><ul>
<li><p>插入排序：直接插入排序，折半插入排序，希尔排序</p>
</li>
<li><p>对n个元素的顺序表进行直接插入排序算法，<strong>最坏情况下所需的比较次数是n(n-1)&#x2F;2 , 最好情况下是（n-1）</strong></p>
</li>
<li><p>与直接插入排序相比，折半插入排序减少了比较元素的次数，元素的移动次数并未改变</p>
</li>
</ul>
<h3 id="3-交换排序"><a href="#3-交换排序" class="headerlink" title="3.交换排序"></a>3.交换排序</h3><ul>
<li>交换排序：冒泡排序，快速排序</li>
<li><strong>快速排序：当每次枢轴都把表等分位长度相近的两个子表时，速度是最快的；当表本身已经有序或者逆序时，速度最慢</strong></li>
<li>递归次数与每次划分后得到的分区的处理顺序无关</li>
<li><strong>快速排序的阶段性特点是：第 i 趟完成时，会有i个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，右边的数都比它大</strong></li>
</ul>
<h3 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h3><ul>
<li>选择排序：简单选择排序，堆排序</li>
<li><strong>简单选择排序的比较次数和移动次数分别为O(n^2)，O(n)</strong></li>
<li><strong>通常，取一大堆数据中的K个最大（最小）元素时，都优先采用堆排序</strong></li>
<li>向具有n个元素的堆中插入一个元素的时间复杂度为 O(logn),删除一个元素的时间复杂度为 O(logn)</li>
<li>构建 n 个记录的初始堆，时间复杂度为 O(n) , 进行堆排序，最坏情况下，时间复杂度为 O(nlogn)</li>
</ul>
<h3 id="5-归并排序和基数排序"><a href="#5-归并排序和基数排序" class="headerlink" title="5. 归并排序和基数排序"></a>5. 归并排序和基数排序</h3><ul>
<li>基数排序不需要进行关键字的比较</li>
<li>平均情况下空间复杂度为O(n)的是<strong>归并排序</strong>，最坏情况下空间复杂度为O(n)的是 <strong>归并排序，快速排序</strong></li>
<li>对10TB的数据文件进行排序，应使用的方法是<strong>归并排序</strong></li>
</ul>
<h3 id="6-各个排序算法比较"><a href="#6-各个排序算法比较" class="headerlink" title="6.各个排序算法比较"></a>6.各个排序算法比较</h3><table>
<thead>
<tr>
<th>排序算法名称</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>适用性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>顺序存储和链式存储</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>O(n^2)</td>
<td></td>
<td>稳定</td>
<td>顺序存储</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>顺序存储</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
<td>顺序存储</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(logn)</td>
<td>不稳定</td>
<td>顺序存储</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d（n+r）)</td>
<td>O(r)</td>
<td>稳定</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>排序趟数与序列初始状态无关的排序算法是 <strong>直接插入，简单选择，基数排序</strong></li>
<li>每趟排序结束后都至少能够确定一个元素最终位置的方法是<strong>简单选择，快速，堆排序</strong></li>
<li>元素的移动次数与初始排列次序无关的是<strong>基数排序</strong></li>
</ul>
<h3 id="7-外部排序"><a href="#7-外部排序" class="headerlink" title="7. 外部排序"></a>7. 外部排序</h3><ul>
<li>在做m路平衡归并排序的过程中，为实现<strong>输入&#x2F;内部归并&#x2F;输出的并行处理</strong>，需要设置 <strong>2m个输入缓冲区，2个输出缓冲区</strong></li>
<li>如何判定添加虚段的数目？</li>
</ul>
<p>设度为0的节点有N0个，度为k的节点有Nk个，则对严格的k叉树有 N0 &#x3D; (k-1)Nk+1 ，由此得 <strong>NK &#x3D; （N0-1）&#x2F;(k-1)</strong>  (Nk必须为整数)</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 这是一个主标题
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;CCC
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="../../../../../js/main.js"></script>
    
    




    
</body>
</html>
